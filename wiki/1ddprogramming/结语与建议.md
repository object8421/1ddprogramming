结语与建议 
\title

读者应选择而读,比如如果你只是程序员,那么,你可以选择第二部分阅读,如果你是图形爱好者,那么你可以读第三部分相关的章节

东西，在程序内抽象上和程序外产品上能做到几个差不多的就得了

最后编程就是这么多东西（任何领域的开发，上有起点（通用平台语言设计数据结构类抽象），下有局限(领域抽象)，其实能抽象被软件化的都是有限度的，不必做太多），不要想多了，现实生活才是我们要着力关注的。

就像比尔盖子说商业，比尔说，商业不就是获利减去成本吗？做生意还有其它事吗？所以他关注技术而鲍维尔关注商业。而编程，无非就是按抽象编程，就是按各人对抽象的理解编程，以此来决定对抽象的安排，并作为一个或大或小的设计师考虑到他设计出的类组成一个app是否逻辑上完备，编程无非不就是这个过程吗？


好了,书写到这,虽然学无止境[^1],但毕竟我们只是想学C,C++,Python来进行一般的系统开发和一点高阶的桌面应用开发,以及图形开发而已,不要拆腾了,让我们结束吧, 如何所学挣钱，学点经济学，比如软件如何盈利，软件公司如何拉单，持之一生的挣钱心态才是head first的！！

就这样吧,愿与你分享学习编程途中带来的一切喜悦,那怕是带着痛苦的喜悦.

唯手熟尔,是的,我欣赏这句！！

>理论指明了知识体系的框架,实践才能在这个框架不断完善知识大厦,而且较之理论,实践的意义还在于:一个tomato你听了一千遍,可能不知道它是什么,但只要你尝过一口,一定永生不忘.(但这需要本书第一部分到第四部分的铺垫才能把门槛降到这里.)

而且,永远记住,不要沉迷于编程,虽然本书谈的是《编程的那些事儿》,但其实,人的那些事儿更有意思[^2]！！

\section1-----------全书完\section1-----------

更多及后续更新请骚扰官网: [http://www.xisofts.com/]()

专业程序员的知识结构
\section1

什么是编程要学的.首先给出一张图.图中从某些侧面描述了编程知识结构.

专业程序员的知识结构

学习时所一开始站的难度和起点不同,后来的成就也就不同,如果不一开始学编译原理,那么以后学习高级语言中所碰到的问题都会求助于自己不完整不正确的经验,就会产生形而上学的错误, 在类C语言中,对于指针等复杂易混淆的语言的细节问题的把握,只要从类型的角度去把握,你就把握了一切.**一门语言的最本质的东西就是其类型系统,任何语言都有自己的独特的类型系统,学习一门语言首先就是学习它的类型系统.再学习它经由类型这种基础设施导致的其它语法机制**. 还比如左值右值的区别其实是类型问题,而类型一开始存在于编译器和编译原理,所以左值右值问题一开始首先应该是编译逻辑,如果你有编译原理方面的基础知识,那么你很快会找到这条从源头上分清问题的清晰渠道. 这样才不会从其它的角度去理解,不但走太多弯路而且易淆,学习中最重要的是这条线. 而本书正是这样来解释指针解释左右值的.我们在前面提到:具体到某个问题,即使是再简单的问题,都不能以某个简单的形式被讨论,而必须从某个维度和某个大范围被讨论,实际上我们能想到的联系都是知识,知识是人类多年把简单的东西弄得复杂化的共工,有一些可以被证明为正确,另一些不正确或即使正确却不受人吹捧的渐渐流失而已,其中有一些被归纳出来,形成某个领域的支撑学科,,但正如知识是某个领域的归纳一样,知识也本多维,如果仅想从IT去认识IT,,那么你会看不到全部,也会不知道很多学习IT需要学到的其它维度的知识[^14],就像有些知识是为了跟人结合而产生的一样[^15],是为了探索一个领域的东西却总是无法不避象涉及到另外领域的事物一样.. 我们现在的编程语言和编程方式,语言提供什么样的语法机 ,人们需要以什么方式写逻辑, 都不纯是狭隘的编程的知识,,而是跟程序运行环境和整个软工有关有关的,就像必须先明白基础的编译原理抽象领域的知识,才能用更好地理解一门高级语言的语法机制一样,而编译原理本身,是跟人密切有关的(比如其形式语言理论是人的理论) 只要学习C语言,计算机系统知识,语言实现原理,网络原理这些系统知识(或者只是了解吧,这本书正是极力尝试让初学者达成这个目标),才能从一个比较大的侧面去看待现实问题对于计算机的实现问题(也即编程问题),,也只有这样,只有懂C,懂编译原理,懂计算机系统,懂网络,才能从一种大局的高度去看待并计划你的系统你的应用.. 对于计算机专业来说,为什么也才那么几门课程(高数线代离散,编译原理,C与算法),,因为这些学科是最重要的,是人类把复杂的东西归为某些唯度的产物,比如把现实问题对于计算机开发的实现归结为专门的一门数据结构学[^16],计算机专业学生的那些课,,数结,C,操作系统,都是无比珍贵的东西 ,,学校设立这些课而不是C++,不是RUBY,设计模式,high level web开发,是因为那些才是可以解释后来一切的底层 ,,而并非一种舍本未未的作法..

>当然我并非在说编程一定要精通如上的每一门学科,有人在不明白STL原理的基础上照样可以能用它熟练地开发应用,注意我这里说的是会用,人们可以不懂STL原理和任何实现却照样可以拿来熟练使用的人大有人在.但那会是有相当局限的,至少,因为语言就是处理三个东西” 平台,语言,要解决的问题”之间的关系,如果你甚至都不理解编译原理是解释高级语言的实现原理,那么你就不明白类型为什么而来,也就不能进而理解class为什么存在,又抽象了什么样的数据本质,以及其它一切一切很多东西,仅仅满足于使用工具的人,永远都不会主动到去创新,那其实是处于一种未开化的状态.

>因为**编程是计算机科学，软件原理，软件工程设计的综合**，所以要理解编程的全貌，其基本模型是这样的：理解计算机需要理解硬件，软件平台的OS，理解软件需要从抽象角度去理解软件实现（数据结构与算法对问题的实现抽象建模），高级方案（编程业界对问题的高级抽象建模）,理解编程就需要理解语言语法和设计方法实践过程等等。即，如果说计算机科学强烈地与离散数学相关，那么软件作为一种抽象，理解它就需要从哲学角度进行，编程作为处理而软件与人关系的学科，软件工程和软件**设计就更多地是一种艺术**。

下面我浅显地一一介绍下这些基础学科,更多的东西你可以自行Google 离散数学,,就是对一切计算机相关的离散形式[^17]的讨论, 是整个计算机某种意义上的支撑学科,计算机和程序语言环境,和语言本身都是本质上一些离散形式, 在解释计算机本身和阐述计算机开发方面都有涉及[^18],比如图灵机就是程序模型,是个离散东东,在编译原理中体现就更明显了,比如函数语言实际上就是一种高次方程的离散,递归实际上是某个离散概念,数据结构中的图一开始是个离散数学的课题.等等. 汇编基础:解释了硬件系统的架构,即CPU它是有架构和处理功能的,而且它还在PC架构中作为控制内存等其它PC设备的主模块而存在, 因此CPU在整个硬件架构上的地位与作用是要层的,学习中要涉及到数制,寄存器,内存地址等 操作系统课程,如果说汇编基础解释了解硬件系统平台,那么这就是解决的软件平台的问题, 要学习到的跟底层相关的抽象概念和运作机制,,这些知识对编程,尤其是系统编程是尤为必须的,比如进程,比如并发,比如异常,, 编译原理的本质是什么呢,,,如果说硬件和操作系统都是解释了软硬件平台(程序运行平台),那么编译原理就解释了程序语言本身的本质,我们今天能用高级语言进行开发,是因为编译器为我们隐藏了相当多的机器细节,那些在机器编程时必须事事亲躬的二进制的东西[^19],而我们,也必须了解基本的编译原理方面的抽象来了解高级语言的一些知识,比如本文开始时用类型机制来解释指针和左右值的行为. 那么C语言课程呢, C语言这门课程最最重要的意义在于C是过程式语言的代表,它解释了一切后来的高级语言比如Ruby,比如Java,的那些基本的过程语法机制,它是过程式命令编程范式的代表,世界上用得最大的编程语言不是Java,不是Ｒuby,不是Vb,而是C,历史上地,C一度是Unix专用系统编程语言和通用系统编程语言, 系统编程语言提供了强大的底层系统编程能力,用C来作系统编程时,它可以提供较快的运行速度[^20],接近底层的更好控制[^21],C语言加数据结构算法的方式解释了计算机产生逻辑的根本[^22],只有深克地理解了这些语言级和数据结构级的抽象,那些操作系统级的高级抽象就有被准确理解的可能性了,不过正因为C语言是靠近机器的(严格来说是靠近系统),它要求人用机器的思维方式来编程,在一些不需要系统速度要求的地方显得开发效益过低,所以需要Ｒuby,Python等高阶语言用来作面向程序员的高级脚本编程,所谓脚本语言,就是相对系统编程语言来说的,而Ｒuby等脚本语言提供了调用这些系统功能的高级应用层的开发[^23]．．

为什么写本书
\section1

为什么要写这样一本书,这个在《选读》的一开始已有详细的说明(有人说那过长,我觉得,作为阐明全书主旨的部分,如果其内容过于精简,那么它反而会使人产生错觉,而这个内容,又是全书的中心和待交待的前提),我想我还是有理想的人,我的初衷并非简单地完成一本书,我只是觉得理应把一个原本的那样的东西呈现出来,而不像我鲜见到那样的书那样.

为什么写成这样
\section1

所有的教学实践只给你一个起点动作，而不是全部（只有通用的静态技术参考书，没有通用的实践全包方案参考），bcxszy并不能给你一套在任何情镜下都适用的实践，它只给你以指导，但是它的框架性作用是巨大的，它假设了并focus on一个common programming scheda
bcxszy中，common programming schedma 是任何domain programming based on it的基础，，，我们选择了gameprogramming作为例子，（重点是common，game只是例子），，并尽量体现这个领域对common引用 
并在体现这个领域对common方方面面引用的同时，尽量体现这个例子领域的全部，以体现一个严肃的应用，详细的设计开发过程（这在实践教学指导中是必不可少的） 



这是一本很容易扩展成为《head first》系列的书,但是我现在没有时间去细写了

在没写完这本书之前,我就想,我就一定会很快写完它,事实上,这本书开工的前三个月,这个目标早就达到了,但是那时的书只是一个草稿中的草稿,换言之,几百页内容的大聚集.

事实上,在要想到把一本书写好而个人又没有多少时间的情况下,我更愿意选择迭代的方式,我一向不不认为花几个月的时间写出来的东东必然不是个精品,也不认为花几年但以毫无组织的方式写出来的东西一定是个东西,事实上如果真要想把一片大范围理论的东西以集邮样的方式将它们归类在一本书里(而并不落入市面上那些诸如《xx大全》之类内容空乏的书的套路)只有作者本人才知道那会是一个多么大的工程.因为作者需要把一个世界呈现给别人看,我喜欢看沧月和今何在的书,那些用简单的字眼成就的巨大精致背后,我猜想那必定是一个心怀狂热之梦的少年般的心事的源发.所以,这本书的前期基本上是一个草稿,经过不停的迭代,当它发展到今天,它就成了这样一本书.

>我将从编程的最初起源讲起, 在我写文章的时候我并不会用故事的形式,因为在讲述道理的时候,除非就事论事(而不是用故事的形式),否则故事这种形式将会带给人们更多其它维度的困惑,这也是我一开始不把它写成headfirst系列风格的原因.保持书的原味要紧，而不是把它改成headfirst系列

教学，需要在适当的层次安排适当的抽象，拿捏好算法抽象与封装抽象的聚合度，故mpge.visual,epage.social中，就他们各自表达的领域，并没有仅提供一个仅是框架的意思
 
bcxszy在选材上花费了巨量的时候，它力求呈现一个全面的编程,,书和addons源码的定位一直在变

bcxszy.book主要的时间花在：思考什么样的组织便于最大清希化地教育。几乎做到了极致和方方面面，从书的章节排版，epage,mywar程序的
抽象组织，二进制组件，产品结构，甚至到书的文件夹组织等。

mpge至少要做到产品完备，文档丰富，源码整齐，使用的语言技法单一，技术点突出，抽象组织合理。

从ver30开始，，mpge的份量大于bcxszy并成为主要攻坚对象


关于学习态度
\section1

>转自baidu贴吧某人的发言

现在想起来觉得以前的时候自己的确是有些无知，当初甚至我连什么是神经网络还没弄清楚的时候就幼稚得附和ruiaijun，那时候可能心里只是一种直觉。

说这些话当然首先是建议朋友们去学习一些简单的多层神经网络，最终你才会明白为什么这种神经网络不是我们想要的，但是你也会体会到那些数学大师们精妙的思想，记得有人给出神经网络本质是非线性自适应系统，我觉得可能对于一些朋友不是通俗易懂，我倒觉得神经网络更像是为一个玩具建了一所房子，这所房子并不一定完全正好装下这个玩具，因为这个东西棱角很多，没有必要或者没有可能建立一个完全装下这个玩具的房子，但是正因为如此，你的这个房子就具有了装下一个与原来你的玩具近似的玩具，并不一定完全相同。我不知道这样说是否通俗易懂，反正我觉得现在机器学习课程就是讲的这些！

好了，现在你看到某人嘲笑你不懂：遗传算法，神经网络，专家系统。。的时候，你不要害怕了，也不用觉得自己一无所知，别人仿佛就是上知天文下知地理，因为你未必想为你的玩具建立一个这样的房子呢！但是如果你喜欢这样的房子，那就去学习各种算法吧，向那些数学大师们致敬，虽然他们并没有能要为AI建立一个这样的房子，或者着根本就不能，我们也不需要，但是：They are great!

关于学习方法
\section1

对于学习方法,有二点区别是要深刻明白的,1,认识与实践 2,思想与细节. 知识是事物之间的联系,那么实践就是强化或深入这些联系的方法,我常想,到底是什么重要,是认知还是技能,人们普遍认为实践应在任何情况下都高于认识,事实是:可能有技能但是没有认知,但却不可能有认知却没有技能,就拿学习英语来说吧,看英语报纸也是一种实践,因为它也能够加强你实际使用英语的能力,(我不是在模糊这二者之间的区别,我只是企图站在这二者之上求得一种更泛化的认识),实践不过更侧重动手能力而已,而认知跟它并不矛盾

>想象一下你是南昌人从小在南昌长大,然后你到赣州去,你能听得懂他们的方言,但就是说不出来这个道理,,,对,你对赣州的方言有认知但没有实践,你只要肯说肯定就能学会,但如果你去的是藏族人的地方,你听不懂那里的语言,你根本就没有基本的认知,所谓实践,就根本难于谈起了.写源程序并不是实践的全部意义,换言之,说不说,也并不是实践的全部意义.那些为写源程序作铺垫的学习过程,也是实践,只不过实践专指一种动手过程而已.

知识的获得与能否运用知识本身无必然因果,拥有足够的知识,再加上泛型的思维,,你就会快速得以实践[^24],一切都是一种格物致知的过程,只有格物至知,先格物,认识到了一定程序后就会产生对事物本质的认识,也可先认识事物本质再在指导下去发展技能,但是认知可以直接传递给你(至此只是一个你所能想象得到的浅层和大概,而且除非实践,这个大概形象你也不知道它到底是正确的还是错误的,更深层的你想象不到的抽象以及关于这些认识的正确性要求实践),相比之下一本书不可能传递很多实践的东西.本书前一部分正是力求让初学者完成从认知到实践的有效过渡.

所以说实践和认知都是重要的,没有谁比谁更重要的说法,人们过多地强调实践与理论的区别，却忽略了他们的联系其实大过他们的区别,,,其实对于初学者来说浅层认知的重要性要高于实践,一开始就有一个好的思想和基础显然可以为未来的实践扫清障碍,这是因为学习是一个层次上升阶段,在拥有一定知识后,理解基于这些知识之上的更高层知识会很快,, 即掌握了基础再加上一定勤奋的博物广识,知识量是几何级上升的,因此一种很好的学习方法是,学习应该先吞,(在一定知识量的前提下尽可量地博物广识,即使看不懂也要浏览完,以获得浅层的认知继续下一步学习),这是学习中自然而痛苦的过程.

>不是提倡光谈和光看理论,而是把理论整理成一个架构也是一项重要的工作,道理上理解过的事，即使会遗忘，也很容易推演,,不是不能直接把这个认知传递给你,而是需要再找一个与你的结合点来让你认识它,因此它是一本同时讲解到认知与实践的书, 不是提倡导光谈理论,而是如果事先有理论的指导,那么学习中就会少走很多弯路,学习中最怕不能理解细节,更怕以为细节就是一切,所谓一叶屏目不见泰山,更有人把学习语言作为编程的终极目标,而如果事先有人给你指导,你就会少走很多弯路,这就是下面要谈到的思想与细节的关系

我们鼓励在实践基础上去学习,也提倡速成,我认为学习不应该提倡逐步深入,人的生命有限,染启超在渡日的般上一夜之间学会日语,这就是说他掌握了思想,细节的东西永远是后来的,只要思想是重要的,(了解足够多的细节才能泛思,但是,在学习编程中,除了一些对至关重要概念集的理解之外,,从来都不是大思想决定一切,而只是小细节,这就要求你作很多的实践) **学习应首先理解基本的框架和思想,然后是细节,虽然真正的学习往往是混合了这二个过程的过程**,但大多数人显然不会拥有正规的理论教育(本书正是在为此努力),所以一开始对语言细节的学习和深刻理解永远都是学习编程的重头戏,如果说一些知识仅仅知其然就够了的话(仅仅是不致于迷惑和建立知识结构),那么有一些知识却是要精通的,因为不但要知其然而且要实际拿来应用.(人月神话的作者虽然写出来的是一本思想书,但他固然精通很多细节),但时时要提醒自己的是细节决不是一切,这就是我在前言的后半部分推荐给你的看书方法., 问题随之而来,既然存在这二大界限,又如何突破,否则这就是一个空谈 多走弯路,学习是认识事物间联系的过程,而记忆或实践是加强这个联系的过程,,能够认识到事物之间的联系,即便是自想的联系也可加深对事实的记忆(一个程序员有他自己的知识体系是重要的[^25]),这就是知识



更多需要读的



计算机,编程中的科学基础导读
\title



离散数学，组合数学，图论
\section1

离散数学与编程

把本来自成整体的系统(为了让它能适合计算机处理而进行计算模型化)即离散化为计算机能识别和处理的结构的过程称为离散,,用计算机来进行纯数学的数值分析就频频反映了这种现象, 离散数学,,就是把数学理论,,形式化为计算机能处理的东西,什么是离散??计算机本身就是一个巨大的离散概体,,能让计算机来处理数学,就必须把纯理论数学的一些因素形式化为计算机部件能理解的东西,因此会有形式语言的出现,因为很多形式语言的低层知识还是图等数学知识,等它与计算机结合成为形式语言时,形式语言这门学问也就成了离散数不的范围 计算机是一个离散结构,因为它的计算模型是属于离散数学的,但是有人会问了,我们现在在使用的计算机跟图灵机有什么联系,错,还是图灵机,因为现在计算机是在图灵机上构建的更高层抽象(我很庆幸你在第一章的抽象思想没忘),就像冯诺依曼思想一样,它还是现代计算机体系结构的基础,请大胆发散你的思维！ 离散数学研究离散了的量,什么是离散?现在我们有足够的知识来更细致地说明它了,这是因为计算机与数学结合后,,传统的数学不再是数值计算了(而且即使是数值计算,,当它与计算机结合后必须被离散化),,,而且一些非数值的计算,,,传统的脱离了计算机处理的数学不可能完成,只能靠计算机,,,因此这个过程中更加提出了一些新的计算形式和计算量,,,统称为离散的量,,也即,,传统数学已经演化到了与计算机结合的离散数学了,,,所有的传统数学问题都可以用离散数学来研究(也即用计算机来参与数学),,,具体表现如下 集合,纯数学中的集合,用计算机来表达最好不过了,因为有布尔代数,,这个代数很好地解释了计算机的运算器的工作方式 逻辑,,图论(不但被计算机,,而且被各个领域的各个分支使用) 代数系统,,关系代数(与数据库有关),,,有限自动机,,正规集(与计算原理有关)

语言中的类型理论Type thery
\section1

xxx

算法中的数学理论，复杂度，NP完全，等
\section1

xxx

数据库科学上的关系代数与集合论
\section1

xxx



[1. 说到这里,我突然想起人工智能,其实人工智能它的意思就是“模拟人类的智能”(它并不要求一丝不苟地模拟好人类,这取决于这种智能需要达到什么样的效果,即它对于计算机表现来说,本质是作弊或取巧),所以人们从遗传,基因,这些人类的特征着手,提出了诸如遗传算法和神经网络之类的理论,但其实,如果存在其它跟人类特征完全相左的一套理论可以很好地完成人工智能,那么它也可以称为“人工智能”.所以,对于本质就是伪的东西,没有必要去要求理论上的完美性.比如空间几何的变换是不是现实的几何(它不是,只是数学上的方程和矢量构成的世界).]

[2. 这里只讲用几何方法来表示的这部分(这属于一般几何中的n维空间的表示问题,以及物体和物体在这种空间中作变动时的路径表示问题,3D物体的几何信息,包括它的位置,及以后发生动态变化的位置信息,即移动,缩放,与旋转.仅涉及到多个同维空间 - 一个空间中的物体,变动到在另一个空间,用它那里的坐标来表示,会是什么值的组合?),至于映射为2d,那是另一回事情了(那属于投影几何中的内容,涉及到了多种不同维的空间,所以“transform”和“投影”,并不是一回事).]

[3. 对于数学理论是不是现实的反映,人们存在着质疑,哥德尔的不完备性理论指出,数学中有一些东西其实是非理性的,非理性不是指理性不能解释而是用数学代表的理性去解释却最终发现违背了最明显的常理.]

[4. 线性空间也被用于解方程。]

[5. 欧氏空间中度量系数]

[6. 注意，此时，是实数域上的有序对，在后为这些多元组正式被称为向量后，，，有实向量的称法]

[7. 有矩阵代数一说]






更多一般性应用问题和一般性设计问题列举

文集中只讲了通用api与appmodels，实际上对于具体问题并没有讲，比如游戏开发，这需要在具体实践中完成。非一本教授理论和语言知识的书完成可以含盖。

前面说过，任何问题都存在三个阶段，即问题，编程和设计，这是game ai的导读中已经提到，软件工程是这样一个过程，游戏开发也是这样一个过程，如：

编程的问题有：平台，语言，等基础建设,编程的编程支持有：语言技法，库设施等，编程的设计支持有：过程方法论等等

CG的问题有：CG相关的那些数学，CG的编程有：modeling ,rendering,cg的设计有，编辑器支持，art艺术者内容生成支持。

程序员能力之调试，反工程

title: 计算机安全和安全编程
prev_title: 更多方案域和问题域举例
prev_url: 更多方案域和问题域举例.html
next_title: 对FFXI的反工程
next_url: 对FFXI的反工程.html

调试，反工程
\title

现在，会编大多数情况下是用来阅读的而不是写的，这用于调试和反工程，所能，具有很强的会编阅读能力，无疑会给调试(开放源码的软件，我们往往是对源码进行调试，反之，我们需要在会编级调试)和反工程带来很大帮助

反会编只需能读懂函数和结构，调用级的逻辑(流程)就行了，因为任何机器函数，最小单位只是函数和结构，THIS指针(函数参数)等的东西，难就难就整合它们求得一个程序局部或全局的逻辑，流程等

[TOC]

- - -

破解与调试
\section1


1,确定算法位置

一般地，我们对可执行体进行分析时（往往用动态跟踪，或与静态结合的方法），或对数据体进行分析时（一般地用静态），不是为了确定数据结构就是为了确定算法。

反工程数据文件的格式时，不太可能一下子就在一个大bin dumps中看出逻辑，，反工程中，往往是制造一个数据变动的机会

2,改造程序逻辑

会不会破坏了堆栈结构？

任何复杂的情况，在会编代码级，如果到达了需要到达的位置，那么只会看到一致指令和堆栈动作，此时，要做的工作，就是
实模式会编没有结构没有语法，没有运行时，它只是一个状态机，因此可以随意写作,,OS下的会编程序对所有资源都是独享的（因为虚拟了内存和寄托）,只是不能越过线性空决的界限和绕过CPU（除非那不是用户会编程而是操作系统内核等权的程序）


3,修正执行体


方案域与问题域之计算机安全和安全编程
\section1

>计算机安全与软件商业化是一对矛盾。开源阻碍了软件的商业化，在东方，人们普遍认为软件是免费的，将freeware看成是no money ware.软件要实现最大的商业化，一要减少免费开源的软件，二是加大计算机软件安全力度。 什么是开源？开源是程序员社会的宗教信仰. 开源的好处？开源对于软件教育促进社会进步的推动力是强大的，开源就是这样一种理念,因为开源导致的理念是开放和协议的标准化,不会出现因为被那个公司控制垄断的历史复杂性, Spring,strcuts.MVC都是框架和模型,思维模型,rails,spring是web框架,是一种"接口"中间件,应用的复杂性要求我们使用一系列中间逻辑和中间件实现了的中间逻辑,直接在这些实现上发展新的,叠加了的新逻辑. 设计中的泛化本质上就对应了应用可以泛化这个道理,我们可以整合一些现有应用成一种标准,一种架构,或者提出一个新的大架构,在这上面发展很多其它新的未端应用.一切在于我们如何泛化,在哪个维度上泛化,要由这种泛化得到什么样的实现,这也就是设计中的应用分析,架构设计 开源可能是好的,不光是因为产生它的力量大,从最本质的原因来说,是因为开源的起因是源于统一流行应用的要求而出现的,它的目的可能是提出一个架构,形成一种流行的应用规范(API是否开放源代码就是一种),避免技术团体或公司由于历史原因产生的可绕过的历史复杂性 因此open jdk的形式是简单的(比如它的类文件组织形式),提出了一种简单的形式,无论它有多么简单,我们总可以在这种形式上发展很多新的逻辑,形式的简单性跟要达到应用复杂性无关,有时,形式的简单只是为了使"复而杂"变得"复而不杂",但这种改变仅仅是形式上的,应用的复杂性是另外一个维度上的事情 开放的标准使我们的规范保持中立,所有人都可以接受,而不受某一个开发商的控制,而开源可以使我们得到大家都接受的一个实现,而不受某个开发商的控制,这两者的结合非常有力.这个实现你可以不使用它。

主要用C来写此类逻辑. 我们上安全网站的时候,比如EBAY,会向你的IE传达一个证书和一串值(公钥),,用这个EBAY提供的值和证书,可以表明你正在浏览的网站就是真正的EBAY 一个完整的加密系统,不仅要完成加/解密的基本工作,而且还做要其它事情(这些事情是加密规范对于现实生活必须要完成的 C 你可以联系数据库系统的完备性等原则,比如,它能保证发出消息的一定是这个人,消息在传送过程有没有被偷换过).人们假定,如果一个加密系统没有被公开破解过,比如一套加密算法在目前没被反算法了,那么人们就应积极地相信它.进而相信这个消息一定来自某个人,在传送过程中没有被偷换过. **什么是加密呢?就是用密钥对明文加密成密文,,或用密钥去显示加密后密文的密文,最初的加密仅依赖于算法**.要知道加密(在应用上)是面向一帮人的,这导致了换不换算法的问题,严格算法的加密系统,如果有人离开(或在目前最近的一次使用加密系统的过程出现过中断),那么他需要换算法.所以,特定情况下,才用严格算法的加密系统. 一般情况下,我们都用非严格算法的加密系统.于是出现了密钥.密钥机制使得,加密过程仅依赖于密钥本身,而不是加密算法的细节(否定那会导致严格算法的加密) 对于密钥,又存在着二大种使用方式,这就是对称和非对称,,,但是在这二者中算法和密钥都是重要的,,,只是分配密钥的体制不一样(当然算法只有一个供加解密,最终影响的还是密钥,算法处在上层,密钥才是直接跟你接确的),,故导致的结果迥异,,,对称算法中,加解密都用一个密钥(故称之为公钥),,掌握了公钥和算法(如果该算法可逆举或穷尽,即可破解)那么别人就可以拿到你的明文,,,,,但是在非对称中(这个对称不对称不是指算法可逆不可逆,而是指有没有二个相对密钥存在),,只有用私钥加密,,用公钥解密,,,这样,除非别人拿到了你的私钥先,,才能用公钥解密 理解时要先想到算法,密钥是第二个要解释的问题和概念. 虽然我们向开源界学到了很多，但记住，开源并不总是最好的,请注意,请正确看待windows集成性与完整的解决方案,与第三方解决方案,正确看待开源与第三方方案(对于新技术，开源社区和第三方始终都是走在最前列，但微软往往总是后者居上，跟进得很不错，做出的产品很利于新手学习)






[1. 一般地,我们无法跟技术赛跑,我们只能是溺水三千只取一瓢而饮,见4.1章"语言之争",语言细节和应用本身都可以是一张无穷的网,比如语言细节可以永远因为应用的展开钻牛角尖,这就是那些称为语言tricks的东西,比如用C实现的OO.]

[2. 本人讨厌编程！！高级语言也不过是丑陋的机器思想的拆射人,只是本人喜欢看小说和尝试写些技术非技术类东西,所以就顺便有了这本书而已,而且这个作业也完成得甚为邋遢,读者勿怪！！]
