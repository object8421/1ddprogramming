本部分安排
\title

宜交叉来读本书！！本书的架构是自成体系的,除掉第一部分(书前附录)和最后一部分(书后附录)外,中间三部分是主体,这三部分自成体系,其中的每一章的每一节都专注于一个主题,三部分的目录定得很详细,它们是对应并自我解释的,既有知识架构,也有学习方法,技术细节的描述,下面一一讲解:

第二部分主要是关于实现编程的导论,这一部分过后,你基本上可以看到编程界常见的那些概念的解释.这一部分重点解释了C的基础实现语法,故谓之实现编程,第三部分专注于抽象编程,描述了Python,C++中抽象的实现语法,故谓之抽象编程,如果说第一部分是基础实现,那么这一部分描述的就是抽象实现,第四部分就是设计编程,如果说整个第二,三部分描述的是隐式的设计,那么整个第四部分描述的就是显式的设计,因为它们主要是那些独立于语言的那些大的设计手段.随着抽象要独立的需要，它们已经被业界做得高阶而且显式了

- - -

[TOC]

问题与编程
\title

Xx

第二部分 实现篇
\section1

\list 第一节：机器系统

这一章从抽象角度解释了PC系统的架构,首先指出整个PC系统的形成是一个不断由机器向人抽象[^1]的结果,在机器内部,先是图灵机作为最底层计算模型,CPU的控制作用在整个硬件内部是最高的,CPU和主存协作(协作以执行指令完成硬件级的冯氏计算)的方式决定了冯氏编程的基本模型(存储执行，顺序确定性和面向运行期),(在没有出现软件前)这个意义上的编程是硬件编程(描述硬件在运行期的功能性的编程),我们选取了最有代表性的实模式下的汇编来讲解了硬件上的编程.从汇编语言如何寻址数据和实现跳转这二大方面谈了汇编语言和用它来对硬件进行编程控制的一些方面,比如IO,并指明这是编程的一种初级形态,然后从计算模型和语言模式的大角度谈了这种“以机器功能为目标”和“以指令编程为手段”的功能性编程组合的限制.谈到出现“以描述抽象的软件功能为目标”(OS)和基于OS上的更高级的“以语法编程为手段”的新编程组合方式其实是一种历史必要.
在引出作为编程的重要主体:OS的时候,我们谈了32位CPU为了支持更强大的执行功能而区别于它在实模式下的迥然不同的那些机制与设施.这些都为导出OS提供了必要的基础,而且,我们还由此导出了机器级执行路径和OS级执行路径(即OS的任务机制)的分别,这为第三章讲解编程的另外一个主体因素:高级语言奠定了基础,因为编程都需要涉及到某种执行宿主[^2],无论在硬件上还是软件上,针对汇编还是高级语言程序,冯氏系统最迫切解决的任务是提供某种运行程序的机制来完成其计算(computation)的本质[^3],而当执行任务完成了之后,用OS上的高级语言来解决开发上的问题,它同时解决了[^4]程序产生(编译器[^5]实现在某种OS上)和程序运行(OS必需为运行它上的程序提供一种执行机制)的事.而高级语言产生于这种OS之上,也反过来服务于对这种OS进行系统开发(系统语言与系统开发).这就导出了系统开发的概念.
(对高级语言程序所处的运行环境OS的讲解,重点是讲解程序如何如何在OS被执行的逻辑,即OS对以它为宿主的程序提供任务机制的具体内容).
这章中重点介绍了CPU与内存在冯氏系统中的管理作用,突出了CPU在整个PC中的控制作用及这种作用导致下的冯氏模型对开发的影响.CPU的那些沿袭到些语言机制的特性.比如异常与跳转(异常也是一种流程跳转，异常就是程序员写的，由编译器调用的程序),信号[^6],调试.

异常就是那种道理上不应出现的情况故称为异常(except就是除什么什么之外的什么什么，exception即由此词而来)，比如missingmethodexception,事实上，除非在极少量的情况下，才会出现那种情况，异常作为编程因素，是语言直接支持的调试，是系统编程，也是编程工程的一种手段

\list 第二节 冯氏上的编程 : 《系统》

第一章并不企图讲解整个汇编语言和机器编程,更不是针对某个平台进行讲解,比如intel平台,而只是为了给读者呈现一个最清晰的跟编程由来有关的那些东西的梗概(关于平台和语言本身的).
对应地,本章也并不企图讲解整个Linux平台,而选取了它作为宿主执行高级语言程序(这跟讲解冯氏硬件体系只讲解了它用于支持程序执行的那些机制类似,即关于平台的)所提供的一些逻辑(这些逻辑跟下一节要讲解的高级语言编程有关,即关于语言本身的).比如任务,异常,调试(IO,GUI这样的东西[^7]放到系统编程那一章再详细讲解,而且,这一章只讲解基本的任务机制,而不涉及到多任务,并发任务的讲解请同样参见系统编程那一章)
如果说硬件级的执行路径是一段电器化的recursived nested堆栈,那么软件级的执行路径,即任务,就是基于C语义的纯软件逻辑了.它提供了进一步的比机器执行路径更好的封装和更强大的抽象.
照例地,我们先是从抽象角度谈了OS本身(这里的OS主要指OS Kernel),它首先将硬件抽象为软件可用的东西(硬件驱动层),并提供一套接口(Posix,硬件抽象层),在OS的实现层次上,任务机制的提供是居首的,对任务机制的讲解,本章将重点做到阐明其中对系统编程有意义的那些细节.
在OS把硬件问题转换为一组软件问题之后,所有的开发问题也由机器硬平台上的指令编程转化到基于OS的软平台上的高级语言编程上了(所以系统问题和语言问题[^8]从来都是不分家的,是要时时刻刻被同时考虑进开发问题的),开发问题首先是解决现实问题与系统有关的那些逻辑,即系统编程逻辑,比如,编程可以如何运用native[^9]的任务机制产生新进程,之类,之类 ,,,然后指出界面和IO都是系统编程中的表现抽象(这是由程序的现实模型决定的)[^10],不过那是属于抽象编程层的
另外,本章还介绍了操作系统与语言的关系,即系统与开发的关系[^11],从而进而提出了虚拟机,虚拟机提出的必要以及它是如何导出虚拟机语言的,虚拟机是为了成就语言的.
这一章从抽象角度说明了常见系统的架构及它对系编编程的方方面面.
重点是系统的设计对于系统编程的影响.

\list 第三节：《高级语言与C》

这一章紧密承接上一章,如果说第一章,第二章讲解了到了计算模型和系统模型,那么对于编程,它实际上还漏掉了一个话题,即高级语言本身[^12],那么这一章主要是讲解编译原理和C语言的(包括C标准库).即基于计算模式和系统模式之上的语言模型和开发模型.
编译原理,即高级语言原理,它解释了很多语言被设计出来的原理,一如既往地,在这一章中,我首先指出编译器是一种抽象,因为它使人们的编程工作变成一种面向行编写源程序的工作.
因为同时承接了语言对于系统的实现(编译后端:高级语言的程序在软件系统上实现,运行,而针对目标硬件系统产生指令,所以需要运行时系统和代码生成逻辑)和对于人的应用需求(语言的语法定义和设计,编译前端:如何表达逻辑,怎么样的书写形式),所以编译器其实只是一个底层工作者(如果不是为了专门实现一个编译器或者基于学习的目的探究其中的算法和数据结构实现,而是为了更好继续学习编程,完成本章的学习任务,那么本书就不鼓励初学者找这方面的材料细读),所以在讲解中,我重点澄清了一些至关重要的概念而又不深入到太多编译原理的技术细节.而我们在本章的讨论重点也将放在:联系编译原理在语法语义上的实现细节,进行对某一种具体的高级语言,比如C,的种种语言设施的讲解,.比如C的类型,表达式,语句逻辑的底层语法语义支持.
本章首先指出冯氏下编程语言其实都是以类型抽象为中心动作的语言,类型[^13]及编译器关于类型的那些推理判断逻辑(静态或动态语义级的),是决定使用这门语言的程序员用什么载体来表达逻辑的手段(这是编译前端为程序员解决的第一大任务),C是,C++是,Java也是.然后再详细介绍了类型.最后介绍了脚本语言的类型
比如在讲解对编译后端与编译前端的区别时.我指出语言语法机制只是抽象,它可以抽象出Rope,还可以是其它东西,所以它跟设计有关,编译后端才需要具体产生表达这些逻辑的运行时,运行时是对数据数据在宿主平台上的宿主语言C实现.而指令数据主要用OS的执行路径进行解决.
我指出语法前就是设计,一旦进入语法,还是设计,只是编译后,就进入了运行期了,这二个阶段是有本质差别的.解释语言与编译语言的差别不在于它们何时出现了编译跟解释的分野,而是在于它们对运行期和设计期孰轻孰重,这种差别使我们可以明白一些东西,比如字符串这样的东西更多地是一种抽象,C语言可以有指针来实现,C++可以有模板来实现,模板实际上是靠近设计期的,
本章的另外一个重点是讲解对C语言的学习(这也是本书在接下来的系统编程部分要求读者掌握的能力)
如果说这章主要是介绍C语言的,实际上不如说它是介绍整个过程式语言的.
首先介绍了C与C++的根本区别在于C++对C的那些增加部分,而非对C的保留部分.即C++的OO和模板导致的泛型机制这二种机制,而它们与C过程式解决问题的方式迥然不同,所涉及到的语言抽象能力是处在不同抽象层次的,C++相对更靠近人,C是用指针,过程语法机制这些底层来呈现应用逻辑的,比如字符串,但C++是用模板,OO等代码抽象来呈现的,这使得程序员能更好远离底层更专注他们的应用,这是这二门语言的根本区别所在.
然后指出,在利用数据结构等实现抽象来解决现实问题时,C好像只有这么一种手段(比如它不像C++一样能很好表现设计模式),而其它第四代语言,不但有数据结构加算法的方式,而且还有更强大的语言内抽象机制,比如代理.闭包.
然后从类型机制开始,浅而扼要地谈了C语言各个方面的东西.当然,这一章作为介绍C语言的章节,重点介绍了指针,并指出“指针是C语言的一种抽象机制,而不仅仅是作为操作底层的工具”,这就将指针上升为C语言的一种语法机制,把它上升为跟OO这样的第四代语法机制的范畴.而不仅仅指针就是一个操作符,相比C语言其它语法机制是固定的,而指针是可以加以丰富变形形成其它语法抽象的.这样就抓住了其本质,

\list 第四章:《数据结构》

对于一门语言,程序员要学到什么程度才可以胜任一份工作呢?前面讲了很大一部分,那么这里正是复盖了用一门语言胜任编程工作所需能力的方面数据结构篇
根据我们在前面“最小内核语言C”那一章提到的,冯氏顺序式语言的本质就是编码更抽象的数据和提供程序员能用的处理数据的高级方法,写程序的过程就是操作这二个东西,,
算法就是在假设不用到任何编程语言抽象组织的情况下,从纯计算机科学的角度出发,探讨计算机能完成什么样的任务的学科.
从提出语言到提出算法,这是人们在解决计算机问题时根据不断出现的新情况不断提出新解法的一个表现,以前是解决映射方面的问题,现在有映射可能,关于如何解决,这就是算法的问题.关于以后提出具体的语言机制,那是如何组织更为强大的抽象的层次了,已超出了如何“能”解决问题的层次了.
语言不过抽象了机器,机器的本质是过程的,函数作为计算机的策略和编程语言最基本的机制,共实是在模拟硬件,所以都跟图灵装备有关.

第三部分 抽象篇
\section1

从前面的章节开始,我们不断提到抽象,,但是没有作为专门的章节来讲解,是因为我们需要一些基铺垫,而经过对OS,对语言,对C的讲解,,我们完成了这个铺垫.所以将在本章中完成对它们的讲解,本书正是一本一步步给初学者”找台阶下”的书.
\list 第二部分开头部分
这一章从语言的选择说起,力求澄清初学者对语言选择方面的疑惑,从现实情况这个根本的角度,首先说明了语言本不存在功能上的差别,语言功能的差别只是它们各自的表达能力范围内能解决的不同问题而已.所以语言的选择根本是受应用左右的.对各种语言的优劣比较只是在有限的范围做的狭隘的事情.
接着介绍了C,C++语言团队之间的一些矛盾.指出矛盾的根本是源于语言间的过度抽象.使得从C抽象过渡到C++抽象的各个阶层的人群大为存在.这揭示了系统编程和系统编程语言的某些弱点.它们都处在不成标准过于低级的平台上. 再者,提出了第四代语言Java,指出C,C++没有被流行的Web作为开发语言,是因为使用C开发规模跟不上,而C++又存在太多语言陷阱,它的库又没有及时跟上历史发展.就系统编程的眼光来看,一门语言的I/O最能体现它开发Web的能力,然而,语言对应用的适配只是狭隘的一面,Java虽然有很强的I/O能力但并不是它决定了工业界采用了它,其实反过来正是Web开发促成的Java的流行.
这一切的一切,(不止是为了澄清初学者对语言选择方面的疑惑)其实更主要的目的是为了导出新的话题:语言选择的问题首先是是一个跟 “设计”有关的问题.(本书到此为止,整个第一部分只是讲解到了编程主体和客体中的系统和语言,应用中的系统编程部分,这一部分的使命就是导出其它编程中的主体因素)

为连惯起见,本章接着本书开头(和第一部分结束时遗留的话题)谈到的“什么是编程,编程的几个层次”话题,继续往下面推导:编程不但跟系统和语言,系统应用有关,在它上面其实是受人和设计主导的(这就导出了编程中的主体:人和应用),如果仅从我们从本书第一部分获到的能力 ------ 系统编程的狭隘眼光看,我们会看不到编程问题的全部,这是因为,系统编程太专注于机器和实现,它降低了人的主观作用.整个编程其实是一个系统和语言占主体的世界.而不是应用和人.

这种现象需要出现某种根本的改观,比如当出现某种深克不同于系统实现的现象时(最大的事件莫过于时代的变迁,Web开发需要新的一致的平台,更高级和抽象的语法机制),编程就需要出现新的因素.比如重新设计,不种设计不只是对于编程本身的设计,而且可能是对平台和语言,以及编程理念的设计.

而所有的问题,包括进行什么样的编程,选用什么样的系统,发展什么样的语言,都是首先属于人的设计,基于某种特殊或普遍的人类需求.

设计的第一步就是抽象.

\list 第七章《虚拟机平台》

硬件,OS和网络是三个平台,网络提倡并发和分布计算,必须把握软工界的一些新潮流,现在的开发都建交在虚拟机等高级开发平台上,而不再是CPU+OS上,而且提倡脚本开发[^14].WEB编程越来越流行了,这就是网络上面的一层抽象(internet是internet,web是web),编译原理其实有很多方面跟汇编有关,这就是跟机器编程有关,,平台 就是OS,,OS就是一个编程层,就像脚本机一样,,,,我们native编程是对本地编程,这里的本地就是指OS,,而虚拟机是可以不需要操作系统就 能运行程序代码的层,,这是另外一个软件运行环境 总结起来,,,这机器,平台与网络讲解了很多“软件运行环境”,特别是我在编译原理讲解中涉及到的机器部分,是最底层的软件运行环境,对设计虚拟机也是 必须要用到的知识,,对解释OS的实现又是必须用到的知识,这三个环境是天然不可分割的,,站在现今天的软件开发的角度来看

\list 第八章《过程抽象》

这一章重点介绍了Python中的泛过程,闭包,欠套函数,等,C++中的重载,inline等

\list 第九章《代码与数据抽象》

这一章重点介绍了C++,Python中的类 (注意,这里只重点讲到类而不是OO,OO作为设计,是应该出现在第四部分的)

\list 第十章《设计》

时代真的不同了！！以前是手工作坊时代,现在是软工时代!在这个时代,人(更确切地说是一群人)作为编程的主体作用深克被反映到编程的方方面面,形成了大量加入了设计因素的编程方式.而设计的第一步,首先是进行某种抽象(对系统编程时代的执行系统,语言系统,设计系统各个层面的大颠覆). 在这一章中,我会写跟软工密切相关的思想和学习IT知识,以及任何一切知识通用的思想,,比如抽象啊,维度啊,范式啊,这对解释以后OO,都是必须的基础,软件工程的相关概念,是编程入门的关键, 对他们的理解是必须的,才能走出为程序而程序的狭小境界,,在一个更广阔的思维空间里进行考虑问题和编程.如果说《系统》是单独讲解软件环境,《语言》是讲解语言,那么这一章这就是讲解软件,语言,应用,与人的关系了,一言以概之,这就是软工,在这个大活动中,涉及到如何对多人合作的真正工程级的大系统大问题的解法,需要考虑软件作为产品的可扩展性的时候,,就需要提出设计和代码结构这二个字眼和关于它们的一系列的知识,这根本上是基于软工是为了让软件产品适合“应用”这个需求而来的,软件写出来的作为产品的特质(即基于设计上的那些考虑,界面与逻辑分开啊,数据分开啊什么的),,这就是说“构架不是功能的要求,但却是工程的要求”(这里的构架是指代码抽象, 注意这几个字) 而这是很多书本都忽略的.
由于方法论是属于设计的,所以放这里讨论敏捷开发的一些东西(设计首先是一种对人类活动的设计)
手工作坊的写软件时代,,就是编程=数据加算法(这句话过时了,因为过程时代,只有Core C的那些代码逻辑,而现在代码逻辑增多了,这句话应改成编程=数据加算法+代码逻辑[^15]),现在软工时代,编程=数据加算法加架构,其实算法是比架构更广的概念,它侧重于指"功能,解决问题",而架构侧重指"扩展功能,扩展源程序",但这二者都是设计考虑的范围,,说明白点设计就是编码前加编码后的总称,设计即源程序,源程序是最终体现,,,这也是一切高级语言在机器端的实现形式,一种语言要最终被体现成数据加语句的形式,那么创造这种形式的语言本身也要提供这二重机制,,这二重机制就是数据加操作数据的方式,数据由原来的数学,字母,这些计算机硬件能直接处理的东西,变成了OO的对象,而处理数据的方法,则变成了架构加算法

第四部分 设计篇
\section1

\list 第九章《设计模式》

有人说根本不需要设计模式,有人说设计模式是C++程序的“补丁”,,这话说错也可以,说没错也可以,,这是因为狭隘设计模式之说就是为C++,JAVA这样的静态语言作补丁(重构时可以很好地改变当初的设计,静态语言不比Python,Ruby这样的动态语言更好地表现设计模式,所以它是从OO一步一步发展而来的,比如C++就用接口),, 而广泛的设计,包括设计模式所提出的那些东西,广泛的设计是一种意识内你要明白它是广义设计,,并主动引用设计模式来进行设计的动作.所以并不是一种补丁.
(这一部分正是复盖了用Python胜任编程工作所需能力的对问题领域方面的抽象)
以上我说的都是“要懂得的部分”,一个程序员只有懂得这些,才算是理解了软件和软工的常识,否则一味钻细节,什么都不知道,处于一种很可怜的未开化状态,,更要命的是,不知道何为设计,甚至对这些没有意识,也就不可能主动领会别人代码或库中的设计之巧,,仅满足于了解代码本身技巧性和语言细节的人是不行的,这样的人,由于一开始不考虑软件作为产品的特性,,最后写出来的东西生命力就不怎么样,而且对应用,对设计的理解,也是你理解其它编程知识的前提,也是编程实现的目标(出发点和终点).
身处编程界,理清概念和事物之间的联系很重要,一个程序员有他自己的知识网络是很重要的[^16],当你在学习的时候,要主动意识概念和其它概念之间的联络,然后去构建这种关系之间的系统,这样你才能有效地继续学习,,否则迷茫于庞大的细节,,巨细不分,也就不能界定概念之间是什么关系,,,这是十分造孽的。
比如《系统》这一章,“为什么要出现编程语言”,,“我们看到的编程语言到底是什么东西”“它们下面是基于什么离散数学构建的抽象”我把一切功能的达 成的中间层,,无论是软件,还是硬件,都看成抽象,(正如本书反复强调和提到的,只要在学习中把握抽象这条主线,我们就抓住了对学习编程最为有利的根本) 我们今天能看到编程语言为什么要求我们用语法,,而不是直接在语法树上写程序为什么Lisp语言就能 直接在抽象语法树上写程序,而不需要一个语法,,,为什么Yacc是一个没有语法的词法编辑器 解释了为什么“我们要用流程控制,逻辑转移”这样的方式写程序,而很多人并不知道,他们学习编译原理,就是为了学到这个知识,这是死读书的人多么大的损失啊,,而我打算择其要点,,组成一条线,,解释语言的由来,,浅而不缺地解释很多很地道的东西,有机地讲解,,择其重点和必要的,去除过时,历史复杂性

编码与编程
\title

对于编程部分,我们首先涉及的是什么是编程的问题.然后那本书将从编程涉及到的四个主体展开，遵循的是一条工程化的线索，.这本书谈实践,自然要格定“什么是编程实践”这样的问题。.

什么是编程编码?于是我们可以得出这样的结论?

**利用某种语言,面向解决初级系统问题,或高级系统问题,体现某种设计,高级应用问题(但又不直接涉及到未端应用逻辑)的通用映射过程.**

谈到编程问题,它必然是语言相关的,和设计相关的,语言与它所能开发的问题基本是一个一比无限的关系,所以,要揭示一门语言能(在实践级)解决什么问题,这个说法本身是有缺陷的,我们应说,一门语言它善于解决什么问题,它能很好解决什么问题,这样说才是对的.这就导致了我们这本书对于语言实践这个概念的格定.

>我们先提出一个最为概括的说法: 汇编,解决系统上0的问题 C,硬件语言和初级系统语言,开发系统本身的问题.解决系统上从0到有的问题 C++,高级系统语言,开发基于系统之上的应用问题.解决系统上从有到多快好省的问题. Python,脚本语言.开发独立于系统的那些应用问题.提倡直接化,标准化,无重复化地来解决问题. (以上三者,都跟语言内整合了什么样的设计能力和设计手段无关,但一般地,高阶系统语言和脚本语言,会比初级系统语言,整合进更好更强大的设计手段)

首先，利用某种语言.

联系中的主体 联系 C 初级系统问题(实现与开发). C++ 高级系统问题,(建立在平台上的)一般应用问题 Python 独立于系统问题,(建立在虚拟机平台上的)一般应用问题
其次，面向语言善于解决的问题.

总结一下,语言与应用,应用如何分类呢?各种分类情况下都会产生不同的分法,应用从“产生零的汇编”,“从零到有”,“从有到多,好”的角度和唯度,可以分为“初级系统逻辑”,“系统应用逻辑”,“高阶设计方案与手段”这些方面.而C语言对应解决“从零到有”的“初级系统逻辑”,它不善于用来解决后二类问题.

联系中的主体 联系 初级系统问题 启动硬件,与汇编合作,涉及到内存映射,socket

高级系统问题, 设计问题,高级应用问题 抽象了的,或语言,平台无关的那些设计,应用逻辑 隐式的,语言内的小设计 比如,控制结构,指针抽象,

企业问题 高阶问题 一般问题 大到有游戏开发这样的课题,小到有boost.assign这样的手段

>这三种问题的分界线: C的是system call,os core, C++的是os Main,(这二者是我们已知的,并已界定范围的应用问题中的系统问题,是被我们正确理解并形成共识的那一类问题) Java EE是enterprise开发(在这里出现了大量框架和分布式之类的概念,是与C能很好针对工作的系统实现,C++能很好针对工作的系统开发,在编程理念和理程设施上迥然不同的那类高阶编程.) 至于第三类问题(一般应用问题),根本没有一个分界线(前二类问题可以从下而上设计,而第三类问题,往往不可能用从需求产生代码的自动代码生成技术来解决).

最后，不直接涉及到未端应用,只写通用映射的中间过程.

联系中的主体 联系 初级系统问题 写数据结构,初级系统问题,但不写诸如《C实现jxta》这样的应用课题 高级系统问题设计问题,高级应用问题 写设计模式,IDL,XML,但不写诸如《Web》这样的太深入某个领域的应用课题
也即,1.应用独立语言,再者,2.应用分层次,择层次而谈,最后,3.只写开发不写实现.

问题
\section1

首先,你要明白,应用,从初级系统逻辑,高级系统逻辑,到一般应用逻辑,设计手段,等,都是不必跟语言有关的,C语言之外的其它语言也可用来写OS(我们用具体语言,C,来代表“系统实现语言”),C++之外的其它语言(我们用了具体语言,C++,来代表“系统开发语言”),也可用来写操作系统上面的那些东西.一般应用逻辑,可以用C++,也可以Python这样的脚本语言来写(但它们解决同类问题是性质不同的,).设计问题,也可,用任何OO语言或其它手段来体现,关键的问题,是,你要明白,应用是独立任何语言的,而且,你不必把握整个应用,而只要把握那些通用的问题跟手段就行.这些通用问题跟通用手段,就是应用和设计层次中的低部分,比如,对于文件的概念(它是应用,是系统应用层次中的低层部分),可是,它可以发展出更加复杂的系统逻辑,比如在初级系统问题中,IO的sys nonbuffer io和language buffer io就是不一样的,还比如在高级系统问题上,数据库,打包文件,持久,这样的高级编程应用逻辑.所以,在本书的讲解中,我们也是择低层次.即通用问题而谈.

其次,开发都是分层次的,同一个问题,在不同层次上,有的是系统问题,有的是高级系统问题,有的是系统应用问题.,比如,IO不是持久,持久不是文件系统,一定要分清这些东西.

其实,我们不可能为应用划分出一个具体的层次,因为它是一个巨大的分类工程.所以,我们只能是在“断层”和“巨细不分”地讨论(比如,其实多媒体问题是一类问题,范围很大,我们在讨论多媒体问题的同时,会讨论诸如boost assign这样的小逻辑.).

于是,对于“IO与持久”问题,让我们分层次地来介绍低级IO,将IO做成流的业界做法.这是业界对问题的一种归纳(抽象成编程问题).于是各种语言有它们自己的实现(库).

>我们知道任何问题都是分层次的,对系统编程,我们该如何划分呢? 一种方法就是按用户程序的模型来分.我们知道,现今的程序,都是指“用户程序”. 从os内核中包含的功能模块(这成为应用程序的模型始源)我们就知道,虽然其上面可以架上很多很多的东西,但只要从基础出发,我们就相当把握了一切的起源.那么ＰＣ到底有什么功能?? 图形功能,多媒体开发,导致的ＧＵＩ, 网卡功能,ＳＯＣＫＥＴ编程,导致的网络编程文件系统,内存,ＩＯ,形成数据库于是,一个真实的用户程序的模型,它必定要使用这些资源,,于是形成了桌面上的程序的几大模型. linux上的系统编程往往是低级系统编程,这种历史遗留现象,比较稳定 我们以“程序关于系统的模型”,这个标准,可以将初级系统问题和高级系统问题分为二部分,一就是“解决程序关于系统模型”的初级系统问题(IO,文本,内存模型,SOCKET,并发),和高级系统问题(网络,持久,界面).

dfd

>本书是对丛书第一本的“关于实践点”的铺开,所以,其内容全是基于第一本书来的.那些第一本书没有谈到的东西,这里也不会出现.而且,本书保证涵盖基本的关于一门语言的,全部实践内容.而且,当然,本书不会写关于一门语言的一般应用. 任何一本内容有限的教科书,都不可能宣传会教给你所需要的全部技能,任何一本书,它宣传它只是教会了你最基本的能力,(只是这样就足够了),因为C,C++,Python能开发的问题是无限的(任何一个问题,都是可以无限被深入的,比如网络,它可以从socket上发展很多逻辑,P2P,甚至VPN,所以会出现各种学术“专家”,在它们的履历表上经常写着,兴趣方向:XXX),因为逻辑的发展都是无限,而且它们之间是互相交错产生新逻辑的,比如网络跟IO,联系会产生“异步IO”,的.这就是我们说的一般应用问题. 所以我们能讲解的,只能是那些我们能抽象了的,而且正在很好被抽象的那类问题(而这些问题正好是一般应用问题的基础),这些问题是什么呢?这些问题就是我个上面谈到的系统问题,系统开发问题和企业问题.

总结一下:应用的按层次分类,下面给出一张图.

33

实践分为二部分,对问题的理解,和实际代码展现(实际代码展现集中在对库的介绍与使用中)

在代码展现方面,我们选取BOOST中的IO库和IOStreams库,再介绍file system 库和serialization库.
以上,不是分离的,而是联系的,都是语言能力但又不尽是语言能力

我们期望,在看完这套丛书之后,形成真正的能力,于是三本书各有其使命,尤其是保证阅者在读完丛书后形成真正实践方面的能力的使命.

编程能力泛指一种用通用语言进行通用编程能力(就像本书即将要整个呈现给你的一样),而不是指一种深入到某个行业的实践,因为那是工作能力.那反而代表不了真正的编程实践的整体.

让你获得用通用的语言来进行通用编程的实践,而且,对于,每个新出现的问题,你将目的地选择一种适合的语言,从某个有源点去考虑如何解决它,这才是真实的编程实践.

对编程编码部分的安排
\title

对编程编码部分的讲解

我们将用一种类伪码系统的语言来描述整个C井编程(而不使用标准的C井语句和语法系统),对应于本书的理论部分要达到的教学效果 ------ 科普式的理论教学,那么整个实路部分,就是practising C井 subtlely,完完全全的为码系统实践教学.

对platform,C/C++,python,C/C++ programming,Python programming(第1,3,4章)部分的讲解
\section1

Xx

对OS programming,high level user’s logic programming(第2,5章)部分的讲解
\section1

如果说编程部分(本书第2,4,5章)只是讲理论和语言问题部分,那么问题部分(第3,6章),讲解的,就是应用问题部分,这就为实践铺平了道路

为什么这样安排
\section1

为什么要把C,C++,Python合成一块呢?而不是整合到第一本书里?因为分才可以合,理论跟实践分开,可以让读者明白这二者之间的区别,比如,我们在这本书里同时提供了C,C++,PY实现的设计和解决的问题,这样就至少可以让阅者明白:编程问题的解决其实是语言独立的.这样也可看出各种语言在体现设计和解决问题方面的差异.使它们明白,语言最终是一门工具.
我们在丛书第一本里用大量文字性质的语言提供了理论,本书第二本,也用源码的形式提供了“你必知的那些用什么语言来开发什么应用为宜”这样的事实. 那么,为什么需要这些认识呢?这些认识对于真正的编程能力,对于一个程序员真正解决问题有什么用吗? 我们说,有用,本书使用大量理论篇幅来介绍这些并不是仅仅让你知道这些常识本身存在,而是对于一个程序员来说,他必须知道这些理论性的东西,在理解了这些东西后获得的珍贵的大局理解能力,而这种理解能力,对实践的展开,是一个强大的后劲,它对解释实践中遇到的很多问题,都是基础.
为什么能把C,C++,Python合成一块呢,因为有共同点,而且,它们除了在语言上存在差别之外,在解决的问题上(通用的系统开发),都大致相同,只是抽象程度上,和对一些具体大小问题的侧重不同.所以放在一起

>程序都用C,可以从功能和实现层面体现一个应用,将主体功能整合到一个大主体源码文件中,这样也许比分散了OO文件还好复用和理解.

这一篇基本是对前一篇《系统问题》与《高阶问题与设计手段》的详细发扬与光大.

其中第一本书:

语言能力《其实践,写在了第一本书里》体现设计能力《内置在语言中的过程设计能力,OO设计能力,因为跟语言联系比较紧,写在了第一本书内,它解决“怎么写”的问题.

独立语言的设计模式设计能力,以及IDL这样的通用解决问题的设计能力,写在了第二本书里》解决常见系统问题能力《第二本书中》,它解决“写什么”的问题.

丛书第一篇.一个程序员的再学习能力,理解编程的能力,语言实践能力(实践点[^17]一:会C,C++,PY进行编程) 丛书第二本.实践能力,编程解决通用问题的能力(单语言版).实践点二:数据结构,初级系统问题,高级系统问题,设计模式,脚本化了的问题.

这也是丛书的这第二本要奉献给你的,对于实践能力,要把语言能力跟你要解决的问题的能力分开,而且,要把语言的实现能力和复用能力分开.

使用语言标准库,第三方库的复用能力,或自己实现的能力 (这是一个语言的标准库要完成的东西)
问题是分层次的，同样地，实践也应分层次 通用（游戏）编程学习计划 1.首先一门语言是必要的： 精通C++（10天）的基本语法，过程式，OO，等语法，基本C++ lib(C的那部分) 在完成阅读本书关于C++理论的情况下实践，达到精通水平 2.平台编程也是必要的： 精通数据库以及socket（20天）,基本操作和使用api的方法（比如MFC对DB和SOCKET的封装） 在完成阅读本书关于C++理论的情况下实践，达到精通水平 至此，如果已达到精通水平，你就可以定位自己为一个平台程序员了，比如一个实际掌握C++和MFC具实践能力的程序员了[^18]（作者本人就是）。你也可以发展为一个游戏程序员。 对于游戏编程，就是先学服务端，再学客户端，这样的安排很合理，因为服务端技术也是通用程序的技术（db和socket也是平台编程）: 3.精通DX (10天)，基本渲染逻辑，变换逻辑和使用API的方法 在完成阅读本书关于C++理论的情况下实践，达到精通水平 4.以上1-3基本是胜任游戏编程相关工作所必要的，最后，如果时间有富余，可以学习学习强化编程能力的中间环节（理论及实践） 比如C,数据结构与算法，os原理,底层系统编程，stl，C++设计性语法，C++ OO原理，C++ sec level,多线程，界面，，一门脚本语言比如python，DP，面向接口编程，敏捷方法,uml工具，3d数学物理,图形学算法，shader，游戏逻辑。 甚至vm原理，python函数式编程，C++ meta programming,boost, 甚甚至编译原理,xml,web编程，aop,com,cobra,soa等等 5.最后才能学习终极大全类的学科: 学一个图形引擎比如irrlicht以及游戏引擎比如fear(20天) 6.最最后，写出自己的引擎！！利用所学解决实际生活问题(认证)和工作问题！！ 7.你已修道成仙.
比如微软的认证mcad也只有几门课程。

>解决具体问题能力,那些编程界没有过方案的问题《第三本书里给出了一个例子,创新,及独立解决问题的能力》,综合编程能力.这种能力跟胜任实际工作最密切相关. 丛书第三本.工作能力,建造大软件逻辑的能力.真实系统的能力(实践点三:多语言协作实战能力,基本的应用开发流程). 本来我想写第三本《应用举例:opensocial系统的实现与开发》,网恋如日编千码.这篇将大约占500页的篇幅,把从源于OS的逻辑写到日常所见的高层逻辑,比如game ,vr,web,解释它们在库级或第三方级,是如何被实现的,又被开发的[^19]. 但我后来放弃了. 工作能力是不可能被界定的.它泛指一类很丰富的未端应用.和行业编程经验.而这一切,是以语言能力和通用实践能力,通用问题解决能力为前提的,所以,我后来专注于写好本丛书的第一,第二本.也即,我们应具备跳出编程的能力 跳出编程的能力:哪些是你要学的,哪些你不应去学 为什么这本书里不写EJB这样的主题呢,因为在第一本书里我们说到,EJB这样的东西,更多地是一种高阶问题和高阶设计,而在以lmtpractise,corelearn为主旨的这样的一套丛书里,是不应该详细讲解的. 我们只讲解最核心的那些理论与实践.(那些形成我们必须要学会的能力的东西) 比如,第一本书中,我们在看完丛书的第一本之后,应该学会理清理论的能力,和运用语言写作程序的能力.语言能力是通用的,所以对于程序员它是必须学会的. 在这本书里谈到的,数据结构,设计模式,二进制构件,分布式,方法论,(特别是)通用系统问题,也跟语言能力一样[^20],是实践中的通用能力,所以我们要掌握它.这些东西(是作为基础设计手段,和通用问题的),虽然同为设计和问题[^21].但它们的地位并不同于高阶设计,高阶问题.对于不同的程序员的学习曲线的意义不同. 而在ＯＯ的基础上发展起来的接口,切口,WEB,ＥＪＢ等一系列我们在第一本书《高阶问题和设计》中提到的新知识,新体系,它们不是基础,而是高阶问题和高阶设计,正如我们在《抽象应用》中所说,Ejb是临时品,是人们不断组合设计,形成新知识新应用,新学习曲线的那些东西,它们不是现代编程的基础而只是高阶东西,在它们的发展中尚未被作为整个编程基础,而只是不断变化的关于高阶应用的设计,可能是一套慢慢才被人们接受的标准,可能在其发展历史上被最终消失或被其它东西取代,如果开发或工作中不用到这样的东西,你是不应该去学的.

[1. 抽象其实是统领整个计算机领域和编程领域的]

[2. 我们现今的语言都是某种运行期语言.运行,运行,必然关乎某种运行原理]

[3. 以前的硬件机器,程序(这个时代标准意义上的程序,是各自独立控制机器各自独立完成自身任务的指令程序)直接在机器内运行,在出现OS后,程序(此时标准意义上的程序是用户程序)是运行在OS上的,OS是发挥原来硬件平台运行程序的那些任务,而且它还将这个工作做得更远,它不但支持程序运行,而且是个多面手,比如它还将编程本身纳入计算机内部OS之上.实际上,系统内部并不一定需要一个编译系统,它只需作为一个运行系统就可以,因为编程本身是并不一定要做到计算机内部的,而OS的功能仅仅是运行程序就可以了,而我们见到的编程方式,都是直接在计算机里使用编译器来完成的.]

[4. 这就是编程的本质,它是人跟计算机系统交流的手段,然而这种手段仅被我们用来实现和控制机器本身,指使计算机为我们服务.]

[5. 跟纸带编程的离线方式相比,编译器让编程做进了PC内部,而且解决这种程序如何在这种OS上产生的机制,和,解决这种程序如何在这种OS上运行的机制都做到了PC内部.都需要被完成,前者是编译器的事,后者是OS的事.]

[6. 如果说中断机制是CPU与硬件交互的手段,中断使硬件接上了计算机,那么信号就是进程间通讯的手段,它使进程能相互协调完成任务.实际上,并没有完全独立的进程,进程本来就不是被设计成为自冶的,只是它们的任务空间自冶而已.]

[7. 这样的除执行之外的其它系统本职逻辑,把它们与任务分开,是因为任务是OS最迫切解决的问题,而且是针对编程,最靠近跟讲解编程有关的东西,而IO,GUI,相对来说,是可以慢慢来讲解的.]

[8. 这一章只讲系统问题,语言问题放在下一章讲解.]

[9. 如果系统是用C来实现的,而你正是用C来开发,并调用系统用C语义实现的那些功能和API,那么这种关系叫native.]

[10. 是设计问题中的show抽象,当然GUI也可以是应用逻辑里standalone的比如微软将GUI和核心作为一个整体的设计作法]

[11. 细心的读者会发现这正是慢慢过渡到第三章对语言的专门介绍作准备]

[12. 冯氏计算机有二个层次,系统层次和开发层次,第一,二章讲系统实现层次的那些东西,那么这一章就讲到了构筑在系统实现层上面的,对开发进行支持的层面,开发层面最重要的问题当然是语言问题本身.]

[13. 用栈式机的执行路径的眼光来看,类型就是出现在执行路径中的数据(的模板),但是因为静态化的东西,包括数据和代码,都是数据,所以一般仅把子程序作为跟数据对立的“代码”来看.指令跟代码的区别就在这里.]

[14. 现在的开发是基于框架的开发,现在的web编程,提出了一系列概念,uml,xp,重构,分发,setup,make,debug,版本控制,测试,当然这些都基本上是构建在OO之上的,参见&lt;代码阅读方法与实践&gt;]

[15. 但这并不以降低数据结构,算法在编程中的地位以前提,实际上,作为基础的数据结构和算法,在它们上面发展了新的代码逻辑,这反而表明,数据结构和算法更重要了]

[16. 这样,一个程序员才能更好地学习新知识]

[17. 在目录中已用%%,%标明的部分]

[18. MFC就是一个平台app engine,因为它有db,socket,gui等]

[19. 当说到实现时,我们指一种以语言为中心的“从无到有”的开发过程,而开发develop,我们指,“发展”已有的逻辑,产生一个新的逻辑层面.]

[20. 我的理解中,这些必须要掌握,也许,并不需要掌握方法论等这样的东西.但其实如果处在真实的软工实践中,你会发现,开发处处跟方法论这样的东西靠得很近.]

[21. 语言能力,跟运用设计的能力,分析并解决问题的能力对应,都是编程能力要涉及到的..]




