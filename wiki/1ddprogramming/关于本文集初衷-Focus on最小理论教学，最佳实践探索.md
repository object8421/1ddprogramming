title: Focus on 通用编程教学,桌面游戏开发实践-关于本书初衷
prev_title: 附录
prev_url: 附录.html
next_title: 更多方案域和问题域举例
next_url: 更多方案域和问题域举例.html

Focus on 通用编程教学-关于本书初衷
\title

focus on cpp,py,windows桌面级(not system)开发，桌面游戏开发，，windows越来越沦为游戏机平台了。


- - -

[TOC]

初学者学习编程理论的难处
\section1


bcxszy关注初学者关注的那些问题但并不局限于专为他们而设，超越了初学点的那些东西对高手同样有意义。它对学习者呈现一条干净的中心，只要掌握了中心，才能迅速入题，去枝节，从简学习以及做到有限实践。


软件的任何一个领域甚至应用都足够复杂，学编程只能学专门技术



把任何东西都弄得有限而狭窄是人类学习的本质需要

有时是繁而不复，细节繁多

所以定位很重要，人力职业所为倒是其次，，，有时不必掌握太多的职能。。。形成专项职能就够了


在编程教育中，一切都可以理解为理论，开发实践只是理论过程的未端。。比如，实践所需的知识网络是理论的，实践细节可以是理论。。

对于编程，最基础的那些东西应该是什么呢？它必定是统一的，甚至超越并统一了理论与实践。即这样才能做到painfuless practise

而且，一个程序员要培养最终灵活的编程能力，他必须能达到“一切从零开始，部分使用OS上，SOFTVM上，lang stdlib上的逻辑”，，能从最底层次开始，实现领域逻辑的能力。。

实践细节，也是一种理论,领域分析理论与产品开发理论，形成了实践理论


开发方式与框架，领域抽象与引擎，产品结构与各级用户支持，，，这就是programming的一切。。
对于某种开发，开发方式与框架，领域抽象与引擎，产品结构与各级用户支持这三方面。是一个arranged progs的基本要做到的方面。
提供某种开发方式与方案域框架，，开发一个能描述领域全貌逻辑，形成为一个中心程序产品----the engine，，提供对各级所需用户的支持和产品线。
proger最主要的能力不在coding,,,在debuging,,不在建设，，在探秘
学编程必定要先学会使用一门语言这是绝对正确的，在学习过程中需要代码来验证，沉淀某些想法和经验性的东西，这个必须要在最开头就完成
网络编程可发挥的设计余地有多大，，，能不能出现多种多样的解决方法，，不是指分布式解决方案，，而是指具体到game netwking这样的东西，，里面出现的具体小问题的解决之法，，id Tech 3 uses a "snapshot" system to relay information about game "frames" to the client over UDP
终端应用方案的解决，，就是实践，bk chpter 2,5指的只是通例，，具体游戏方案域，有具体到细节的实践，故整书可作为实践的典范之作。
自从有了cpp，c就越来越成为我的反工程验证语言，反工程小工具语言


至于熟不熟，那是另外一回事（速度上的），，，理论必须先行，它甚至包括实践所需的能力的绝大部分，，实践只是一个去疑的尾端体验过程。


对于平台

不建议初学者研究OS实现，理解了CPP，DP，工程思想后再理解windows src强过先理解C,译原理再来这样做，因为编程的最高形式是写代码的方法（范式）与理解应用的方式（如message based xx），这些在系统实现和应用开发都是共同的，如windows src中msg based apc,object mgr kernel,all kindsof handler等 


对于语言


>C和C++是一脉相承的,遗憾的是,就Better C部分来说,C++只是对C的增强而非替代,如果他离开了Better C,就只能有类的代码模式的复用能力,却无法保留C的强大而直接的实现能力(如果写数据结构这样的东西都要强制用到类,那么除非有必要为复用作目的,否则没有用C++的必要.OO提供的最本质的意义和作用有二1,将C++这样的通用语言“在类层次”变成为某种程度上的DSL,2.正是因为1的作用在先,所以普通个人也可以开发复杂的软件系统.甚至是数据结构,这样的要求程序员自己实现某些逻辑的知识.),而它的标准库里虽然也有与原C一样的那些模板实现的库但是却是抽象的不像原C那样原始而直接的,业界一开始是用C的方式而非STL来表达数据结构,所以一个C++程序员(假设他用了OO来实现数据结构)既是一个实现者,也是一个设计者.因为它既抽象了如何能被解决的问题,又抽象了如何能被复用的代码. 你可以这样说,**OO这样的代码抽象,正是为了抽象数据结构这样的实现抽象和数据抽象.使你在复用层次上可以直接使用现成的数据结构,而不是实现它们和重造轮子.**如果说OS是抽象硬件为软件,OO就是抽象数据结构这样的实现问题为复用问题,而C之类的语言,.需要你自己实现数据结构.因为它的标准并不允许你直接使用它们.


>首先,OO将用这门语言进行开发的工作发展成了ADT和UDT编程,这使程序表达的概念接上了人类的思想[^4],而程序也能处理这种表示,但程序员的绝大部分工作在于定义一个DT表示它们想要表达的逻辑,而且提倡以A – Abstract的方式,但实际上,这种形式反而有时候是一种禁锢,第一是因为把任何实体和概念都封装为语言的DT,固然做到了统一,但凡事巨细都要做成数据,这很烦人,第二,也是最大的问题,程序员之间的水平参差不齐,他们定义出来的DT可能会给未来复用它的程序员造成理解上的麻烦,并不是所有人对于某个东西都有一致的封装及理解,当然,这些问题也是语言间不同的[^5],对于没有OO的语言,C++的Vector数组固然比C Plain Old的数组版本好用,对于拥有OO的语言间,Java大量规范设计的OO库比C++只有一个STL和松散的BOOST要好. 当然,这是对于跟用C来表达这些概比较来说的. Java的库是高度OO经过设过的,规范了应用,相比C++语言,比如它规范了流的概念,Java的OO和规范的库是人们说Java比其它语言易的二个方面.只要熟悉这层抽象人们就可以拿来编程.但是虽然熟悉编程的人可以拿来用,但是对于没有编程经验的人来说,它照样跟C一样难.因为对于初学者,是根本没有经验可言的.而一切照样都是经过了大量铺垫的.只是存在多少上的差别.

因此Java的所谓易,是相对用过C和C++的这样的熟悉编程者来说的.至少使用Java,我们照样得学好跟C一样的数据结构知识.就拿比Java更抽象的语言来说.人们说Ruby,Python偏向于人,但是几乎所有的语言都脱离不了数据结构,,都脱离不了底层,如果数据结构这些实现问题没有搞清,语言机制也就是一种更大的障碍了,Ruby的OO只是指类的那一方面,,Ruby的IO,数据结构,Python那些抽象的语言机制比如Lamada,,也跟其它语言和语言机制是一样的,,,复杂,跟底层相关,有众多细节.

>C用最初级的封装了汇编的逻辑写应用,C++用类来封装逻辑,如果你看过用C表达的数据结构和用C++来表达的数据结构你就会发现这二者的不同[^6],有时看出来样子普通的一堆语句,你根本不知道它想表达什么上下文数据结构逻辑,就C来说,虽然你真一开始就明白它想写什么(比如有文档的情况下)但你如果不明白数据结构在先也不会明白用C表达的数据结构究竟在表达什么,就C++,Java这样的面向对象语言来说,似乎能够整体上看起来是一个一个的类,显得意义明了,但实际上语言越接近应用问题反而代码看起来更复杂[^7],况且,C与C++,Java,Python,Ruby都是通用语言,现实生活是很复杂的你根本做不到绝对靠近除非你为每一个问题写一个DSL[^8] (比如像SQL语言那种专门处理数据库逻辑的语言,不会写SQL语言的人至少可以大致看懂其意思),一堆有机类有时反而难于让人看出它想表达什么,而且另外一方面,类里同也是函数,也是类C的进程式的语句逻辑而不是封装上的类逻辑,这样问题又回到C的那些问题了.

这些都应该被尽量在语言被设计时就避免而不是人脑避免,当一门语言复杂到你真正需要掌握这些才能编程的时候,编程就演变为远远不是那些所谓的简单复用的工作了,对OO的真正理解涉及到设计,涉及到编译原理的类抽象本质,涉及到它如何以层级的方式来抽象数据结构和应用[9^],虽然我们以为OO语言就是简单的复用语言但它们明显做得不够.

>所以,语法绝对是新手最大的拦路虎,没有一门语言,即使高阶抽象语言如Python,Ruby,也没有把语言细节弄得足够简单,使得你可以不管任何语法产生式的机制去直接构建你的应用,,在不损耗语言表达能力的情况下,而且RUBY的一些语法机制也不是不简单.需要你有深厚的系统知识去理解他们,比如协程,元编程等技术,在接确过一点C++人的眼里,丝毫不比C++简单[^10].

在数据结构与OO的结合点上,比如ADT表达数据结构,其实也是语言与冯氏编程联系的结构,冯氏上的编程提倡用数据化模式的方式去解决开发问题,冯氏上的语言用ADT来表达抽象ADT编程方式中的D,这是一种设计,是对问题的抽象,也是对如何写代码和如何被复用的抽象,要知道,你想要明白STL必须要理解一些Adt和数据结构(Adt是类型抽象,数据结构抽象就是数据结构了)的东西,而这不光是C语言算法和数据结构的一些东西,而且还是某种语言本身设计方面的东西和程序语言机制方面的东西,C++并没有完全做到Adt完全的抽象(没有抽象到你能以一种脱离底层完全不同的眼光去看待数据结构的Adt),,这不是C++的错[^11],,这是你没能学习算法跟数据结构的错.. 冯氏系统中的要素,比如,异常,进程等概念在编程中都有体现(这就是系统编程要解决的问题),冯氏语言针对冯氏平台上的这些问题并从编程层抽象它们以进行解决(因为它们都是系统形成任务执行程序,建立出错机制以更好运行程序的逻辑,所以这种逻辑由系统执行层面下放到编程层面,给程序员以配置这些逻辑的时机或为了更好调试,就在编程层对应地有了这些语言机制),于是可以把它们做到语言内,即可以或者做到语言的语法语义里,或仅仅做到buit-in lanuage 库或扩展库里. 都是无穷无尽复杂的语法和系统细节让初学者停滞了他们学习一门语言的脚步,在你开始满怀欢喜地按书上的例子用C++开始写“Hello World”时却发现少引用了一个头文件之类的问题折腾得一头恼怒不知所措,却在花了很长一段时间之后才发现这是C系语言的分离编译机制[^12]在作怪(这就是那些被称为语言陷阱的东西,然而这是一个大问题,虽然对于个人来说不是,但对于软工这个多人共工的人类活动来说,语言上的陷阱它是), 这根本上是因为我们依赖了太多粗糙的抽象,因为它们根本做得不彻底,比如,你依然得学习算法跟数据结构才能理解这样的ADT. 而且,你得理解设计,放大到整个人的层面,一切活动都是人的,随着编程发展起来的那些历史抽象是巨大的,现今的编程是软工,抽象不可能做得对所有人”都足够像”,比如那些不懂得ADT就想看一本诸如《数据结构JAVA版》的初学者[^13]. 当然,能举出的实例和联系,词汇远远不止这些,还有很多很多..

对于开发方式

软件是组合的，把软件比作堆积木的道理就在这里（软件可以只是无逻辑关系的组件组成的拼凑件-----在OO过后，曾经有过一次革命，认为组件也可以促成软件工程的银弹），可在各个逻辑层面进行复合.并且是一种组件化分别完成的过程。但是，组合软件的能力是建立在“通晓某软件”，“知道软件逻辑结构”等的基础上的，即软件设计，实际书写源码等能力上的，所以任何软件是一种异常灵活且复杂的“积木”。 在编程的实现[^1]领域,从来最终都是过程编程即Core C的那些指使计算机如何工作的过程式动作[^2]很好表现的逻辑〔类体里面也是,任何抽象了的代码其内部都是〕,所以,用了类,只是将面向过程抽象到了一个更好被复用的问题,并没有将如何实现这层抽象到程序员不需要理会,所以对于不懂C的人来说,即使它能很好理解C++的OO,也做不了什么好的C程序[^3],OO的强大只是指它类外的那些代码抽象模式。



初学者实践的难处
\section1

形象思维对于实践归纳也是至关重要的

复杂的科学，，也可借助形象思维去导向理解，二者并不矛盾

其实要掌握一门语言如C还是蛮有限的，可是真正的编程，软件工程下的编程，往往需要认识太多的领域与常识。这方面造成了编程学习的曲线。不难而是繁杂。
职能，经验的东西与技术的东西并不尽然相同
容易把技术发展为职能，可职能并不具创造性，只要超越职能，才有技术发展和职能的升华，----------------- 我在说什么。。。似理非理，，

编程其实就是英语，，语感就是那些脱离细节的天份形成的技能。

with designing,coding,debuging,testing,profileing ablities
above are all of a proger's ability

c stds,,qtcpp src generals ,win natives ,,,all y have to practise


虽然实践与理论关系的探究是一个由来以久的话题，但人们往往还是认为这二者的区别大于它们之间的联系。

市面上已有大量关于实践的书,那么为什么还要选择这本书呢?因为这是一本,一步一步把问题说清楚,再提供给你代码展现的书,而一般的书籍,上来只是代码展现.
从学会编程的角度来看，并不鼓励一个人从一开始就发明编译器这样的东西
实践一直被认为是学习编程的最好途径。然而这适合有一定基础的人。贸然实践。我相信很多的入行者得到的是信心的低落。而这种创伤无法弥补。于是急需一种对于所有新手来说略显平和的方式！而我相信这是《编程新手真言》能办到的,,它给了读者一种“painless guild to programming”

实践是一片大海,不想被海淹没,请跟我走,跟这本书提供的标准海岸线走.而且,对于代码展现,本书给出了最为核心而全面的实践能力展开所需要的代码量(只有5k).

而且,那些书大都讲基本API,没有实现,只有复用.这本书讲到了如何实现.只有实现能力,才是最终的编程能力.

本书只讲解那些基本的问题原理和语言问题,你可以看到,一个基本的概念,在它第一次出现甚至到本书整个部分,都在不同的环境下被涉及.本人深信,正是对显而易见的那类问题的不是真正上的理解,让我们对编程最终产生了一种障碍感.只有彻底面对并解决这类问题.我们才能真正很好理解它.只有真正理解了这些基础性的问题.真正的编程能力自然会随之而来.

这就是围棋高手,他们常常研究基础棋谱的道理.而不是高级的对战布局.




关于实践


is there a 最佳实践与源码范例
\title


一个程序员无论是工作在OS上还是VM上，都应经历，平台编程实践，语言实践，库与应用编程实践，也许还要加上个软件工程(具体到某领域，它可能是接下来要讨论的game domain programming或xxx domain programming)实践，所以本书定位于：focus on cpp,boost,windows,desktop game programming practise

这部分紧接第一部分而来,所以为什么选取“3d.vr”作为一般性问题的代表呢? 这是因为,VR和计算机图形学涉及到知识丛多,而这是一般问题(集)的特点. 而且,这里面算法和程序知识都很多,适宜拿来作讲解.


桌面游戏实际上是一次桌面程序，但也包含了自己特定领域的程序逻辑。所以并不是一般的桌面程序，既然是桌面程序,那么按照第二部分《第Ｘ章:系统编程之桌面系统模型》那一节. **任何一个"桌面程序"都是一个关于桌面级逻辑的有限堆栈**，即，本书是先讲common programming,再讲具体programming,对于具体programming，我们选取了3d.vr领域相关的问题和编辑来讲解。因为前面我们完成了c++ programming,windows programming,cg programming,ai programming那么到这里，我们就可以完成game programming了。 

前面解决了high native programming的那些问题，这里着手解决更一般的问题，如果把game当作“一次程序”，那么它必然也有自己的system programming,desktop programming 逻辑和编程层次。由此，本书addonsrc的安排也会按src/general和src/game的方式安排。


- - -

[TOC]

最佳实践
\title

2011年受dotnet和web dev的影响，将cpp换成qtcpp，将nativedev整合web dev
也是为了在传统cpp下建立起一套类dont和web的开发，发布框架，而不需要使用到发布整个VM等技术，完全使用软件VM运行程序等技术。
顺带建立一个uniform user and proger dev space use language
由python到js，，是因为受了web dev的影响
而现在，用qt作uniform userlvel and proger lvel dev space
with dymic compent support but not dymic language synax

 m p g e 组件结构非其产品结构。
 no vm scripting,,,plus dymic compent,,,========= quake3 vm and console cfgs
 qt中有消息交互的动态单元class,,,却无消息交互的运行期执行单元compent
 组件之所以为组件，，就在于它们要像源码单元一样，在二进制也能通过消息机制，，或其它机制，，，进行通讯。
进而可以被编程，被控制。

 其次，组件技术，，使得本地语言不需要以增加新的runtime的方式来提供vm，就可以为动态可执行单元成为现实，这就解决了 统一分布式问题 ,组件就同时可以作为发布和运行单元，分开语言系统与操作系统执行程序的方式(于是，scripts可以用动态组件代替)。并保持作为本地代码的效率。
the vm是作为compent vm而存在的
于是，scripts可以用动态组件代替，，于是，甚至根本不需要基于操作系统的运行时扩展，即dll机制，来实现所谓的plugin plugout system，，而直接使用可运态载入的组件模块。
 这样，甚至统一了程序员编程空间和用户编程空间，脚本语言不需要了。对用户编程的支持也可以像程序员编程一样。 而且共享同一门语言，同一种范式。而且，编程不再面向不可视的抽象，而是产品实物，engine这样的抽象模块，不提倡对它进行直接扩展，而command的定制，对engine command的定制？？
commander as engine front
commander based engine mods
 this is the end of both prog/user programming space
commander based game engine mods，，就是具体game,,,gamelogic


由于引入了虚拟机支持的组件技术，它就可以将基于引擎的扩展弄为引擎小件(对于用户定制来说，去掉mvc这种复杂的程序框架，而采用可视模型
mpgedk的重点在于对mpge engine front(the notwar3 engine commander)进行modding ,,使之形成新的game logic,,,在这里为止前面的所有动作都叫编程，(即发明mpge 的过程和扩展mpge 的用户编程过程。)，，至于用qml ,xml进行定制，是gui assits，，图形编辑器辅助的，所以不叫编程，叫生成配置。。
commander as engine front，胜过decl system scripting calls。。as the engine front for user modding





最佳实践，，肯定要分步的，，存在不存在这样的过程
最佳实践，至少一套是自上而下，一套是自下而上的，两套兼备才是完备

我们要求得一个"painless guild to game programming"(请参见书的附录：focus on xxxx)

桌面游戏开发最佳理论的和最佳实践，最佳实践过程应是什么样的，就像开闭原则一样，软件过程的大小并不矛盾可以同时存在，比如，它可以是练习用的小程序过程自下而上组成的大程序（小程序的缺点是工程规模太小，难展现大设计）

自上而下的设计过程也可以分解为小程序过程（然而它的缺点是让人去理解大架构先，再来理解小程序，学习曲线高，设计实现也难），，，，其实，在设计师眼中，这两者是统一的，对于非设计师的初级设计员来说，它往往只能从下而上，反之则不能，而设计师可以协调两端，变为统一的设计。

tmpge targets both at edu-purpose and real-project-purpose，，and fulfilled the gap between top2down and down2top 设计全景，also it shows多语言混合使用

tmpge also show 逐步练习的分步过程，和利用前者进行集成进行一次设计的过程。

tmpge同时实现了mpge的c版本，cpp版本，template版本

tmpge被设计成最佳实践目的（它的general部分，要展现c，common data&algos，system programming，game部分要展现cg，ai），从中你可以看出多个过程的痕迹（最开始是c的练习版本—主要用于data&algos，然后是oo的syste）。

然后是OO的highlevelsystemprogramming部分，最后是template的gameprogramming部分

bestpractise gameengine or muchparadism gameengine or bpmpge？

bpgl：bestpractisegeneralprogramminglib，，基本思路是实现一个仿gnulibc的东西（加入data&algos），再以template为shell，gp和dp手法，封装成类stl和boost的东西。afc部分封装第三方c库，然后做成template版本

>>以C为基础，模板为SHELL，可以避免光用模板实现带来的效率不足问题，STL这样效率敏感的库，应用C为基础，模板AS SHELL封装

tmpge是与bpgl独立并行的bookaddons，，它直接基于bp

mpge src中的well transable general部分，是2008的c generals加2009年的cpp generals组成而成的

08年的c geneerals是参照gnulibc实现的，09年的，是参照STL和BOOST的，但是它是基于原先C generals的，这是与boost最大的不同（boost不直接使用crt）

boost库，如果构建在原先的c语言的stdlib的部分(包括cppstdlib,but except stl)，往往是用template作为shell对过程的模板封装

mpge是练习过程小程序单元组成的，而且大量运用到外来库，tmpge作为mpge.ver2，是统一设计的，较前者，它对特定领域，甚至整个程序的抽象都处在一个合理组织的状态，而且体现了大方面的设计，，所以它是很好面向教育的

对general programming部分的安排(the wtos :generals, game stds)
\title

作者深感，编程界难于入门，知识繁多，而且新知出现突飞猛进，曲线曲折，进阶困难，突兀，所以，作者拟先提供一种编程解决方案(wtos部分)，，然后才关注于domain programming并发明一个游戏引擎来包含这个领域的所有逻辑。


作者原本想提供一个大而全的类OS的东西（具体见设计即编程一节的文尾），后来想这样的工作未免太大了些，所以考虑用现成的，屈服之下，直接采用了mono,clr,ironpy as toolkitlang的方案,比如用户适合抽象库，，，就用了clr这样的东西，所以便有了这个wtos，即：

c,ooplib 换成了 cpp
better c 换成了  .net vm
tookitlang 换成了 ironpy
ual 换成了  clr

总之，wtos并不是一种OS，即使它是，它也不是designed in purpose of replacine the os we dialy use,,,but prorivding an edu-purpose structed abstracts formed os,,即wtos主要是为了accomplished with mpge而设置的，现实生活中并没有这样一种OS(专门设置一个uniformsystem api engine)



后来作者将关注点缩小为：存不存最完美的具体系统加语言架构

最完美的系统+语言结构应是:

os with systemc runtime + systemc

native with userc runtime + userc(ansi c,,etc..)

c standardlib(such as glibc)

cpp both as (highlevel nativeprogramming language,dsl designing language,dsl extending language)

foundation class,,---------- dsandalgo lib,,,natives lib(bases on glibc),,,designing suportting lib,,dymic loading compent system,domain spefied lib  
the framework class -----    (nativeapp framework,,gamelogic frameworks),,,,,

above all as cpp's stdlib

no vm scripting language based on cpp runtime,,implemented in cpp lib level...

using its runtime to cpp to archive extending programming



再后来，作者进一步将关注点定在，存不存在这样的一个库


1.(标准库，准标准库完全用template替代oo，而使得CPP的OPP反例成为第二性的),难怪新标准的cpp要取消掉编译期的concept

>>cpp的标准库应该是类qt的oop libs ,作为标准库好像不太适合大量用编译期逻辑。

2.高级的语法总要从template手法去进行突破，唯一不同的是qt的库级OO手段(qt对cpp扩展是库级加工具的方式,metaobjectsys 就是字符串动态注册的hash map)

如上所说，，这样的历史传统，已经使得CPP中的OOP成为第二性的。而这是不可思议的。因为Oop处理最细节抽象，对象系统的提供是最基本的，基于oop的切面，concept离不开底下那对象系统，都要靠OOP来提供object tree。这也就是说，总要靠oop来提供抽象，这样adv oo system才能策略化组合它们形成新抽象

>>看过一篇文章叫《OOP的黄昏》，，其实说起来，OOP不会是黄昏，因为它已经革过命了，，GP，FP，不是复辟者，如果OO是一个国家的话，那么GP,FP是以OOP为国的小王国。

cpp模板技术害了cpp标准（特别是库标准）很多年，新发明的C系语言，唯一的出路是兼容C，而且发展OOP，而且要避开CPP已经做得很好的template cpp parts。，，语言tr和准标准库都围着GP转，最后发现自己需要的是纯oop，，好在人们也意识到了这个现象：

最新的cpp tr居然舍弃了concept ,这是它在舍弃泛型构建标准库，回归oop的表现。



再再后来，考虑到本书倡导有限实践，因此在书中不必提出一个通用的c++,boost实践教学，只在应用它们开发mpge时讲解涉及到的general programming(langtechs,design,ds,etc..)部分的实践。相对于“理论”，这是“limit practise c++,boost” ,更多请阅读附录部分关于本书初衷.故去掉了wtos的议案。

cpp没有一套可持续集成的库，，的确，如果说CPP是第三代语言，，，java,c#是第四代语言，，那么它们的区别不止是平台上的，语言上的，，还是库标准级的。。

这个根本的问题，其实还是cpp与java,C#的出现历史条件,过去现状，使命不同造成的。。。如果你能统一看之，，其实也没有什么。。

CPP STDLIBS不足以丰富得可以拿来就用，CPP的轮子不如java.c#多，而且往往需要重造轮子。。不好集成。

实际上，C++已经有足够丰富的库(它还可以使用C的库)，标准的，准标准的，针对不同领域的第三方的，所以，这些除了API风格不一而已，其丰富面，是一点也不让于java,c#的。

所以，为什么还要去造轮子呢，大部分时间我们选用加定制就可以了（以扩展的方式，以正向工程编程的方式，而不是hacking src的方式）。

>>为什么要强调“并非以hacking src方式使用一个C/C++库呢”？因为jfc.clr都隐藏了对标准库的源码级修改的定制。。而只能扩展。

java,.net把它们的库做进一个叫jfc,clr的发行包，所以，它们可以持续集成，，当一个CPP语言套件也集成了这么多东西的时候，而且得不到他们的源码，你说，你还需要去造轮子吗，，我们只能忍耐它已经集成了的部分，就像JFC，CLR一样，，而选用或定制我们需要的部分。。jfc,clr有大量的基础类，框架就留给用户去定制。

所以，我们只是没有找到一个类java jfc,jdk,clr一样的替代品而已，也难怪，就像我在《cpp oo vs cpp template》中说的，cpp一直没有一个像样的oop stdlibs。好在qt就是一个。

CPP之父说只有库才能救CPP，，MPGE即是这方面的尝试！！

----------------------------------------

对QT源码的改造：

总而言之，QT在很多方面都值得我们去研究，QT与CPP组成了一门叫QTCPP的语言系统（就像一门.net有它的fx clr一样），足以应付绝大部分通用系统编程。可是，它的源码组织是很难看的，，为止，基于教育目的，我打算把它改造成我所说的founndation,framework,product三层次。当然，我的发布并不带任何版权，也不对原版权造成冲突，敬请期待。

这套源码未来将成为MPGE的一部分。用来构建gameengine(当然，不像我上面提到的基于qt graphic/view framewrok 2dgameengine一样，mpge中，我仅会使用qt foundations/general/*.*部分)

对分布式架构的改造
----------------------------


本来想提出一个本地化的web框架，就像tao,opendd一样，后者不喜欢事事都依赖组件或组件based。转为提出一个轻量级，且不过设计错设计，充分利用nativedev框架，仅在这个基础上加入少量东西，就达到本地逻辑搬上web的效果。

首先考虑了x11这个业界已有的参照

x11是一种将本地应用转化为serverside natives的典范，，它设置了一个中间层，使得这个框架作用下，，可以在本地和远程应用同样的界面技术。。。与传统WEB的做法(设置专门的前端htmls)不一样，，与minqw不一样(minqw使用connector,reactor的通用tcpipserver framework)
x11与mysql,sqlserver的分布式有点类似，可是一般不提倡将这二个数据库用在本地，本地一般用sqlite

可是不行。完全一致的本地开发云开发，并共享一套开发环境，使用同样的发布方式的方案到底是什么

这个方案后来包括二个部分

1，serverframework(服务器协议设计框架：reactor,connector)
2,uniform minqw lpc and rpc



在我的distrubtor only web架构中，，gui server这样的东西是不必的，，因为一般servers，，都是基于console的，，，不必是gui的，，，如果是gui的，直接写成本地的gui逻辑就可以了


因为web是把前后端做在一起的（浏览器只作为viewer别无其它），它强云端的“肥计算---将云看作超级计算机”而不是浏览端的参与，对等节点的自组织而是中心化方案，业务跟非业务都在一端（连生成供viewer使用的前端内容都是一手独大的），，所以总有那么一种前端技术存在，，，何必多此一举呢，，所以不应发布带UI show逻辑的组件，不应像web前端一样。出现这么一个层面。

一个gcf的组件有界面ui文件，业务体dll，其次就是与其它与它互为客户的组件的交互脚本，与本身宿主的安装脚本
无界面组件，往往是提供服务的consoles，不是控件，有界面组件往往称为控件，


on demand web apps are often those with cosole and serverice，要将一个本地程序作为webapp，仅需要将它与实现了cgi的桌面程序通讯就可以了，所以从桌面开发来说是本地开发的事情，，就是一般的协议服务器技术了，余下的就是客户端考虑前端的事情了，

web 仅应是发布平台，开发，管理什么的，应保持在本地就够了，而且是本地程序的web，统一传统web(see my distrubotor only web archevnt)

这就是最后得出的“发布only web架构”

--------------------------------------------------------------------



为什么这样安排
\section1

对应于对理论部分“通用编程理论“进行讲解时所采用的为码系统。

胜任图形，游戏开发工作的能力
\section1

xxx

游戏编程的能力列表:
\section1

xx

[^1]: 一般地，在一些急功近利的中国游戏开发项目中，，根本没有一个通用的模块 - 引擎的存在，全是定制化的实现 – 快速的工具程序和游戏程序s。在游戏界，最主要的工作能力，是仅仅具备能组合各个层面的编程素材进行产出产品的能力就足够了，当然，引擎就是系统化的游戏编程素材(引擎技术和引擎抽象,它们代表了这个领域的大部分方面)，如能在理解某个引擎的内部设计和实现的情况下，就能更好具备判断组织哪些素材进行编写游戏的能力了。

(语言系统实训和应用开发)
\title




在前面我们说过，**编程无非二种过程，即建立抽象和复用抽象的能力**，如使用数据结构和算法来解决问题就是将问题映射为抽象，这是一个典型的建立抽象的过程。

任何程序的开发，都是由编码（处理解决算法，语言映射的语言语法层面的事）和设计（处理对于应用抽象的事，，语言语义层面的事），，是一个由语言到产品的过程（可能有多个产品。）


一般地，编程实践存在这么几个层次
在没有方案和复用件提供的情况下，往往用反工程和超越文档的方法去求得能反应到程序层面的东西，一般地：

1，会编级的东西，，强调反会编
2，C级的东西，，强调源码分析src annoting
3，CPP的东西，强调api docs

在一般情况下（使用库开发的情况下）下：

1，api kits，，在不需要定制库的情况下，或者他人源码不可得。从他人源码外部扩展就能满足需要。

2,,src hacking，，在需要定制并从他人源码内部中扩展。

层次又分：

1，大量依赖使用OS上的逻辑。使用SOFT VM的逻辑，语言标准库的逻辑。

2，一切从零开始。部分使用OS上，SOFT VM的逻辑，部分使用语言标准库的逻辑。


软件设计就是规划一个有机的抽象系统，，而且，这个过程是“一次完成的”，，所以，敏捷过程方法学，，妄想把它变成“多次的迭代过程”，使软件生命变成动态的。重量级的软件过程是昂贵的，轻量级的迭代过程则可以使软件过程不致于因周期太长变得无法挽救。这也就接上了预设计和修补设计之间的鸿沟。
为什么说软件过程是复杂的，昂贵的呢？这是由软件本质决定的，软件的本质即抽象，书写(源码)方式进行的软件开发，完全是一种艺术，几乎，你如果不知道或不了解：

1，软件的抽象本质----软件是由抽象组成的；

2，对于一个领域，存在哪些业界抽象，这些抽象处在什么层次，，哪些是实现哪些是扩展（具体的软件总由某个领域的具体的一套实现抽象加封装抽象组成）

3。在什么层次可以形成一套具体软件，已有抽象和扩展抽象的关系如何

那么，你就不会真正了解一套源码系统中：

1，为什么要提供那些源码文件对应哪些抽象

2。他们组成了一个什么样的对象抽象系统完成了一次设计。

3。为什么那些熟悉的源文件名字眼会出现几次，它们代表什么样的抽象区别。

程序语言技法,语言标准库,或第三方应用库,都是方案,对于游戏开发,它涉及到的方案域更是众多,对于一个实际游戏的实现,语言方案和组成游戏各子领域应用方案都是必须要了解到的.

pmec and engitorQTframework - pmec 实际上是一种qt的改造精简版加qt gcf集成的版本,mod for engitor 实践及例题

本部分,即展示了从语言到具体游戏子应用方案域来实现一个具体游戏的过程.

为了最大化教学效果,先提出问题和方案,再以程序论述这些问题和方案,特别是最终的msgd,即多风格游戏程序,mutiple sytle game demo,更是从教学上体现了一个桌面游戏的抽象与设计.

- - -

[TOC]



一次编程中的数据结构和算法
\section1

xx

一次编程中的应用和设计
\section1

架构师的能力就是设计能力,,,程序员的能力就是编码能力(然而在每个小问题上每个小模块上也存在设计,所以程序员也是一个设计师,不过他不直接面对复杂的大系统而已)

所以什么是设计能力就出来了,它泛指一种真正的编程能力,即将现实问题映射为语言逻辑的能力,(找轮子是作设计的一个步骤,),那么设计能力要求你有什么样的能力呢,,当然,现实问题的模型你是要清楚的,而且语言逻辑也是你要清楚的,复用的库你要从语言的观点去搞清每一个接口的真正意思(无论用什么语言,,数据结构,设计模式和语言本身这三者的逻辑是不变的,,其它的就是具体问题映射到语言的能力了),在整个设计过程中(映射中),,你必须清楚每一个步骤,,因为软件设计真的不像拼零件(小软件和简单软件开发过程可以不需要明确的设计与实现的分工过程),,大型的软件接口太多,,你必须熟悉每一个功能模块,,和预见每一个功能接口..这种细节的无限性决定了软件的复杂性和设计实现时的清楚性,,否则就是编译不过,不成软件..那意味着项目失败



从设计到编码，存在着脱离了语言的映射和结合了语言的实现映射，人们通常把1作为架构师的工作,而把2作为程序员的工作而已.如果架构师的工作深入到类的类部[^1],深入到详细设计,那么他实际上担当了一部分程序员的工作.但在人类的工作中,二是受一控制的, 也即C程序员的能力更多在前者(数据结构),而数据类型属于后者,设计模式,面向对象都是后者,是C++程序员或架构师的事. 对于2,即实现.跟具体语言有关. 程序员对于算法,数据结构,数学实现问题这些细节的实现问题,和对现实应用的抽象问题,把握最重要,而不仅仅是语言能力,代码抽象能力(我们知道这三者是不同的模式,在编程中是解决不同问题的),如果有架构师的工作在先,C的程序员仅仅需要提供函数过程模块,(极度求接口化和求极度模块化,设计是需求驱动的,接口是要提供的功能驱动的,都是不必要的那是架构师的工作)三种流程控制结构加简单的类型机制,已经能将一切现实问题的解法映射给计算机[^2],学再多的语言,再多的语言机制,不过学到了更多的映射手段,代码结构方面的东西,真正要解结的问题呢,反而被模糊了,对语言的学习应适可而止, (要精通所用的语言的语法语义) 我们要编程解决实际问题,必须熟练并精通语言这个工具,它对应应用的那些语义语用方面. (要精通处理什么样的数据) 《数据结构与数据库》(编程与数据)计算机就是用代码来处理数据,那么对应Python来说,它提供了什么样的处理数据来解决实际问题的能力呢? (要精通写什么样的代码或使用什么样的框架) 《算法与架构》(编程与设计)写什么样的代码,,,不再是写什么样的实现,什么样的算法的问题了,,,而且还是要体现什么设计,,构造什么架构的问题,,如果说面向过程的写代码就是注重设计算法,,,那么在OO这个注重可复用(而且现在这个年代,我们大部分情况下是一个开发者而不再仅仅是一个实现者,我们的确经常是使用外来库来构建应用)的软工时代,,而且要懂得设计架构. (要懂得待处理问题域的细节),比如第四部分的《Python serverside web programming》从这一部分开始讲解用Python进行web开发的细节,我会向你介绍web 编程的大致面貌和领域相关术语.

多次事后的维护
------------------

>>关于调试

一个程序的能力往往不是体现在它能活用抽象映射方案，而是体现在他能利用一切可能的手段去调试，这涉及到程序和非程序的诸多领域，比如调试
在编程界，要放下一切所谓速记类的天分跟机器打交道你只能变得比它还木呐，或者说循规蹈矩，不要寄希望于能记起你刚做的修改，因为它早已淹没在抽象的细节海洋中了。(谁说编程一定全部是智力的投入没有体力？)


在一个充满着全局变量符号的大源码体系中，光靠事后的调试真的很吃力，如果有事先的模块测试，可以省掉很多以后一旦出错就要找BUG的努力，测试是xp编程，debug是系统编程（如果用编程的眼光来看它们的话）
debug是system programming,而test是xp agile programming(programming for xp agile) 

调试,是很重要的过程(静态语言除了编码基本靠调试),对于程序员来说,如果它不是最终的产品产出者,,那么其地位,比测试还重要. 软件开发调试测试就是那些有时候不难但绝对很繁杂的那些东西,调试的时间耗费惊人，软件百分90的时间花在开头和最后
调试让编码继续,而测试让产品发布前进. 
其实，一个程序员最最重要的能力，，就是出了问题可以变通去解决，，绕过那些你不知道的，用一种拆中的方法，适合自己的方法，让工作继续，比如调试能力的具备往往就是最关键的。 


>>关于src hacking与编程

source hacking to yourselfs is better than just importing it.to be a real proger,the only thing u have to learn to do,,,is hacking the sources

编程中，理解一套宠大的抽象，整理出其底层接口之间对应于系统逻辑，语言逻辑的关系，，还是最难的，，这就相当于读会编，整理出它对于工程级的逻辑一个道理


算法仅对无源（程序可以参考）编程和有源需要参考其中的算法的情况下有意义。

对于一个programing novice，，，不使用太多封装库，hacking太多开源库，往往是很好的实践手段。
懂得代码hack也是好程序员

src annoting and src hacking is a qk way to learn to practise 大于 just importing the src apis，so mpge.ver1 include original magos,fear,raknet src

随书源码考虑将src hacking做成与正向代码mpge源码体系风格一致的整合，这证明，反向与正向工程，最终走向同一个工程，并不矛盾。而src hacking这个动作，其实也可以算是方法论中的迭代过程。


小总结：
\section1

对于一个程序员来说，语言能力是最重要的，方案运用能力次之，对问题的掌握排在第三，算法和科学基础的理解排在最后。

[1. 假设他在利用OO编程]

[2. 在命令式编程语言中,控制结构等等被证明为可以产生一切逻辑..因此具备三种控制结构的语言都可以成为产生一切逻辑的语言..]

[3. 实际上core C里面有很多东西,可能你以为的C远远比不上真正的C大,你眼中的C可能只是真正的C的一小部分,请参照本书第二部分第四章&lt;最小内核语言C&gt;]

[4. 虽然工作能力,大部分情况下只需要你是个api kits,懂得业务逻辑和API使用就可以.但这绝对不是普遍意义上的“编程能力”,在本丛书第二本中,你将看到详细的解释.]

[5. 离开了数据结构你当然可以写程序,但几乎没用,一个离开了数据处理的程序能有什么用?这就相当于学会了使剑,剑的套路,却没能学到功夫一样,这就是为什么你要学数据结构的道理.]

[6. 往往我们把复用能力当成编码实践能力,把设计能力当成广义的编程能力]

[7. 很多人不明白,他们学习语言,最终学的就是这个,1语言特有的或普通OO的对问题的抽象与解法2,编程界对问题的抽象与解法.你将在本书语言之争开头讲述语言与应用关系的时候再深克看到这一点.]








关于编程能力
\section1---

理论给你统观全局，全面的知识系统不会让你有“知其然不知所其然，实践的时候出了问题联系不到任何解决问题的契机”

1.实践给你下手逢源的能力 
2.实践给你实证实验的能力 
3.这样，下次重新实现的时间变得更短，至少不像初次的什么都要考虑，什么都卡在细节上，整个工程濒临不可能完成，所以，请忍受你的第一次大型开发的进度难度。 
4.这表明，你已经有实践能力了

>>作为＂编程老手（比如一个api kits）＂，远远达不到“编程科学的master”的境界，，碰到新问题时就会卡壳（不是写不出代码而是做不出设计），代码能力(“语言和库能力”)远远没有“计算机科学”和“编程科学”重要，一个鲜有代码能力的计算机科学和编程科学master借助 
一个鲜有代码能力的计算机科学和编程科学master借助伪码或Uml类工具（再结合一点语言能力和库接口调用能力），，可以迅速完成一份设计，完成一份开发，，实践的能力在这两个科学先然后才是语言和库代表的工具能力（理论和实践，，只是完成这三个过程的伪概念，故并没有真正的理论和实践一说）

实践能力的具备往往只需要做一个项目（这个项目最好是面向教育而显得清晰面面俱到的，最好要把这个项目死记硬背下来），工作要求灵活的实践能力，因此最好，做越来越多的项目。来求得灵活随机的工作能力。

经验是不能成书的知识，其必要基础是时间及累积的时间。大量不能成书的细节，知识的累积。而这恰恰是能力中很重要的一部分。非实践不能解决

真正的程序员可以从需求到程序到产品,,或反过来，，思想上有充分想得通的自由度,,这是唯手熟尔的最高境界了,,一般地，从对编程毫无基础到能精通编程（熟到能变通地直接或绕过解决任务程序语言层面的问题甚至细树未节---领域问题不算，，需要至少五年时间，几十W的代码量）

>>何谓唯手熟尔

一个库非一个月不能算是熟，即使你第一天就了解它的全部基础用法（也许是借助一份touris，APIREFDOCS）。

因为任何一个应用实际是一个应用体系（如果以库应用和语言应用的方式看待编程，而不是以开发眼光发明应用的眼光去看待编程，比如，在没有大量库发明之前的C++编程情况之前，它即是强调用重开发的眼光来看待编程的，直至后来有了BOOST等才改变），有它不断深入和扩展的应用情境，所以，应用库，且仅仅把它当成一个工具，，也是一个体验过程并不是一个静态过程（仅仅会用就了事，还要活用），于是有：

1，将语言和库看成编程应用是开发实践的第一层，将库看成编程实现是开发实践的第二层，显然地，后者要求的能和要更大些，MPGE即是对这二个过程的展现都有。

2，在业界提供了参考方案的情况下，能灵活地使用这些方案（从语言到库工具），完成不同寻常应用的，是实践的第三个水平。MPGE对这个过程也有展现（它展现了一个“多典范游戏”的程序和产品设计）

3，能独立解决问题（算法上的），在业界没有提供参考方案之前（反工程得到），能提供从编程到应用的全套方案的，较之实践的第三水平（旧瓶换新酒），这已经属于发明和创新了，是实践的最终水平。MPGE对这个过程仅是一小部分的展现（反工程FFXI，它没有提供新算法上的东西。。它主要还是限于旧瓶装新酒）。

往往，大多数情况下，我们仅能做到实践的第三个水平。
 



编程时碰到的信息量永远是巨大的,有生之年我们不可能掌握这些信息的来龙去脉,对于程序员来说,提供一个关于它的编程参考文档可以说是掌握了此信息,因为这个文档就是这个信息的大概,实际上我们编程大部分情况下都只是用第三方的代码库来编程,这个信息用于编程所需的全部东西,对于编程来说只要掌握这些东西就行,**其实,宠统来看,最终的编程也只是体力活,不要把编程想得神圣,它整个做的事就是用特定而狭隘的方法解决同样特定而又狭隘问题的一个典型**),换句话说,一些知识如果不能理解就得先放(这本书并不适合于赶考使用), 在这个信息的社会,至于信息,是撞事学事！一个程序员并不全知全能,它只提取和了解事物对于编程方面的信息.对于事物的逻辑认识,只能在对它的编程中不断掌握它,抽象是惯穿这本书的重要的思想,维度也是,我们是从学习编程的眼光来组织这本书的.也是站在初学者的角度来解释诸多概念及其关系的.

语言能力是剑法,对问题的理解能力,是心法,最终的编程能力,是脱离了表达问题时总要涉及到对语言元素进行处理而直面问题的境界(一个谙熟的泥水匠会时不时去研究工具怎么用吗?),比如《在windows下使用会编得出保护模式地址》之类异常活波的话题,如果把编程理解为解题,那么,我们得要用公式和原理,或者说解题的惯例,,所有这些,都来源于对问题的理解,和对语言的把握.如果说,编程具有灵活性的话(人们说编程很难说,那是因为编程这个领域支节实在太多了,任何开发都是交错的,而其实只要在掌握一门语言的某些机制的情况下,集中在一个角落开发而且所学的语言就足够用,那么你就会发现,编程其实是很狭隘的),那往往是处在一个特定环境下被讨论而已,基本的思路和实践套践是不会变的. 一切东西,我们应该查本究源,深入其原子世界[^26],深入原子世界,深入只是为了获得浅出的能力,在解决表面上显得很浅,但其实底下原理有着一坨障碍性的问题时获得明朗的能力.往往对问题的第一眼的理解是从字眼着手,顾名思义有时是个极好的习惯.这就必须注意相关书籍对同一个概念的命名,翻译过很多文章你就知道要措词,措词跟概念有关,二个稍微相差不大的措词都会让读者摸不头脑或让他们恍然大悟. 然而千万不要走入另外一种极端, ,知识用词和技术用语没有一个标准,比如方法和函数指的是同一个东西,比如什么是线性(一次就是线性),什么是离散(离散了的量),这都是仁者见伍,智者见,但人们对此的理解都不会差到那里去,并且也不会影响后来的学习,这里有一个描述或形式的概念,相信大家都还记得初中学过的集合,是描述性概念,但集合其实还有一个形式概念,给定了形式就可以框死,书中力求对某些至关重要的那些概念进行形式化的描述. 而且,要知道,即使是《虚拟机的原理与设计》[^27]这本书的作者也会对别人书里的进程概念感到不解. 最后,什么是编程能力以及语言能力是不是就是编程能力的区别,比如拿编程语言来说,只要越过语言的表达这一层,我们才能用语言表达和理解事物[^28],就像口才,一个好口才的人说话时绝对不会想到措词,因为语言已经成为一种意象,只要把一样东西思想化,才能超越这个东西而去想到别的东西而长足发展,比如面向对象,这本书将帮你解释为什么面向对象是一种科学的机制,解释的过后你甚至会觉得这是一种本来就该存在的很亲切的机制,只要超越了面向对象我们编程时,再加上一定设计模式,才能真正不会一动手编程就考虑什么是面向对象之类..(而这些,好像都是一个高手所能做的事了.).本书主体中的二部分就是认知和实践,思想和细节的结合,所以你要做的就是在认识的基础上作大量实践.,每天写小程序,编程能力就会日渐提高,而当你写过和分析过很多程序之后,你就会具备一眼看出的本事,过程的最后你发现自己蛹变蝶飞了, 我注意到程员序考试中多了一项标准化,的确,知识的传达也需进入标准化时代了 

\list 对于语言

看完了本书对目录的组织,对特定的编程,你要学什么,怎么学,应该一目了然. 编程涉及到所有上面这些,因此要学好一门语言解决问题,不但要学数据结构和算法,系统问题,,精通语言的语法和库,而且学习的另外一点还要包括:抽象和设计,现实问题,人类软工知识... 最好的顺序是学平台,然后学语言,数据结构算法,最后是应用,而在这其中,最重要的是学习语言,而学习语言,最重要的是学习数据产生模式(数据抽象)和数据结构和代码产生模式和代码结构.

就学习一门语言比如C来说.我们最初学习和接确的当然是它的语法语句,综观C语言的语句形式,就只有编译原理后期翻译的那些语句形式了,即Core C的那些东西[^3]. 由于语言是由语法定义的,因此我们称,类型,表达式,控制语句形式,赋值语句,这样的东西为语言的要素,打开任何一门关于程序语言教学的文章,我们都可以发现这一点..对C的介绍请参见第二部分第四章. 而字符串,IO,异常,标准库,数组,与Windows的接口,这样的东西是语言的高级话题,和高级功能,不是语法级规定的,,比如可能是库提供的,库与语言的关系请参见以后文章

以上这些,其实都是表层,都是人类将某些根本的东西加以泛化得来的.我们将承接上一节讲到的话题进行讨论,承接上一章的精神, 因为,人类的所有东西,都首先是某种抽象.只有把握住了设计,你就从整个大面上把握了编程(这当然也包括编程语言本身).

如何选择一门语言,及该学些什么以解决现实问题 比如,确定选择C++了,那么要精通它的每个细节,工具自然是越顺手越好用,然后,对于应用领域的选择即对目标开发领域的学习(当然,这之前是选择在哪个平台上进行),比如,你想开发游戏,但其实,游戏跟C++“在历史上能解决的”,“正确抽象了的各种其它问题”,息息相关,所以,其实,“编程就像解题,你题解得越多,那么你就越会用C++解决现实问题”,不要以为,只想学WEB开发就以为只掌握WEB开发框架就可以,(实际上,WEB框架解决的抽象是整个WEB问题中最为有限的一些,你还得涉及到业务,涉及到C++解决过的问题的其它方方面面其它领域),,也不要以为,游戏开发,比如客户端,就是DX,其实它涉及到C++解决过的问题中的“界面,多媒体,COM等内容”,而服务端,还涉及到“网络,数据库”等等.

本书的名为“系统眼光看编程(语言)”,开发眼光看问题,但其实,本书,花大篇章描述的,正是“问题”,即300多页的初级系统问题,和300页的桌面问题.反而,对于语言,我们强调“够用就行”(语言问题从来不是整个编程中的最重问题) 我们深信,对实践划定的这二个主要领域,和你将对这个领域的这笔实践投入,会给你以后的编程之路带来丰富的能力.(虽然编程存在很多方面,但只有这二个方面,是需要从细节上去把握的,并作为基础知识实践于你的整个编程生涯的,这就是“有所偏重,有所侧重”的道理),所以本书,从数据结构讲起,再讲系统本身

实际上对于程序员,数据结构学这样的实现逻辑是你应大力学习的.你的主考官都相信你会简单的面向对象写程序和复用,理解业务和业务APIs,但就是不能确定你能不能用数据结构自主解结实际问题.[^4]系统底层=C语言加数据结构,算法,,,,这二门学科刚好完全地归纳并解释了编程对应于计算机底层的方方面面..其实C语言很简单,基础的指针用法也很简单,如果学习了C语言版的数据结构,因为这是在学习C的习惯用法,,因此指针的很多抽象用法也会学到,,也就同时学会了C语言和数据结构,,,因此学数据结构是学习C语言最好的方法.. 深克地理解了算法与数据结构,你学习编程才算到了家..因为你真正学到了用通用的编程语言解决现实问题的方法[^5]. 数据结构,数据结构中的"数据"二字永远是一个程序的中心因素,,从普通数值,字符串,数值到结构体到OO数据,体现了人们封装程序开发数据对象的复杂性的要求..而且这种发展是为了产生一种更广泛深度的开发方法的(冯氏语言就是在类型上构建类型,再构建数据),这导致了语言对数据的更复杂抽象, 有数据结构就是因为如果你在汇编下编过程,就知道程序是数据跟代码的结合体(计算机就是用代码来处理数据嘛),数据本身从数值数据,字串数据啊什么的泛化到了oo的class,,,那么在内存中这些数据该如何存放(及如何更高效地存放)以进行程序执行时的动态内存(就是数据流分析工程)呢,这就出现了数据结构,,,那么当这些数据不用时要等到下次用到的时候怎么办呢(就是字节流),这就是数据模型的持久化称为数据库技术(由于数据从基本型转到了OO的CLASS型,因此数据库技术也就进化到了OO的数据库),线程的泛化是并发,并发在很多时候都被要求用到,比如操作系统的多任务,网络中的一对多,数据库中的同步等等,因此一门语言必须不能回避并发性 一门语言更高级的就是,数据结构,线程,网络,界面,数据库,组件啊这些高级内容了,下面一一道来 无论如何,一个程序员是要经常学习新知识的,如果不能快速接受(比如你的基础知识跟不上来),那么基本上你会很累,大学只是学习这个基础知识的阶段,你最好把编译原理,离散数学,汇编程序设计,操作系统,C语言,这些基础弄得滚瓜烂熟,,并积累一些具体的开发经验,,等出了社会之后,你会发现社会上的编程知识跟你在大学学习的东西差了去了,这个时候你的这些基础知识就发挥了很重要的作用,你需要这些基础来理解软件开发中的后来的大抽象大学问,新思想,比如DP,AOP,OOP,DSL,STL,UML,REST,COM,J2EE,etc.. 总之钻进去了,也就是一种乐趣．．好自为止,

数据结构不但是最接程序员的基础技能。近实现抽象而便于研究一套源码系统抽象起点的东西，而且，在处理io,文件读取等关乎系统编程等方面，它是必不可少的。数据结构实在是程序员的基础技能。
在源码阅读中，表示结构和存储结构往往不一一对应，能解释这个的唯有数据结构学了。


\list 理解方案域，组织抽象，完成有效设计的能力

基本上，问题往往是源于从文档上获取不到正确的操作方法，立刻能变为程序的，，最不拖泥带水的方案，当感觉编程无以为续时，那往往是你忽略了对领域问题和方案的研究。
换言之，一个程序员知道如何最终去解决一个问题。产出产品。如果问题不是出现程序上，而是出现在文档方面的知识获取上，那根本不能算是程序问题，只能说是知识问题。


在抽象一节中我们知道，抽象使程序员更加关注方案域，而非问题域，可以说，抽象使程序员全部，而且仅需要关注方案域，这样设计就是一个有限的方案实现，于是：

**程序员的能力不包括掌握问题域，而仅仅需要了解方案域，或作出一部分方案域的设计或实现。**




在正向工程的时候，有时候，我们需要一些手段，来促成这个过程
1，事后调试（往往用工具如debugger完成，或语言内的某个logger()过程）
2，事前测试(同样是用编程的方法来完成)
3，src hacking,docs reffing

所以，正向和反向工程，其实他们都是统一的，为了全面编程这个工程而服务

更多非直接编程但服务于编程的工程手段还有

1，写UML
2，写profiler
3, 写docs

这些，都应记入程序员能力当中。

----------------------------------------------------------

在调试时，有时是对数据流进行分析，有时是对二进制码进行分析，以超越文档，求得方案域的隐藏细节。







>这也就是策划的工作职责之所在，他们不必了解专业问题，而只需要了解方案实现，然后提出一套设计供程序实现。
\list 对于问题与设计
以C++来说，编程的能力就是C/C++（语言技法：指针，引用，模板，基于对象面向对象），库（对语言和应用领域的扩展：智能指针，字符串流，并行），

你应该知道,真正的编程能力不是使用轮子的能力(复用能力),这根本是因为设计上的开发只是抽象,而是将现实问题用编程语言来解决的能力(这就需要你具备设计能力,即很强的代码控制能力,能把现实问题抽象为代码而不仅仅满足于使用别人现成的库)虽然复用能力与设计能力都貌似语言能力,从语言的眼光来看,复用能力是属于设计能力的,但实际上他们还有很大不同的要求有不同的语言能力,有些人具备在不懂STL原理的基础上使用STL的能力,但它们就是不能用STL来实现一个STL..这就是上述二种能力的根本区别的证明[^6].

>要知道,程序的编制者跟程序的使用者有时是不一样的,这二者要求的能力是根本上不一样的,C++的模板就是一个绝好的体现,写起来难,用起来易.C++的模板是用来书写高抽象库的好工具,会复用并不一定会写.当然,这二者并非绝无联系,理解stl库的实现过程中使用到的模板理念显然可以帮助我们复用这些规范(接口)进行实例化(使用接口)的过程.

有时难以理解的绝对不是代码本身(语言的语法和语句有限),难理解的代码是其中体现出来的设计元素和应用元素(有限的语法可以体现无限的语义,对应不同的应用体现不同的设计)..也就是所谓的算法和设计,,有时是设计模式,有时是现实问题模型的相关抽象(其实算法和数据结构也是计算机开发中历史形成的抽象,,即某个“现实问题”,但一般将它们独立出来). 实际上,数据结构,设计模式,现实问题这三个东西跟任何一门程序设计语言都没有关系,因为任何一门冯氏模型决定下的开发语言都满足这些东西,,而且计算机界的一切软硬基础都是算法加数据结构的集中体现(再往人类的软工一点,就有设计模式了), 我们编程往往涉及四个能力 语言语法的,比如流程控制,数组,IO,字串,class,OO 数据结构和算法的. 设计模式的 现实问题的. 看不懂一套代码,主要是: 你不知道普通的语句是体现什么样的数据结构 你不知道普通的语句是体现什么样的算法 .........抽象惯用法 如何向现实问题靠近抽象并设计的 现实问题的复杂性,跟语言逻辑的简单性,非dsl之间的矛盾(语言从来被设计成通用的).. 用某种语言来编程,体现的代码控制能力只有1是必要的,然而具备了1并不意味着你就能定出某种数据结构,或设计模式,,或抽象出某个现实问题,,因为那根本是另一些领域需要你掌握的东西(而不仅仅是语言能力).所以你汇编码能力并不意味你有编程解决现实问题的能力.你有编码能力所以一定有复用能力,但你不一定有实现这些轮子的能力(以及阅读这些代码时认识到这些轮子设计的能力,这样你阅读代码的能力和眼光也会受到限制,只限于简单的复用能力,因为复用能力只要求你拥有接口复用能力,,真正的逻辑不只是接口间的简单复用,而是接口间复合形成什么样的抽象以及如何逻辑上形成这样抽象,这就不仅仅是接口复合作用了). 所以真正的编程能力在于2,3,4,加1编码能力,,所组成的综合编程能力; 程序员的能力模型,语言30%,数据结构50%,对现实事实的抽象理解能力10%,,设计模式能力10%.. ==100%.

**学语言,我们最终是学到了一种手段,语言的语法机制只是这个工具的规则,语义才是我们所需要的,它如何呈现应用的那些设计手段,以及计算机界对某个领域在开发角度的全部抽象.才是与应用最为密切的才是我们要学的[^7]. **因此，学习编程的一种好办法就是：用对领域编程的学习，带动对编程本身的学习，这二者互相良性循环。** **

****真正的编程能力最终是设计能力！！对现实问题,思维模型的学习！！而非对细节,对平台编程！！事物的OO解只是事物解空间中的一种而已！！

\list 对于专业知识,其它领域逻辑

程序员只是翻译家,不是计算机科学家,或系统分析员,它其实跟英语更接近一些,而不是数学,当然这句话是针对非专业程序员来说的. 那么编程学习需要学到数学吗？尤其是一些专业数学？ 当然,专业计算机学生可能要学到线代那样的东西,那么程序员需不需要学数学?编程能力本质是什么能力? 编程本质上是不需要数学能力的,当然如果你是在进行数值方面的工作,并涉及到用计算机编程的方式来解决这些问题,那么这是要懂数学的,然而另一方面,如果一个不懂计算机不懂编程的泥水匠也得用数学知识去解决问题的话（比如计算机图形学与数学的关系）,那么他也是需要这方面数学知识的,所以,所谓数学知识,,是不属于编程能力的,而只是领域能力而已. 比尔盖之喜欢招物理出身的人,因为它们具备很强的想象力,抽象力,对复杂事理的理解力,虽然他们中的一些也有数学知识,但实际上,数学知识只是解决问题的工具,比尔更看重它们的抽象力等东西,因为抽象能力和想象力才是编程能力的根本.换言之,抽象能力是具体能力之上的.编程是不限于解决数学问题的,所以除非你是编程作数值计算的,那么在编程中,你需要的就不仅仅是数学知识了,如果不是编程作数值计算的,那么你可能几乎用不着高深的数学知识. 当然,计算机实现是离散数学基础的,编程中的数据结构等东西有一部分是离散数学的,lisp这样的语言原理也是来自那么大理论的,掌握一定的数学知识对最终理解编程是巨为有用的. 也即,用计算机研究数学和用数学研究计算数,,,,这产生的所有知识都是数学,,都是离散数学

更多相似的内容可以在结语《编程和游戏编程中的科学基础》中找到

\list 对于工作

编程能力关键就是手熟能迅速产物, 有时候，人们也称mysql工程师，MFC工程师等（这些库对于它们所表现的应用领域太有代表性了，所以人们以库指称那个领域的开发工程师）

Divcss的组合就造成了一种职业，这就是网页美工，设计师等，divcss实际上是网页排版师的工具，虽然它是一种语言，但不妨称为工具更恰当

对于编程和游戏编程要达到什么样的能力才算是会，达到什么样的能力才算是可以胜任其、相关的工作，对此，在二个大部分导读的能力部分安排中已经讲过。这里再综合讲一遍。

丛书第二篇讲的,只是通用设计,与通用问题,其实编程的实践远远不止这些,比如EJB,比如WEB.如果你的工作中涉及到这些,你还得上前一步,学习... 比如拿起一本《精通EJB》,《用jsp设计一个电子商务网站》之类..或本套丛书的第三本..

这是因为设计和应用,永远都可以有它的新形式和更高形式,正如我们在第一本书《抽象应用》中讲到的.

但是无论如何,走到这里,我们已经算是个程序员了，言下之意就是:编程虽然远远不止这些,但能学到这里,具备语言能力,设计能力,通用问题分析解决能力,这对解决差不多的问题.也差不多够了 有了基本的理论与实践能力,最后仅需的工作能力就是“综合编程能力”.(**实际上,那种“在获得api docs的情况下能快速实践的能力”就是综合编程能力)** 综合的编程能力,对于编码控制，主要就是指实际的语言映射抽象能力和出错后调试的能力了 : 在获得api docs的情况下能快速实践的能力(解决一般应用问题的能力)
我们在前面说过，最浅层意义和最少能力要求的编程，就是组合库，设计UML的能力，这就是基本意义上的编程过程(见第二部分game,game programming导读)。 在前面二本书里,我们一前一后地讲解是编程必备的实践能力中的语言能力,和运用语言体现通用设计和解决通用问题的能力. 那么,这本书里,是向你证明胜任一门工作所需的那些能力.
>或许，获取领域逻辑也是一个能力，比如有的文档不可轻易得到，此时就需要反工程获得。以超越文档的方式。这也是本书附录安排《对FFXI 的反工程》一节的目的。

**你的工作所需的能力,最终能力,就在这里..(反而不是前二本书说到的语言能力和通用实践能力,而是在工作中涉及到的最终的创造力的东西,即综合编程能力)**
\list 找工作的能力
(对于找工作，你只需要是其中之一就可以了)

当然，这并不要求你是个数据库工程师或网络编程工程师 - 工作对能力的要求划分就是数据库工程师啊，图形工程师啊，界面工程师啊，如果你会一种库，也可以叫MFC工程师)，
编程的能力列表: c指针，C字符串，C的类型（数组，其它单体或联合类型），C的结构，c的位操，C的宏，C集成汇编，C代码的调试,c项目的测试，C的内存管理

C++的类型，C++的引用，模板，类，基于对象面向对象，

数据库开发工程师

网络开发工程师

**对你死亡级的提醒,请不断写代码唯手熟而的方式是阅读代码,成千上W,并实践！！！**

[^1]: 系统问题,是用C和数据结构,算法来解决问题的那一类典范, 实现这个概念是语言相关的,用C的语句和语法写代码,和用py的语句语法写代码,二者在各自所属的语言内,都是实现.,我们把语言内除了抽象语法和设计语法的那些基础语言设施(基本类型语义和流程控制)称为core c,在编程的实现领域,从来都是Core c的那些逻辑..

[^2]: 数据编程才是真理，因为我们的计算机是一台数据机，所谓OO，只是将数据编程稍微抽象了一点，它只是一层仅可供工作的壳，在大多数时间，我们依然要深入处理数据以进行编程。

[^3]: 类只是将实现套了一壳,从而将面向对象层次的复用维持在这壳外,壳的里面却不行,照样是过程编程

[^4]: 而且OO继承是为了重用,封装是为了复用,等等

[^5]: 泛型的型与OO的型

[^6]: 还比如,用c实现的数组和用Python 内置的List实现的数组

[^7]: 因为C++代码本身虽然没有跟C一样跟现实问题处在二个最远的极端,但你看懂了代码却看不明白代码后面数据结构方面的东西,这是因为你还得理解数据结构这些非语言的东西,和现实问题

[^8]: C表达的向系统问题接近和Java表达的向现实靠近各有各的难处,作为一门工业语言,要求它看起来便于程序员理解和复用,Java这方面是做得不错的而C肯定只是专家语言, 在本书后来,你还可以发现更多的语言之间的比较,比如本书第二部分第三章语言之争

[^9]: OO在语言端有抽象事实,访问控制,复用,接口,代码和数据抽象的意义,在应用端有OOAOOD的意义.新手难以直接理解其真正有用的那层意义.

[^10]: 编程应该是死的,然而它被做得太灵活了,这就是它的错

[^11]: C++的错就在于: C++是语言,作为解决问题的工具,语言都做得那么复杂,这就是C++的错.

[^12]: 以我的个人经验来说,C的声明和实现分离机制尝试解决的问题比他没有提供这种机制带来的问题少得多.

[^13]: 编程难就难在对其的切入困难,对于新手来说,他得同时了解语言,设计,才能看懂一个稍微中等的程序,如果我们能提供二套实现同样功能的程序,一个用过程式,一个用OO,那么新手就会知道,所谓过程,OO只是程序表达手段,真正的应用其实是另外一回事,而他,会去尝试了解编程界对问题本身的抽象,也会主动去学习OO,过程式.这样的学习过程是最好的.

[^14]: 我实际上说,有些IT的问题不纯粹是IT问题,并不能直接用IT原有的知识来解决,就比如,JAVA到底比不比其它语言优越,,这是软件的问题,然而它跟人有关,,跟软工有关

[^15]: OO这个东西不仅是技术问题而是软工问题,是为了解决编程方式跟人的关系结合产生的

[^16]: 真正掌握了这些基础,你会发现再多后面的技术用语及其背景都是支节,比如,编译原理,操作系统,C语言,从数据结构的眼光来看,都是同一些东西变来变去的组合罢了

[^17]: 从数学上来讲,离散量,就是指计算机能很好处理有理分数,有理分式,代数多项式,等这些用整型,有理型浮点数描述的逻辑.而其它的就是非离散结构,所谓计算机是一个离散结构,说法就来源于此

[^18]: 本书第二部分第一章和第二章开头都频频涉及到大量离散概念

[^19]: 抽象使我们得得于不顾某些繁复的东西而专注另外一些更为强大的侧面,有点AOP的感觉了吧?

[^20]: 实现C语言的编译器是一种将C语言代码直接编译成本地码的工具,不存在任何逻辑中间层次或解释程序(比如虚拟机)因此运行速度很快

[^21]: C语言提供的指针等,直接与硬件内存地址啊,这些东西挂钩,符合系统软件的要求,另一方面它是类型严格的也符合系统开发要求安全性的原则

[^22]: Linux等系统软件都无一例外地是用C来实现的,一个语言跟操作系统的关系是什么??一个操作系统可以用一种语言写成,,因此如果语言历史原因地出现在前,那么这种操系统或其内部某种系统机制会用这种语言来描述,比如Windows的对象,,就是说如果Windows是用C++来实现的,那么这个对象就是CUI**对象,这根本是一种历史原因,,因为C语言在历史上一直是专用系统编程语言的标准

[^23]: 底层编程是类型编程,高层开发是往往接近一种脱离了类型考虑的scripting的动作

[^24]: 一般理论的东西学到家了,实践就会很快很平稳,而且没有误解和偏解,所以对于编程,我们注重理论的学习先行.然后才是实践第一.

[^25]: 在对术语的理解中,如果你以为自己已理解得正确,那么请坚信你目前的判断是对的,并纳入自己的知识体系,这个道理应存在,这个道理应这样才是合理的.应从这二个方面归入你的知识体系,做到自圆其说

[^26]: 任何一个术语都不会简单,有它自己产生的环境与其它知识的联系,但也正是因为这样,这也决定了它的有域性,任何知识只要放在它自己的领域内去理解才能更容易被理解

[^27]: 【出版社】 机械工业出版社【书号】 7111111117

[^28]: 语言跟你要说的话就像用C++语言去表达一个算法,方案领域跟应用领域的对应,就像穿鞋去上海, 穿上鞋只是开始,真正你要去的目标-上海还远着呢