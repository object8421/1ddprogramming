/*!

\page 脚本语言与脚本编程.html

============= 脚本语言与脚本编程

**以下转自Javaeye Hoping**

领域特定语言(DSL) 其实,大家在每天的软件开发中都在不经意的使用着这项工具.当我们在使用面向对象语言进行软件开发时,其实我们是在一种抽象的层面上进行工作.有了这层抽象,我们所编写的软件就会更有表现力,更为简洁.比如:当我们写下下面的代码行时:class Cat extends Animal.我们想表达的是Cat is a Animal,面向对象语言为我们提供了强有力的支持.而这个抽象的实现细节则由编译器来完成,我们无需关心.这样我们就能够在一个更高、更直接、更易于理解抽象的层面进行开发和交流,同时也大大降低了出现错误的机会.当我们使用支持泛型或者AOP的语言进行软件开发时,其实我们是在另外一种抽象层面上工作.比如:当我们写下如下代码时: template T Add(T, T) 我们想表达的是求两个类型为T的变量之和,而不管T到底是什么具体类型.想想看,如果语言不支持这种表达规范,我们要写多少个雷同的Add方法.有了这种表达规范,我们就可以直接、简洁地表达出我们的意图,而具体的转换工作就有编译器代劳了.还有,如果我们在支持AOP的环境中进行软件开发,那么我们只要使用该环境提供的AOP语言规范定义出我们希望的横切关系(其实就是一种抽象),剩余代码的编写和插入工作就由该环境帮我们自动完成了.虽然编译器或者开发环境在底层生成的实际上也是大量重复的代码, 但是这些代码的抽象规范却只有一份,而人们开发、维护、沟通所基于的正是这唯一的一份抽象规范,底层的重复实现细节对开发者来说是不可见的,并且是自动和抽象规范保持一致的.可以说,在开发者的头脑中,是没有重复的.从而有力的支持了“once and only once”和DRY原则.试想,如果语言种没有提供这种描述规范,那么我们要编写多少晦涩、难懂、重复的代码才能描绘我们想要表达的概念. 上面提到的抽象是一些比较通用的机制,因此一般都是语言内置支持的.也正是其通用性使其有效性范围受到了限制.一般来说,上面的一些抽象机制是仅仅针对开发者群体而言的,并且使用这些抽象机制进行的表达也是由编译器来自动生成底层执行代码的.但是,还有一种抽象表达更为重要,它的作用是在开发者和客户之间进行沟通、交流.说它重要是因为它和所要开发的系统是否能够真正满足客户需要密切相关.这种抽象表达更贴近具体的问题领域,因此也称为领域相关语言 (Domain-Specific Language(DSL)).比如,如果我们开发的是一个金融系统,那么如果我们能够使用一套金融术语及其关系来刻画金融领域中的一些业务逻辑,那么不但表达起来会简洁、直接得多,更重要的是客户也更容易理解,和客户沟通起来也更为容易.再如,如果我们要开发一个科学计算系统,那么如果我们拥有了一套描述科学计算领域的词汇,那么在表达该系统时不但会容易、自然很多,而且也更加高效.有了这套DSL之后,剩下的工作就是要自己实现一个编译/解释器,来把 DSL自动生成为目标语言.由于这个DSL一般都局限于某个特定领域,因此其编译/解释器实现起来也不会有多大困难. 敏锐的读者一定会发现,我们在前面列举的支持面向对象(OO)、泛型(GP)或者面向方面(AOP)的语言,其实也是DSL的一种.只不过它们所针对的是更为通用的,和软件要面临的实际问题领域无关的领域.它们的作用是为了提高一些通用问题描述的抽象层次,并且也为构建更贴近问题领域的抽象提供了基础. 自上而下 还是 自下而上? 写到这里我突然想起一个非常有趣的问题,那就是大家常常争论的自上而下开发和自下而上开发.一般认为,自上而下的开发方法更具目的性一些,也更为自然一些. 其实自上而下的方法是有很大风险的,一是往往很多预先的设想很可能本身就是错的,一是这些预先设想落实到底层时要么无法实现,要么无法很好地适配.其结果就是生成一个具有大量冗余、丑陋粘合层代码的系统.而采用DSL思想的自下而上方法则具有很多你可能没有想到的好处.你可以先实现一些DSL中的单个单词,然后再实现一些更大的单元,并试着把这些元素组合为更大的领域逻辑,按照这种方法实现起来的系统往往更加简洁、清楚、干净,甚至更加易于重用.一般来说,如果你想采用DSL的开发方式,动态语言大有用武之地(Python、Ruby都是不错的选择,在 www.martinfowler.com/bliki中,Martin Fowler对动态语言和DSL的关系进行了深入、有趣的描述).

自下而上的做法实际上是在改变、扩充开发语言,使其适合于所面临的问题领域.当你进行软件系统的开发时,你不仅仅只是把你所构思的程序直接映射到实现语言, 同时你还不断对语言进行增强,使其更加贴近你所构思的程序,并且表达起来能够更加简单、更加直接.比如:你会想语言中如果有了这个操作符,表达起来就更加清楚、简洁了,那么你就去构建它.这样,语言和程序就会一同演化,直到二者能够形成一种完美的匹配关系.最后,你的程序看起来就会像是用专门为它设计的语言开发的.而当语言和程序能够很好地相互适合时,所编写的代码也就会更清晰、更少、更有效.

值得注意的是,自下而上设计相对于自上而下设计来说,并不意味着用不同的顺序来编写同样的程序.当采用自下而上设计时,常常会得到一个和自上而下设计不同的程序.所得到的不会是一个单一的单片机 (monolithic)程序,而是一个具有更多抽象操作符的更“大”的语言和一个用该语言编写的更“小”的程序.此外,这个语言的抽象操作符也很容易在其他的类似的程序中得以重用,所编写程序也更加易读、更加易于理解. 还有一点值得提出,那就是自下而上的开发方法可以尽快地得到来自代码的反馈,可以及时进行重构.我们大家可能都已经知道,设计模式一般是重构的目标,这里我想特别指出的是:DSL往往也是很好的重构目标.

--结束转载—

**像C++,C这样的语言都是被设计为通用(General purpose)的,要通用,它必须一切从头做起,而不能一开始就很抽象**,否则它不能做它抽象之前发生的那些事儿,因为那不是他的任务,它在历史上能很好解决的问题是系统编程领域的，

通用型语言往往是系统编程语言因此往往基于某种靠近计算机底层的离散形式, ,其它的语言往往称为自然语言,或DSL实现特定领域事情的语言,(相对C++,C来说)不强大,不深入底层,不能控制计算机干任何通用事情,因此往往基于高层模型,,
因此,C++,C这样的语言必须要涉及到汇编原理里面的东东,**而DSL可以以任何高层的形式被体现,比如不需要编译的UML图都是,POWERPOINT代码都是DSL,根本不需要编译器这样的图灵完备装备**
抽象语言往往比不上系统语言对于计算机编程方面的功能强大[1. 这也就是脚本语言比不上编译语言这样的语言对计算机编程方面的功能强大.道理很简单,因为它太抽象了,所以在它抽象了的地方,它反而不能发挥这个层面的能力,我们将在稍后谈谈脚本语言.脚本语言是一种抽象语言.].因为抽象语言的虚拟机往往是高级机器,根本不像我们的硬件机器那么底级,图灵模型对应我们的硬件机器和架构,而虚拟机往往跟硬件架构差别过大,因此脚本语言和系统语言是为二个不同的机器设计他们干的事,,,,

通用语言,一般是严格语法的(就像我们见到的那样,C,C++,JAVA都是那样),而除了系统领域之外的应用领域,一般是特定的,灵活的，并不是通用的,所以传统的“通用语言语法加通用库”的方式并不适合于解决此类问题(因为它并不是传统语言能够并已经很好抽象了的那些领域),

特定应用领域往往要求更特定的抽象，并且，要求特定的语言元素特定的语法结构才能很好表达它，比如文本处理领域（C++处理文本时，没有专门的标准文本库，也没有语言级直接支持regex表达式这样的东西），而python显然对于这个领域的设施支持比C++方便)，

撇开c++和python的这种对比不说，我们一定要知道，对于特定领域,用传统的系统编程方法和语言来完成是不合适的，因为如果硬要这样做,那么要么要求通用语言提供新的语法,(而这是很困难的，语言的扩展并不现实。它会造成语言过于复杂多变)。要么不改变语法,而提供新的库,比如文本模式匹配问题,C++在语法级没有直接支持,它就用boost.regex来做.换言之，这些方式只是要求在通用下求特化,让它们干它们不擅长和始料未及的事，C,C++并不绝对“通用”(它们只是DSL，C是系统实现的DSL,C++是系统开发的DSL ------ 注意，我们不考虑C++的第二层)

脚本语言是相对C这一类系统编程语言来说的,, C最重要的特点就是它用数据结构加算法来解释系统底层开发的手段,,用C开发绝对离不开对系统原理和数据结构的理解,,而这些原理,包括C本身的实现,都是基于数据结构跟算法来解决问题的[2. 明白这点很重要,因为有人希望学习C语言作Web编程,这就有点南辕北辙了,而且这个认识可以端正你学C语言解决问题的方向.所以说大思想是重要的.].

而脚本语言和虚拟机语言,可以基于更高层的开发逻辑和设计方式来解决问题实现编程,比如Python,Ruby,可以运用包括 OO,DP在内的高层语言逻辑[3. 关于Python语言特点的介绍请参照有关章节.],,程序员不必涉入数据结构这些与底层和解决大家都解决过的问题直接相关的东西,仅提倡在复用层面利用这些解决过的东西能编程就可以了[4. 抽象的语言,意味着它可以少干些轮子重造方面的事情.比如脚本式开发,OO层面的复用,当然,任何事情都是不完美的,太抽象了,往往也就同时失去了C能控制底层的那些能力].

**以下转自smartcsm 的WayneZhang**
要知道什么是脚本语言,就必须知道什么是脚本程序,脚本程序简称脚本,是一种程序代码,它是由某个系统(如操作系统)或服务器(如Web Server)或应用程序(如AutoCAD, MS Office等)环境提供的能自动化操作该环境的功能的指令执行序列.而为了合法地编写出脚本程序所制定的形式语法和语义的规范,原则,定义等等总和形成了脚本语言.脚本语言实质上其实是一种用户接口.现在用户接口这个词,多指图形用户接口(GUI),即指软件的视觉和使用设计必须符合用户的习惯.但用户是有层次的,一部分是普通用户,他们通过软件提供的类似菜单选项,工具条选项,以及使用说明和简单配置等功能,来完成他们的日常工作和任务的,这种用户也被认为是最终用户.而另一部分的用户不仅使用这些一般的功能,而且希望软件随时能按照他们的意愿定制使用在菜单工具条选项中不能提供的功能,或者他们能在这个软件平台上做二次开发,将开发后的产品再出售给自己的客户或者自己内部的其他部门.为了能够满足这部分用户的需求,软件开发商就推出一种编程语言,让这部分用户通过编程的方式来使用软件内部提供的功能.这种语言就被称作脚本语言.使用它的这些用户被称为高级用户.
????脚本语言赖以生存的软件环境被称作是宿主环境(host environment).宿主环境可以是操作系统,服务器程序,应用程序,而开发这些宿主环境的程序语言(如开发操作系统一般使用c语言,开发 WebServer一般使用c或Java语言,开发应用程序一般使用C++/Java/c井语言)被称作系统开发语言,或用一个更贴切的说法是---宿主语言(Host Language).在软件产业发展初期,软件没有GUI接口,软件供应商提供一些使用该软件的API(应用程序接口),而这些接口一般采用的编程语言是宿主语言.由于宿主语言是功能强大但也复杂的语言,因此使用该软件的用户也是专业性较强的用户.但随着硬件的快速发展,软件业逐渐渗透到其他产业以及用户群体的不断扩大和GUI的出现,逼迫软件开发商必须提供一种比宿主语言功能较弱,但使用简洁,方便的语言来给一些非专业程序员用户使用.这就是脚本语言产生最根本的原因.目前世界上有数以千计的脚本语言形式.在操作系统领域,Linux上有bash, Windows上有WSH(Windows script host),而web上有perl, jsp, php, asp, VBscript, JavaScript. 在应用程序领域, AutoCAD上是AutoLisp, MS Office上有VBA. 3ds MAx上有MAXScript.各种各样的脚本语言极大地丰富了其宿主程序的功能,使宿主程序能满足不同客户的个性化需求.
????因此,目前大多数相当出名的软件都提供有脚本支持,我们国内的软件开发商是否也能考虑以这种形式来提供二次开发的接口呢?因为脚本语言的简单性能够降低二次开发的成本.如果软件是使用Java开发的,提供的二次开发语言也是Java或干脆直接提供源码进行二次开发,会极大地增加开发和维护的成本.而且当今软件行业的竞争日趋激烈,谁能快速满足不同客户的个性化需求,谁就能在竞争中占据有利位置,因此脚本语言的地位也日益突出.可以这样下一个定论,如果软件产品中不提供脚本支持,该软件产品必死无疑.
脚本语言有多种分类方法,但按照使用方式来划分,脚本语言可被分为两种,一种是独立型(或称宿主型)(stand-alone)脚本语言, 另一种被称为嵌入型(embedded)脚本语言(也称作嵌入式脚本语言).独立型脚本语言顾名思义,是指所构建的应用程序的主体程序全部或绝大部分是由脚本语言来编写的,即使用到了系统设计语言,也是非常少的(主要存在于库中),脚本语言与宿主语言的接口也只是由脚本语言调用宿主语言编写功能的单方向调用,极少反过来由宿主语言调用脚本语言功能.由于完全是用脚本语言来编写,因此就可以摆脱宿主语言的束缚,定义出符合需求的脚本类型,如脚本语言中所定义的对象的内存布局不必要与宿主语言中所定义的对象相同(比如Python对象和C++对象在内存布局方面就是不同的,两者要进行通讯必须经过一定地转换).甚至可以忽略具体的类型,设计弱类型语言.独立型脚本语言的代表有Python,Ruby,perl等.嵌入型(也称嵌入式)脚本语言是指构建的应用程序的主体结构由宿主语言(C/C++/C=============/Java)来编写(主要是为了性能和效率方面的考虑),但为了增加灵活性和二次开发性,在应用程序内部嵌入一种脚本语言来灵活地操控宿主语言编写的功能,并且宿主语言功能和脚本语言功能之间的双向调用是非常频繁的,而且也是对等的(即指双向调用的机会是相同的),由于是嵌入到宿主系统中,所以要受到宿主语言的一些约束,无论是数据类型还是内存布局,应尽量与宿主语言保持一致,如脚本语言的对象和宿主语言的对象最好能够在内存布局上保持一致,以便两种对象能非常直观快速地相互通讯,而无须进行费时而又冗长的相互转换.当然独立型与嵌入型脚本语言也并不是绝对分得非常清楚的,许多脚本语言既是独立型脚本语言又可作为嵌入型脚本语言使用.如Python和Lua.

**--结束转载—**






------------- 传统编程Or脚本编程?

**脚本语言实际上着重脚本二字,而不是语言二字**,因为脚本语言它的最主要的关注点就是为现有代码准备一个伪码系统(Opcode system used to use someth),至于你是用图灵完备的语言或是用其它设施完成,那不是为码系统必然的性质.

游戏中的scripting level更理应被称为oping,脚本扩展的基础,最直接的意思是为现有代码准备一个为码系统,如果不是采用语言,那么它还可以用其它方法完成(比如以前最初意思义上的用配置文件的游戏脚本机制,它就是一个语言)

>设计应该被配置,被Scripting,而不是被编码,设计语言应是一门非图灵完备的独立语言(要考虑到它的通用性而不是DSL就更好了). 脚本语言与程序员,与用户

>


语言宿主程序等于指令加数据(指令是被硬化到CPU中的),实际上就是指CPU加内存,内存器,因为程序运行的过程永远不在乎这三个东西,在诸如C语言这样的结构化函数语言中,深克地提现了数据结构跟算法这样的东西..因为这可是冯氏架构规定的啊, 宿主代码,脚本宿主机指的是一种什么意思呢,,因为各种语言有不同的运行时,同一种语言不同的编译器结果也有不同的运行时(编译原理有专门一章讲解运行时),因此其'指令加内存'的运行时内存分布情况是不一样的..当可欠入式脚本语言要



>微软的自动对象也可以用脚本来控制,比如Microsoft Word OLE automation objects.,,利用vbscript(VB的一个子集，vbscript是VB对应的脚本语言，它没有js强大，语法简单，但是它运行于wsh,与 windows的联系比js密切，故提供了对windows组件的很多封装)来控制,而Windows提供了对于它们的脚本虚拟机支持.

另外一种比较通俗的游戏脚本机就是读取一些txt文件,游戏程序内内置一些函数,然后遇到txt内的某个字串就中断然后执行某个函数.
脚本语言中的本地系统编程是种unnative抽象

脚本语言独立平台,提供高阶的设计手段,和大量的随语言一起分布的,作为语言标准的直面应用的库.(而系统编程语言强调事事从最基本的类型做起,因为系统语言要求通用和提供可定制性,所以不能提供太高的设计手段,和可供复用的库设施,所以系统语言本身就被设计成那种能很好重造轮子的语言)

换言之,系统语言面向系统上的应用,而脚本语言面向广泛意义上的应用(可以当然bind系统语言开发的系统逻辑),这就是脚本语言之于系统编程语言的特点所在.它们之间的区别正是由它们各自的任务决定的.要分清高级系统语言C++和脚本应用语言之间的区别.

系统语言因为拖着一个系统,其本质上并非专用的应用开发语言.而只是通用的系统开发语言.有它因为移殖和平台问题导致的一系列大问题[5. C++唯独用template,Boost等方法实现了另外一种"python".].而脚本语言并不需要对某个平台进行开发,从而需要考虑移殖和速率的问题.因为系统问题不是它的初衷和设施基础.它直接面向应用编程(系统编程,系统逻辑不由这类语言直接实现的,它只是封装并bind),由于整个地扔掉了系统这个大包袱,一切编程问题,都是脚本语言内部的事情.而且,脚本语言本身很高级,往往提供大量库(甚至DSL相关的库),这就对熟悉了编程的人来说, 显得尤为简单(复用做到了极致).

在这个意义上,脚本语言其实是一种整合系统(提供一致的类型且开发时动态的类型,黑盒化平台)与整合设计(提供OO或template这样的高高阶设计),整合问题(大量标准库的出台直面各种问题)的语言.它将一切开发上的事,做到语言中,做到库中.不提倡一步一步实现解决过了的问题.

所以,编程,应是一种很有意思的事情,在脚本编程这个层面开始体现出来.因为这里的复用程序最高(**编程几乎等于计算机应用能力**).库和语言功能足够丰富的语言,几行代码,就可以勾勒出一个程序来.而且标准库,它提倡事事规定以统一的方式来进行(标准化编程).比如py stdlib,jdk,不需要为诸多的tricks犯迷糊.

>unity3d运用c井为脚本,为什么我说Java也可以是一种脚本语言与其说Java是一种静态系统编程语言,不如说它是一种脚本语言、历史上对什么是脚本语言什么不是脚本语言没有一个定论,至少它与下面列出的几点没有个必然的联系此语言是静态类型的,还是动态类型的语言, 此语言是强类型的,还是弱类型的此语言是面向本地的,还是面向一个VM的语言此语言是编译,或者编译成中间码被VM解释的,,还是直接解释的 5,此语言是图灵完备的,还是类SQL,HTML,XML的标识码. 综合以上几点,可以发现,其实任何语言都不存在脚本不脚本的绝对说法所谓脚本,只是说此语言有没有DSL的意思,即该语言是不是专门用来开发某个领域逻辑的. 因此脚本语言也可是,图灵完备的,静态类型的,静态编译的,强类型的语言.. 1,如果是图灵不完备的,就可以是sql 2,如果是静态类型的,可以是cint,动态类型的Lua 3,如果是解释类型的,可以是underc,编译执行的cint 4,如果是带虚拟机的Lua,不带虚拟机的underc, 5,如果是半编译半解释性质的Java,纯解释的underc 这是为什么呢,因为脚本语言是相对系统编程语言来说的,,系统编程语言就是指C这一类语言,,C最重要的特点就是它用数据结构加算法来解释系统底层开发的手段,,开发C绝对离不开对系统原理的理解,,而这些原理,包括C本身,都是基于数据结构跟算法的而其它语言,可以基于更高层的开发逻辑,比如Java,可以应用包括OO在内的高层语言逻辑,,程序员不必涉入数据结构这些与底层相关的东西(当然,我们这里不是指数据结构的逻辑模型,而是指被用于OS和C语言运行时,这些开发时时克克要面对到的底层数据结构,这就是说,数据结构可以是一种思想模型,可以不一定用于底层实现,还可用于应用和高层设计,,但是,OS实现,C语言运行时实现所关系到的C语言机制,,C面向开发的可复用库,,都是基于数据结构和算法实现的,,这就是系统底层基于数据结构算法,因此系统编程语言开发系统逻辑要时时克克明白这二种大思想这个道理) 从这个意义上说,虽然Java是一种通用语言,,但其实它被主要用于WEB,也算是一种DSL了,也算是一种脚本语言..因为它主要用来进行非底层的逻辑配置式开发..是一种功能配置式语言,而不是底层实现式语言..

------------- 产品级意义

脚本语言使程序逻辑动态化,并置入一个可编辑的文本格式中。从这个意义上来讲,**脚本语言就是在产品级,使逻辑作为文档格式持久化**,而不是作为不可变的程序本身。

虚拟机编程，脚本编程与组件编程（关于它们的一些深层比较:p2p cloud和增量逻辑开发部署）：

1)可持续集成

上次说到脚本编程是持久化逻辑。这就带来了逻辑的增量集成。

可动态mount的增量动态逻辑补丁，敏捷开发的持续集成？？

增量逻辑补丁?

持续有机集成，是方法论中的，它将软件生命看成动态伸展的非一次性设计，重点是逻辑的集成和mount,于是，服务描述和接口（接口体是动态的服务容器）可以很好集成然而不是唯一方案

组件加组件描述（组件开发中，组件本身的开发只是一部分，重点在于这个组件描述形成的应用）可以很好支持持续集成，和动态集成

増量集成还需要动态集成呢，数据可以借助文件系统动态増量mount,可逻辑呢，类是源码级别的，组件和插件是二进制级别的。

可増量集成的逻辑，组件or脚本，程序从过程开始，甚至都不需要一气喝成，所以，类，它还是一种逻辑mount modify机制，从类级持续増量集成

文件系统要mount才够味。。linux做得很好。。这样可以动态发布。。增量集成。。

编程分一次性编程(引擎)和扩展(API)，，扩展编程实际上就是mount logic 2 a logic hub(作为引擎体的逻辑一般是稳定不变的那些抽象)，而将尾端抽象保持为plugin

组件为什么重要，因为它是扩展，是API，是一切！！PLUGIN是一种扩展，script是一种扩展，一次性程序基本没有，所以都要有扩展。所以组件重要。。

noengine 程序开发，才是真正的持续集成

peerlogic

面向服务之前我们一直在面向API编程。。API必定有个API集，一次性程序，就是引擎。然后其它的后来集成者都是插件。

组件服务开发和组件服务组合，，，就是no engine（面向服务编程），任何一个组件都是engine（而且要做到互不影响引用）一切联系皆发生在服务组合，即组件外。

以对一幢大厦进行持续集成吗，主体必须先建好一个monolith core.集成仅发生在插件对主体的丰满意义上

可在动态运行期组合的程序，主要拥有了noengine和logic dymic mount to a monolith kernel的特点。。而且拥有了真正的积木搭建的特点而脱离了编译运行的程序方式才能看到最终结果，这是一种从已运行的结果看结果的编程。

2)组件就是服务API

对应用编程，是组件的目标。

以应用为api

把api直接作为开发件和发行件单位。。这就是组件。。统一的开发发行API单元。

interface，，是可发行的api。。因为在部署时导出这样的API，在哪部署呢，所以组件必定需要一个运行环境管理它的套间，安全性，IPC支持等问题。。
interface运行期api，也称为服务，也或许是一个class，也或许是一个pme class(成员数据往来以class为单元单位交互)，是组件编程的基本开发交互单元。
框架本身是作为引擎使用的，但它同时也是一系列组件。。而普通的引擎就是静态的APIS，并不在运行时导出XXX。

  
从已经编译成功的东西中派生接口，而不是从源码中。。这就是组件编程。。这就将编程变成了使用程序(应用描述编程)，而不是开发程序（引擎编程）,,且在运行的东西中。。

组件描述编程将逻辑配置作为设计者的工作。不需要调试。
每一个组件透露出p,m,e信息。。
组件在动态期交互的能力到底来自于哪里，是activex 式的ipc机制还是pme的语言机制。。pme只是交互方式。。ipc才是机制平台和底层处理基础。。
组件技术的根本是OS的IPC机制。。
  x协议是一种ipc？
源码API是静态的开发体，作为运行体被载入时，一旦载入本身并不能交互（借助ACTIVEX等），而组件API，是那种载入后受OS的组件管理释放出接口的运行体。
而这种接口甚至可以是cpp class(二进制级别的)，可以在运行期控制运行期class。而不用在编译期设计好。
简言之，就是可以把API当APP用。比如wcf之于apache
直接从已经开始运行的运行体中获得开发可用的类。。并进一步控制它形成逻辑（这样就是动态组合，持续集成，而不必一次性设计好。遵守设计-运行的框架。这样就可以代替脚本----脚本最大的表征就是其动态class，动态内部类型，动态组件，仅提供了等同于脚本语言动态类单位的动态）
组件和组件管理必须要有OS的基础，语言和运行时并不能单独完成这个过程。如activex,dbus就是在win,liunx平台上的基础。com,dcom这些复杂的后来实现可以drop了，，gcf只采取activex

.net的wcf,wpf,之类之类。实际上是apache,mysql这样的极大化。。是虚拟机框架下的分布式东东。。

wsdl这样的东西被虚拟机代替了。。但实际上是很好的东西，只是它的跨语言部分要用IDL。。这就使得它很不流行最终被该死的VM取代。。

soap,实际上是将网络协议弄成跟脚本一样的东西以进行设计上的工程合成，实际上是simple object access protocl，代替纯TCPIP的http协议，实际上是组件web通讯机制。。 xml rpc消息。。。但只对web消息进行xml化，而不能对通用tcpip应用进行xml化。。是它的局限。

本地组件交互，实际上是把OS的进程管理直接当成了组件container管理。。  组件管理与通讯。。

peerappserver，，还要为这些组件设立安全区间啊。。进程沲之类的


3) peer cloud

之前的gamengitor理想还是p2pgameengine...
.net的wcf，，果然还是逻辑上的p2p啊。。

远程ＡＰＩ，不一定就是ＤＣＯＭ ＡＰＩ之类的，因为本地也存在分布。它只是将传统Ｃ／Ｓ，Ｂ／Ｓ直接隔进开发的一种层次。因此逻辑也可以Ｐ２Ｐ。

服务ＡＰＩ可以是组件层次的，因为开发就是在组件外面的描述，任何组件本身就是个appserver，也可以是虚拟机的动态class集，可以导出服务元数据的，，这样ＶＭ本身就是个appserver

服务是一种远程API，，这是分布式程序与本地程序的最本质的开发机制上的区别。。本地非分布式程序与本地分布式程序，如果仅是ＴＣＰＩＰ的分布式（如mysql,apache）就纯粹了本地非分布式程序的分布式版本的。不是基于开发的而是直接进入了发布层次的。所以不算。。

4)改进

对com的描述组合形成新应用，应划分引擎组件和描述组件的界限。并使用CPP，而不是XML描述。

变引擎开发和设计者配置为统一的范式。在组件开发中完成组件描述。

om is enough ,,no dcom,rpc,,,just com+tcpip is ok

engitor,,,story based可持续集成gamengine

*/
