/*!

\page 元语言与元编程.html

============= 元语言与元编程







------------- C++中的元[1. 元就是产生导出其它概念的概念,某种概念最初产生的地方,比如类型的类型,数据的数据为元数据,]编程


编译期解释是被发现的,而非被发明的,在一次国际会议上,有人发现编译输出的错误中居然也有运行期相似的结果,,这是模板实例化的结果(我们知道一旦编译出错,源码不可能得以运行,我们知道一旦编译出错,源码不可能得以运行,,而如果编译时就得出运行期才能得出的结果,,说明它经过运算了也即"图灵完备"了),,于是C++的这种语言机制就被“发现”了.并最终发展出Boost Mpl这样的元编程库. 我们知道C++主要是在动态运行期发挥作用的,OO如此,模板STL也如此(具备编译后端的语言皆如此,因为需要进入运行时,获得系统给的资源映射为平台逻辑,而元编程程序并不需要),理解模板元编程与模板STL前者是静态而后者是动态的区别,就像理解模板与数据结构的区别一样,根本在于得首先理解模板,再理解模板运用于这二个地方到底产生了什么不同.而这一切的一切,其实都是因为模板仅仅是一种语法机制,而后两者是模板在不同情景下的应用形式而已
**所以,所谓模板元编程,你可以理解为:它把编译器当成了更高层次的解释器和运行时而已.** 模板编程是产生式编程(比如泛型编程),而模板元编程是另一种跟产生式不同的编程范式(因为它面向受限编译期).****
lisp语言常常被作为教学语言,因为它源于严格的图灵理论,lamaba高阶函数理论,它的变体 shemhe语言采用List,即广义表作为数据结构,这种数据结构可演化成任何一种数据结构,采用函数作为语言内first class来作为主要的开发范式,,,因为这种开发方式是图灵完备的,实际上它的计算能力是等价于任何一门语言的.理论上可产生一切逻辑. C++ 中的函数并非first class,但它的元编程实现了一种metafunction,,这使得function(实际上是变形了的类模板)可以使C++在编译期实现“函数式编程”,(在这种意义上C++的模板就成了图灵完备的子语言了,实际上C++所谓的元编程主要是在模拟函数式编程)当然这种动作是深受限制的故而需要作抽象迂回的,(比如它的metafunction不像stl的仿函数是利用运行期支持的设施实现的,BOOST MPL库中的每个function独成一个文件,都需要include才能用,这主要是因为模板实现的函数并非类型,编译期并不认识函数调用及函数原型不能以函数(参数1,参数2)的形式进行调用,事实上它只认识模板以及相关机制,实际上你还可以看到编译期C++的好多奇特的语法都是源于编译期不完善的设施在看相关书籍的时候一定要处处提醒自己把握这个要点(除非改良C++标准以使编译器厂商支持编译期待性比如最新的C++09的提出), 我们下面再举一些编译期的语言设施及导致的迂回方式(某某说过,抽象是解决问题的一切方法). 编译期只识别递归(比如在递归中一个特化可以指定递归结束条件,要知道递归首先是一种思想,,它成立的本质有二,1,自身用自身来定义2,结束条件,,,如果说template&lt;类型&gt;是递归的第一层意义,那么template&lt;0&gt;这样的特化体就是递归的第二层意义使得递归得于成立) enum(变量就不能用,只能用类型和常数这样的编译期就确定下来的值比如typedef),struct(用struct而不用class是因为struct默认它的成员是public的)这样的语言设施,而且只有int,bool作为模板参数可用. 模板不能以模板为参数,,除非“类模板模板参数”,这样就不能直接产生foo(class foo1,class foo2),这样的结构,,,要绕一些弯子,比如tag dispatch function. 循环展开通常采用了复杂的迂回技术, 让模板的成员带value,模拟函数式编程的返回值. 因为元编程实际上是对产生关于类型逻辑的一种编译期策略(要知道多态化是设计的一个重要方面,编译期模板使C++变成动态语言或无类型语言,而这使C++成为跟Ruby,Python一样的高抽象设计语言),它将要做的事情要完成的逻辑提早到编译期完成而不用到运行期的资源(因为C++模板赋于它这个能力可以这样做),所以通常可以用它来进行设计,模拟设计模式等等.因为模板是语法导向的,所以它的源程序是需要按源程序文件的发行的,进行语法级的复用(模板程序只需要编译前端就逻辑成立),而面向运行期的程序是二进制导向和复用的(事实上除了C++,没有那门语言有这样的能力吧),,这就是所谓的二进制复用,因为变量,class的内存映射,,全部是运行期的编译后端的事情. 用List数据结构实现typeList.

------------- 元编程的意义


这个整合层就是策略,,,模板技术允许我们在编译期就用“策略组合”加“模板技术”来生成源程序,这实际上也是编写库为用户所用时所要考虑到的问题用户希望能从库中提取功能的子集,这势必产生这里提到一个trait的概念,简单描述一下先相比C井和JAVA,RUBY这样的语言来说,实际上即使是C++也没有直接在语言级上提供太多的抽象机制,而其它的语言,比如JAVA在语言级就有代理,RUBY在语言级就有混入.相比之下C++中只有OO和模板,(故称C++是第三代语言,而前者是第四代语言),而且C++的OO是二进制导向的,一直为后人稍稍诟病,但C++的模板技术却大受吹捧,它的抽象能力不小,首先它正用能得到generic programming,偏用能得到meta programming,而且丝毫不比第四代语言的那些抽象弱.这迎来了C++的再一次发展高峰. 模板中不需要变量这些运行期的设施,只需要 type和常量,, 它又是语法导向的(所以其复用的手段往往是提供源程序,而且其缺点是不能提供强大的运行期能力,比如Croba),而不是二进制导向的,, 因为运行期才有变量的概念,我们知道C++是个强类型的语言,因此无法做到运行期的duck typing,但模板使它具有编译期的duck typing功能,OO的那种产生类型的机制是不纯粹的,可侵入的(我们称这种语言为面向对象),而duck typing才是好的产生类型的机制(我们称Ruby,Python动态语言实现的OO为基于对象),而C++对于类型控制的能力在于它的编译期(因为它是强类型的),,而不是运行期的RTTI,实际上C++的RTTI是很弱的,它用来支持OO是需要花费运行期资源的,而作为一门静态类型语言的C++在编译期就有了关于类型的一切资讯(比如它实现多态就把这称为静态绑定),而如果将这种决策推迟到运行期(来实现运行期的OO多态),那么就必须借助于语言的 RTTI机制. meta programming是对模板的一种偏用,即trick而不是C++的一种技术,它是被发现而不是被发明的只有范型,人们发现编译期也能实现一些运算, 比如模板中也可使用if else和递归这样的语言机制,但实际上模板不是语言,无法直接识别if else和递归,实际上它只是傻傻地实例化(即使是这样也能图灵完备),但是从另一种眼光来看,因为模板机制能间接支持 if else和递归,,所以它终究是一种图灵完备的系统,即模板实际上可以看成是C++的一种子语言,另一种意义上它也是C++的embeded language).(比如它用这些tricks艰难地实现了一套编译期的stl,详见c++ meta programming那本书,而我们在用的源于HP的stl是运行期的)

最新的C++0x标准或许可以改变这种局面.C++0x标准为C++提出了一系列改革,的目的就是为能使元编程成为模板的正用..

------------- PY中的元编程


Py中的元编程,

在 py和C++中都存在元编程,只不过意义和实现手段都不尽相同,c++中,是基于“可以为运行期产生代码”的“真正的编译期图灵完备”,实现手段用了独立的template编译期实例化技术.而py中,元编程,本质就是“一般的编程”(也是对运行期进行描述),只不过它的意义是“元编程”(而其实,这种所谓的元编程也是狭义的“元”,它并不产生程序),所以,跟C++技术的元编程有很大区别.

那么python中的元编程究竟是什么意思呢?

我们知道.Python是动态类型语言,换言之,声明性语言,声明性,就表明它很泛,python虽为通用语言但其实很容易通过扩展新类型的手段发展成为某一DSL(无需改变python的语句),这种声明性其实正是python努力将自己发展成DSL的手段,DSL与通用之间,只是领域词汇的不同(语句但是其次,因为它只是代码形式,不是要写的代码内容),具体到语言,只是内置的类型及语义系统不同而已.

而一门语言,最重要的,就是它的类型系统,及这些类型系统之下的语义.(语句,并不是一门语言最重要的,因为它们是书写的形式,不是这种语言用来表达逻辑的本原,类型及关于类型的语义,才是这种语言的关键)

这就可以借助python强大的,“类型,可以动态改变”的特点,来从python级去替换它的List,str,dict,等内置类型及语义,从而形成一种新的“python2”,python standard library提供的compiler服务,正是使python成为一种mini dsl的可能提供了基础(以python compiler services为基础写新的python实现.即提供新的一套类型机制及语义,共享现有python的一套语句形式).

以上所说,即是在python级,利用python的机制进行mini luauage的创建,那么,C级可不可以呢(python在c级(在《py语言系统的c/py api扩展层次》我们谈到.Py/c才是python的整个基础,它的其它上层可以被替代))?而且,我们在提供一套新类型新语义系统的同时,能不能同时改变python的语句形式呢?


------------- 比较


xxx

*/