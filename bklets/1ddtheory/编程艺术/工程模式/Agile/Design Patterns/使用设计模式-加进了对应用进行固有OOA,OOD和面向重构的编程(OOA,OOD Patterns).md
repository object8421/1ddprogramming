/*!

\page 使用设计模式-加进了对应用进行固有OOA,OOD的编程(OOA,OOD Patterns).html

============= 使用设计模式-加进了对应用进行固有OOA,OOD的编程(OOA,OOD Patterns)


设计模式，最初是四人帮GOF总结出来的，他们合写的一本书《设计模式：面向对象的复用方案》是OO设计界的圣经之作。

>四人帮的那本书是基于C++语言的面向对象来谈设计模式的,因此它先提出一些面向对象的知识,比如一个类的class和 type(interface)的区别,提倡对接口编程而不是对class定义即实现编程,提倡对象的组合而不是继承.而且它稍后提到的诸多设计模式中, 都有对象,职责,请求,之说,这些都是OO里面的知识.. 在C++中，DP用得最重要的C++语法就是接口。

在第二章结尾的《API与复用中》我们讲到C的移殖,往往是Smoothing平台相关的代码部分(封装),就是将逻辑中,设置大量中间层,将程序主体中的中间层放到上面,，它们形成了一套KISS原则和KISS方案，在CPP的设计中，，又存在大量的，”abstract idioms“ (它们往往是隐式的作为库存在，而不是作为设计存在)
**而设计模式,是OO世界中的KISS原则和KISS方案，是显式的，作为设计抽象存在**，因此，它跟C的过程式复用kiss方案,cpp的习惯抽象法，是统一的，不过这种复用被移到了OO环境中进行讨论而已，设计模式，即是此种解决方案。然而，它又不光光是这些，我们现在细细讲来：






------------- 设计模式与OO



设计模式,是对OO者的Brain Blending,因为每次动手OO的时候,你都要怀着“我写的OO代码中哪些是将来极易改变的部分”这样的眼光,这样就可以主动地将代码中的这些部分“比如**创建行为,表示行为极易变化”(这些问题是一个object system中常出现的那些问题**),另立一类(往往是逻辑类),而这些,(为逻辑在不同情况导入了几个层面的做法),正是典型的设计模式思想的体现,

**故，dp其实是加进了对应用进行固有OOA,OOD的oo编程(所用的一些OOA,OOD Patterns)** ，

###### 设计模式与抽象

我们知道，**OO programming就是在不同的各种object system下工作**，有时，我们是扩展它，有时我们是实现自己的object system，这些都涉及到处理对象之间的关系，和对象与它们的对象系统之间的关系

设计的一种方法是提出更多的抽象，其实.不妨把设计模式称为抽象模式[1. 设计模式跟OO一样,不但解决抽象应用的问题(即设计模式中的抽象模式这一层意义),还解决抽象复用与重构的问题(设计模式这四个字在字眼上的一般意义)]更好(我们知道抽象问题领域是设计中的一个重要步骤),,因为它更多地跟着眼于解决具体事物有关(就跟数据结构一样,不是跟具体语言有关,不是属于某种代码结构.)正如数据结构是择“数据”这个维度来抽象对现实事物映射到计算机解法的做法一样,设计模式是择“模式中的各个角色和关系”来映射对现实事物的模型,从而求得一个现实问题到计算机的解法一样(就目前所提出的一些设计模式来看,他们都是抽象现实事物模型的初步组件,一般有倾向于用面向对象语言来实现的趋势比如四人帮那书).数据结构和设计模式都不会跟某种语言和语言机制有关,跟“面向对象”这样的代码抽象有本质上的差别,是实现模式,实现结构,而不是代码结构.着眼于如何解决和抽象问题,而不是如何抽象代码以进行更好能被复用这样的软工目的(当然,这二者是不分家的).

每一个设计模式中都出现了一些角色(在OO语言中用对象来表达),然而使用某个设计模式的个体(Client)不属于设计模式的某个角色,而只是使用这个设计模式的客户,,设计模式的目的就是为客户提供一个好的对现有对象的访问方法,设计模式是一种高于任何成码的思想和经验模式,因此不能直接用某个工具建模下来,在使用设计模式的过程中,,,总会产生一些新的抽象(而且有时不只一层抽象),,这些抽象隔离和解偶了客户(Client)与现有代码之间的关系,,,在它们中间作为中间抽象出现,而所谓抽象,,往往都以一个类的方式存在,(因为JAVA中一个类默认只承担一项责任或实现一个对象数据描述, 因此一个抽象往往就是一个类,当然,抽象有时以方法的形式存在,某个设计模式也会以方法的形式存在,比如工厂“方法”模式,一般来说,设计模式都会形成某几个抽象类,对应该设计模式中的几个角色Actor),,

最后，因为设计模式是一种抽象，所以也是一种迂回的方法(因为增加了抽象所以代码变得有点难于理解而且类层次增加这变得运行时变慢了一点),,然而这种方法成全了一种好处,,那就是:它部分或完全都解偶了使用者与现有代码之间(实际上设计模式可用在开发的各个阶段)的关系,,,这使得以后的对软件的维护工作和修改需求变得易管理和易实现,使软件不致于由于当初设计上的欠缺而变得难于修改而濒于死去.

------------- 将DP做进ooad体系

OO本质的问题，及它与OOP设计，语言集成之间的关系


在整理QT的源码为MPGE的过程中，我不断地发现src/design的源码量很少<100k，较src/lang的>5M有很大差别。

从源码量就可以看出，qt对所谓DP的利用率很低，因为QT在AS A OOP LIBS方面集成到语言级的方案足够丰富，metaobjectsystem可以作为DP的核心泛化出各种不同的designing supports，，

这就是说，语言的设计也是一个选择问题，是选择一个最小核心，最佳组合的问题。不光是平台所需（qt 的OO很好表达了high level native programming）的应用问题，比如，同样是OO，QT较之cpp99的OO，就可以支持更多更广的设计（上面说到src/design的源码量很少）。

>>这个所谓的”更多更广的设计“说法其实很重要，，这就是支持更多更广的后来设计，，比如design patterns based on oop,,

设想下，为了将设计集成进语言，，为OOP选择一个核心，，它该会是什么，，无非是objects tree如何在运行期构成，objects如何交互，，

针对于此，QT提出了signal slot,这不仅仅是callbacks，

callbacks是什么？？？，callbacks只是一种语言技法(对语言的修补而不是将其看作核心)，而signal slot却是语言机制内的oo system,它应被放在src/lang/oo,而不是src/lang/techs

将对象间的关系看作是语言OO体系的核心，，而不是直接用于编程的，语言外的abstract idioms-----------比如QT看待callbacks的方式，，，而它又可迎合highlevelnative programmign的重大需要，本身又可以泛化出大量的design patterns，，这样，就把语言内的OO和语言外的DP分离了。而DP也可以被作为advanced oop体系。。

这样太酷了！！

--------------------------------------------------------------------------------------------------------------

综上，OOP是现今OO语言多采用的基础支持设计的语言机制，，，真正的OOP是指语言OOP支持之外的高级OOP，如interface oop,concepts oop, 切面oop,etc..






------------- 设计模式中的设计


对于不成熟的OO程序员来说，他们往往称DP为补丁。

什么时候表现为补丁?就是老总说,某某公司要求我们开发一个软件,但是这个公司提供了一个库,要让我们现有的代码,用一种方法能使它跟这个库协同工作,,因此要利用到设计模式,,就是现有代码,,跟可复用的别人的库,,,,在这二者之间用设计模式进行连接,,,,发展出一种可运行的逻辑,, 这种情况下使用DP，就是强制使用了DP。来进行对object system的扩展。(OO中使用DP，就像C++之于C用对象封装数据结构一样《参见C与C++之争》，将程序员绑上或许他们并不需要的更高抽象的战车上)

所以有人称设计模式是OO的补丁,是因为现今来说,设计模式对于OOA,OOD来说,只是涉及了很小的一部分.在有些人的眼里（它们不经常使用DP），只发挥了一种轻微的“补丁式”的作用(而非主流且极为通用的OOA,OOD策略------相比之下，在他们眼中，那些没有使用到DP 的OOA，OOD策略，一般的OOAOOD策略才是通用的).

而非补丁式的设计模式的应用,则是在产品没有出来之前,,不需要适配既存可复用库和要写出的代码这二者,,采用的一种预先的,,大而全的设计方法,,非补丁式的设计模式,,是一种真正的设计,,,此时模式二字反而可删掉,,是一种预先想到可能想到的所有扩展能力,,决定采用什么设计模式来编码,,在这编码之前 ,,决定采用什么设计模式,或采用什么别的方法,,,这就是真正的设计,,预先的,,如果可能,尽量大而全地考虑,,,


------------- 设计模式与框架复用


**为什么要提出DP呢,因为DP很利于重载**,,因为它的结构本来就是DP,,一开始就是被良好结构的,所以后来利于重构,能根本上从设计上去改造应用,进而改造源码,这就是平常说的框架复用了.
设计模式是一种天然的可复用策略,,软件设计的终极目标就是符合软工,扩展软件的可扩展能力和生命力,,设计模式就是服务这个的,,设计模式因此有一些原则,比如LOC,控制反转原则,不重复自身原则,,这就是设计模式对于软工,所要达到的目的,

当然设计不仅是面向可复用,,还面向应用设计,,如何设计应用,,如何设计用户界面,如何分析业务逻辑以便于扩展出关于这个业务逻辑的新逻辑,,不仅是在设计如何编码了,还在于调动计算机资源的能力、思维的建模能力、分解和搭架能力,,很多人以为设计模式是补丁其实是很狭隘的东西,,其实设计模式本来就不是编码,,,只是当人们站在编码角度来理解设计模式时,,他立马就错了,,设计模式是一种流于建筑和软件界,通用的可复用策略,,是思想级的,虽然它不是不可以在代码上被表而而已 ，本文最后会详细谈到


###### 设计模式用于重构
上面说了，对于设计模式,一般有下面几种理解: 重构时的设计模式.修补式的设计模式(client角色浓重) 大设计时的设计模式.全新式的设计模式(可以没有client角色在某一套模式中) ，其中第一种情况，就是重载展开时的最佳时机和常见情况。
重构有二大因素.1,新的需求.在这个层面上,要考虑新加入的需求导致的改变,是应作为原型的设计的一部分去触动它,还是作为原型的机制实现而不用触动它2.要添加新的API接口,这是原来没想到的,重构,揭示了“软件自上次定(原)型以来,新的因素可能导致的综合上的变化(所以不一定是设计的)”

因此它最适合于被用于重载。



>这段移到设计中的原型 和重载中

原型只能是目前认为最好的原型.

重构有时并不触动设计.重构理论上可脱离需求进行,但不鼓立.可能引起软件变更的因素,为了迎合它们这就是主动和被动重构的目标所在.从程序设计的眼光来看,需求泛指“新的设计改变需求”不一定是设计的事.

------------- 总结


DP是思想级的, 一想到设计模式就想到实现,,一想到编码你就错了,只有一开始把设计模式想象成为一种思想,你才能真正理解设计和设计模式这就跟算法设计方法用来从数学上描述问题一样，

与设计模式相比,算法体现的是一种更泛化的问题解决方法的说法(或者说它更测重于说明如何实现能不能实现,而设计体现是如何设计,要设计出什么架构来表达什么逻辑达成过程),在《领域数学》节中提到的算法是数学界对于问题的Solution(VC7以上的工作空间被称为Solutiom). 设计的严格意义是广泛的,, 我们这里说的设计是指定义某种思想上的架构(软件架构往往是一种思想构架,然而必须最终在代码上体现出来,,设计模式也可称为架构模式(实际上设计模式可用在大架构或小逻辑上都可)或逻辑模式,),然后在这种架构下编码构建应用(世俗的眼光里好像编码的地位一直要次于设计^^),这不是一种泛思想的活动(虽然严格意义上的设计的确是泛义的),而是面向产生类文件的设计,但我们正对事物或问题进行设计,所以在源端是非常不确知的高构,在目标端是一定要产生类文件,
我们说,算法设计方法源于对某种特定问题的算法求解,设计模式就是面对各类问题,从设计上的解法,比如,迭代器,就是"数据结构"领域的DP,,面向这一类问题,比如从containe中分离算法,所以要用到迭代器
如果说算法设计方法是针对某一类算法可以求解的问题[2. 当然,存在算法上并不能求解的问题,这就是图灵不可解问题,比如停机问题,不要忘了,一开始我们就谈到图灵机是用来验证算法的工具.冯氏机只能执行一种串行算法,图灵理论正是整个软件问题,也就是计算模型的中心.],,,而提出的算法设计方法,,,那么设计模式,就是针对每一类现实问题在设计上,尤其是在设计的抽象过程中,所导致的通用设计方法.
DP就相于于问题模式中的数据结构和算法设计。而对DSL应用的抽象,和DP,这些都应属于用户编程,而不是全是程序员在语法层面的工作.

但具体一种设计模式不是不可以用代码来表现(编程即换维重现,即将思想级的东西转变为语言级的东西),, 这就跟算法一样，也可以用代码来表现

MVC是一种表达窗口的现实问题模式,此时用mvc复用设计模式就最好表达了.而mvc被policy based design实现了,所以它首先也是一种代码模式了.

>比如MVC,工厂方法,工厂,单件等,,MVC可以说是一种框架,,也可以说是一种设计模式,,因为MVC是设计模式的组合,,它被作为一种框架时,比如 strcut,spring,也是成立的,,可以说现在的一些WEB开发框架比如STRUCT,SPRING,ROR都是设计模式的实作品,而设计模式是一种思想,,设计模式这种思想,这种设计目标和设计手段,,被体现在代码上,,就是用了设计模式的软件,,或用了设计模式的可复用框架,

然而对于程序员来说不利的是,数据结构已经被很好地映射到C语言中,而设计模式几乎在C语言中找不到它的影子.这正是它不成熟的地方.也许有一天会有一套“设计模式”专用语言出现.或者将它集成在语言中，



>DP会帮助OO成为软件银弹吗？


就像设计模式，设计模式会带来新的抽象问题,有时甚至一种模式必须要出现一种反模式来应对,,可是,我们往往只取设计模式暂时能解决当前问题的那一面.相对于当时的某种情境来说的足够通用的方案。

我在《OO为什么不是银弹-过度抽象的利与弊》中谈到,OO并不是银弹,银弹是那些能统一人类思想,形成契约文化,经验的东西(比如我们写小说的那些套路),而不是简单的class这种面向复用的小技俩. 设计模式正是上述所谓“契约文化,经验”之类的初步体现(不可否认,我们所看到的设计模式跟具体现实事物还是有很大距离的),等到有一天,所有的问题都用设计模式来抽象的时候,成千上万的设计模式会被提出来.人们会倾向于用大大小小的设计模式来解决问题.那么设计模式就会到达它的颠峰.

*/