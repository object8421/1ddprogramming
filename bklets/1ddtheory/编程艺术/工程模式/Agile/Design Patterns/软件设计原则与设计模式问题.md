/*!

\page 软件设计原则与设计模式问题.html

============= 软件设计原则与设计模式问题


设计首先是一些原则，就像C和系统编程一样存在着kiss原则和解决方案一样，设计模式首先是一些思想级的原则。它是设计上的文化。

其实在UNIX的C编程中,也出现过KISS这样的原则.姑且把它们称为“C的设计模式”,可以看出,它们往往是极度隐藏的,而C++这样的语言,有显式的接口机制,可以表现更多的“设计模式”

>在抽象的顶端加入人的东西（设计上的策略），，低端加入问题和机器的东西（实现上的算法，机制），，用策略来控制机制---最初的框架，c中的，是为了能动态换算法，换言之，能为多个同类的算法提供容纳并切换。

 设计模式其实还有一个兄弟，，就是框架模式，，，当设计模式被用于程序抽象时，它是设计模式，我们常说的那套，也可叫抽象模式，，当它被用于构建产品级的架构时，，其实是框架模式，，也就是应用模式。。。


>注意.目前提出的一系列设计模式虽然有分类方法(创建型,动作型,算法型等等),但模式本身是不分巨细的.因为事物本身并没有一个巨细之分.实际上模式跟模式之间,一个可以是解决大量问题的,而另外一个可能是专门解决某一类小问题的.

单一职责这个字眼是相当模糊的, 单一职责,要求你懂得,在某个具体问题具体分析的情况下,哪些抽象所代表的职责是应归为一类的,然后才能抽象为单一的职责,所以一句“单一职责”,对你来说可能是空话,





------------- 设计原则之业务与逻辑分开



业务就是你做软工的设计阶段时,所要明确的"逻辑本身",界面就是"表现此逻辑的应用形式"(面向用户的一端),也即逻辑是"我们要搞清的问题"(面向低层的一端),要解决和面向的问题领域,这个所谓的"问题"是严格的,它决定了我们在编码要体现什么样什么维度上的功能.因此在设计中,"搞清你要实现的问题"永远是重要的 另外一个概念是数据,数据处理逻辑要做成独立于界面和逻辑的,此时要提出一个架构,进行新旧系统的分合与整离,让应用统一于某种低层逻辑或界面形式,或由这种架构创建新的应用.

>谈到分合,我突然想起,有一些库,总是把其它库的事情给做了,这反而是一种策略上的失效,比如SQL,QTSQL提供了对SQL语言的抽象,但其实它超越了数据库的界限,把语义编程(用SQL进行对数据库的应用)做了进来,数据库本来是解决程序模型的那些问题,它解决“人们不必像系统编程那样,处处定义一个内存池”来进行对“程序向OS讨要内存”的封装.并将它维持在编程层面(当然,对于一个完善的DB系统来说,它还应提供管理器面向用户,这就是它超出编程的现象),而不应,把它长足发展为SQL(这样的话,就超出了编程的界限)

------------- 开闭原则



我们应该对扩展开放,的同时(注意这三个字必不可少),,,保证对修改的关闭(一个工程,应该在设计时就要考虑到将来修改的需要,而且要保证未来修改时能尽量降低工作量,对于一个真正的工程级的规模,人力管理工程应该尽量简化), 几乎没有接确过设计模式的人[1. 除了完全外行和真正的编程高手外,绝对的天才和绝对的白痴之外]看到这句话都会感到疑惑,而且会产生一个很普遍的疑问:不修改何来扩展?
>这里的安全是指对修改关闭，什么意思呢？在一个架构中，基础部分是不需要被扩展的，比如不需要提供脚本封装或接口机制，甚至，如果有必要，可以使用语言语法技巧使之“不可修改”（如一旦修改就会导致编译错误）
高手与低手(我没说新手因为我觉得低手这词好用)的差别就在于这里,高手往往看重的思想,首先从思想和设计层面去想问题,因为任何问题都首先是设计问题,其次才是代码实现问题(即设计能力,,,识别架构和建立构架的能力),而低手考虑问题的第一切入点就是源码本身,因此产生“不修改源码何来功能扩展”的疑问也就很自然了
而其实,在高手的眼里,只要定义一些抽象,产生一些迂回就可以解决问题了,这些迂回(实际上就是产生一些高层逻辑,或者说设计模式,这些逻辑就是具体某个设计模式中的某些角色Actor)可以让我们clients通过这些高层迂回避免直接接确到低层的实现(虽然我们client无论如何最终是要进入到具体实现的,但我们可以不直接而间接迂回地进入啊！！这些低层的实现就是现有代码了,是实现部分(可能是某个你要使用到的第三方库代码),我们经常要对实现部分修改,或者说对现有代码的修改,而要求要有最少的工作量,而一个没有定义抽象或者没有定义好合理抽象的工程要涉及到很多修改工作),而这,,真真实实就是解偶的意义所在..

我们再来说这些逻辑,其实这些逻辑都可以称为中间逻辑,,然而这些逻辑的地位又是不同的,,有与具体实现接近的那一端的逻辑,,这些逻辑也是高层逻辑,,但是把与接近client使用者的逻辑看作为相对更高层的逻辑..

具体什么是所谓的抽象和迂回呢?说个故事吧！ 《西游记》大闹天空时,要求当天庭大官,太白金星向玉皇献记说让孙悟空当弼马温,太白金星的智慧就体现了开闭原则,一方面,在孙悟空方面,太白向孙悟空说明玉皇已同意他上天(对扩展开放),,另一方面实际上只是给了他一个放马的差,实际上按天庭规则(系统原有结构)孙悟空是不能上天的(),然而迫于孙悟空的力量(修改的需要),太白只是稍微迂回了弯子(增加了一层抽象),就暂时平息了玉皇(玉皇本人不知道如何扩展这个需求,因为这是与天规相背的)和孙悟空二边.

------------- 迪米特原则


之所以不称通米特原则为通米特法则是因为在设计模式领域内实在不存在一个法则之说,通米特法则也称为最小知识原则,一个事物对另外一个事物知道得越少,那么它本身就越安全(这可以联系武侠小说里小人物碰巧目睹了对杀手杀人的整个过程,那么这个小人物就会有杀身之祸,),

这里的安全是指对修改关闭

实际上无论对象组合还是继承都会造成类与类之间的引用,都会造成不可复用的问题,然而,相比继承来说,组合可以极大地减少这种复用的偶合程序,而继承压根就是不可分离的,因为本质上组合是一种Has-A的关系(组合对象与被组合对象),而继承关系是一种Is-A的关系(基类与继承类,或称父类与子类,注意这二个概念还是有点区别的,一般说到父与子关系时就是指父对象与子对象,而说到基类与继承类时往往描述类与类之间关系的用词~~)

还有一种关系是Link-A的关系,这种情况下的不可复用性按情况下来定,,Is-A的准确意思是什么呢(这里的意思指语义)?如B is a A,,那么“B是一个A”,,可能是一个A,但是不一定必定是一个A.而且如果B是一个A,,那么反过来就不能成立(子类化,虽然站在类型转换的场合下可以但是现实生活中这样理解不通)

一个代码的修改量应只取决于它最低层的实现,如果某个低层引用了过多高层逻辑接口的实现,那么这只能说明,对这个实现的解偶还没有规划到家,理想的情况是,应该只让这个实现的修改不触动到任何间接使用它的高层逻辑！！(因为自顶向下的引用对于顶来说,如果底部被修改顶部是不用作任何改变的,而如果是自底向顶引用,那么当底发生改变时,一定要涉及到顶部也要改变,,而这就是不恰当的高层抽象,违背了好莱坞原则和通米特原则)

------------- 好莱钨原则


好莱坞原则(不要给我打电话,我会打电话给你们)强调高层对低层的主动作用,即低层应该只管好自己的工作(具体实现),而高层自有它自己的工作(这就是管理低层的逻辑们,或者说从client到具体实现的一系列中间逻辑),在不需要到某个低层的时候,高层并不会调用到这个具体低层,低层永远不需要向高层作出表示,,说它需要被调用,,(即在所有的处于使用者与现有代码的中间的,用于隔离和解偶二者的,那些中间逻辑中,低层逻辑永远不要涉入高层的实现,而只要高层通过某个逻辑去涉入低层的实现,也即低层应不要调用高层,只有高层才会去调用低层,这才是合理的,我们应尽量避免向上调用和相互调用).

------------- 策略模式


Open和close一点也不矛盾,当它用在同一个架构上,open指出这个架构的可扩展性,而close指出这个构架的内敛性,open是相对高层来说的,,而colse是相对内部实现来说的,,,一个构架应对高层open,而对内部实现close,,,

策略模式将可变的行为集封装起来,这符合OO封装“可变部分”的原则,可变部分就是实现,我们修改一个软件直接修改的就是实现,而非抽象(实际上也不应该也没有必要对抽象进行修改,如果你的工程存在对抽象的修改,那就只能说明,当初在定义抽象的时候压根定义的抽象就是不合理的抽象,真正合理的抽象将使用者客户和现有代码极大地解偶,这使得以后的修改工作只需在低端实现进行而无须触动高端).

------------- 观察者模式


好莱坞原则指出,类之间应尽量避免低层(实现)向高层(抽象,逻辑)的引用, 观察者模式中,观察者,被观察者,一个被观察者管理诸多对象(观察者),这些观察者通过

------------- 装饰模式


装饰模式就像是一个用类来修饰类的机制(这就添加了新的职责到被修饰的类,,这里说的修饰本质是什么呢?就是类的组合,让一个类被修饰者成为修饰者的一个实例变量),,,这要求修饰类(可能是多个)和被修饰的类有一致的接口(也即它们同共都曾实现implent了某个接口,或者继承了某个有接口作用的抽象类extend,,这样一来,就可以在动态运行时用一方代替另一方,然而客户并不会知晓其发生过内部的替换)

装饰模式可以让很多具有对等地位而且拥有共同接口的类进行有穷互饰,这样可叠合多个类进行某个共同的接口作用,并获得最终的修饰过的这个成员作用 .

------------- 单例模式


某些只能够拥有一个实例的类对象必须通过某些方法来保证它在程序运行期只有一个单例,而且,更重要的,,必须提供一个全局域访问入口,这个入口必须是类层的,, 单件模式在普通的由类创建实例的路径中,创造一个约束抽象,使类不能无限地创建它所属的对象,,只能创建一个 通过这个全局域访问点,你可以直接调用类的某个机

因为它的产生实例的构造函数是私有的,只能从类的内部去产生和获取这个实例,换言之,你不可以通过继承或组合的方法去获得一个实例,而且这个方法往往被定义为fina,,也就是C++语言中的CONST,即子类不能覆盖它,

因此,可以用类方法(也即静态方法),这种方法下,从继承

------------- 迭代器模式


如果你知道什么叫递归和递推,那么迭代器本身这个概念你是很容易理解的,迭代器跟集合(集合就是通俗意义上的对象集合,虽然存在很多不同质的集合,比如用数据结构表达的对象集,或者用函数索引的hash集,但是只要是集合,它的内在总有一些对象及对象逻辑,对象逻辑就是操作这些对象的根据,比如遍历算法,而至于本象本身,可以是无意义的对象,或者同性质的内存节点,或者离散的东东,然而上面说了,这些集合内部必有一种方法作为逻辑可用来遍历他们各自内部的对象,)的关系就是:无论是什么集合,它都可以把一种抽象抽象归纳出来,就是遍历它们各自内部对象的算法 所以,对抽象的提取,往往是找相同的部分,把这些相同的部分提到高层,而用这处抽象来封装可变的部分(这里指各个集合内置的不同的遍历算法),这样就形成了一个所有集合能共享的遍历接口(当然这个接口并不为集合所用,集合自有它们自己的遍历算法,而是为client所用,不同的client都能面向和共享一个共同的,使者这些集合来进行遍历集合的算法,而不必管这些集合自身具体是如何遍历它们自身的元素的)

------------- 工厂模式


工厂模式用来实例化对象,,,可被形象理解为一个封装了专门用来产生对象的某种逻辑(这种逻辑可以是一个方法的形式存在-这就是工厂方法模式,也可以是一个类的形式存在-这就是简单工厂模式),因为大凡产生对象的过程都是低层的(调用New方法实际创建实例对象,属于实现),它压根就不应该跟高层(这里的高层指的是需要引用那些实例或间接引用到那些实例的抽象或更高层抽象,由于一个类只能负责一种责任,一个抽象只能被作为一个类,因此当有多个抽象存在时,有必要将它们按职责分成不同的抽象层次,形成不同的层次类放在一起.

这个道理就像:我们生产出一系列的东西(我们当然可以把这个产生过程直接放置到某个未来应用中-这个未来应用要使用到产生过程中产生的对象,这样一来所谓的“某个具体未来应用”就会跟产生对象过程直接挂钩,因此我们把产生对象的过程独立出来,归纳它为专门的产生对象实例的过程,而应用这些对象的一些应用--虽然不知道未来会有多少应用会存在,而这个“不知道”的说法,本身就反应了它符合未来的扩展性--放置到另外一层去),然而会有其它一系列

------------- 真正的门面模式


门面模式也称为外观模式,它提供一个易使用的接口作为它的外观,只是为了使现有代码client和要使用到的对象集(往往是多个具有不同行为不同接口的对象)通过这个接口(制造出的目标接口)能被更简单地使用而已,也即打包某些对象行为(并透露出一个基于高层应用逻辑上的接口),常跟适配器模式放在一起被讨论,因为它们都是为了提供接口而存在的,,适配器模式是转换接口为了“能够被使用”,而门面模式是简化接口为了“更好地被使用”(让被适配对象被client被使用,通过一个目标接口-注意这后半部分的说法才最最重要的)

------------- 真正的命令模式


将命令本身封装起来作为一个对象,让它的调用者(注意这个调用者不是客户Client,Client是模式之外的使用者,而是命令模式中的一员Actor,是这个命令模式抽象层中的一层)和命令对象通过对象组合的方法

------------- 真正的模板方法模式


模板方法用一套模式作为定义方法和行为的大致框架(注意是大致,而不是全部,这个机制就允许挂钩,和一些需要它的继承子类实现的抽象方法),这跟策略有一点相似之处,因为他们都封装了作为可变部分的行为,然而它们之间还是有差别的,

然而,模板方法使用继承模式,而不对象组合模式,模板方法因为是一个抽象方法,因此如果有子类继承它,那么这个子类必须要实现这个抽象方法
模板方法抽象了复杂系统中的逻辑,调用流转,,那么工厂模式就抽象了复杂系统中的对象产生策略,而非调用上的考虑

为实现制造一个前端代理,,就是proxy设计模式

模板方法一般在复杂的对象系统中存在,比如一个应用程序的框架,,因为模板方法的可以通过一系列策略,产生和调用对象系统中的方法,使它们有机地传动,流转,所以是某种意思上的,"系统cover dive制动装置

------------- 真正的适配器模式


Adapter,不是接口的意思,它更准确的意义应该是适配,真正的“接口”在不同的应用场景下有不同的意义,现例举如下: 1,Java的一种机制,这种interface语法是一套抽象机制,如果实现 2,接口类,这些接口类往往是抽象类, 3,二进制复用的接口,比如COM,也就是构件接口 4,接口方法,某个class非private的方法(无论是抽象的还是带有实现的都可以称得上是一个接口,一般是指抽象的成员方法)API都可以是一种接口 5,逻辑模型,通俗意义上的“抽取归纳”某个接口,或者说是高层入口,通过这个高层入口,所有的 以上只是为了不跟OO中的接口相混淆,所以强行把适配器模式说成是适配,,其实适配就是适配二个拥有不同接口对象的接口对象(也即这个产生的目标对象“接口对象”也是一个接口,

*/