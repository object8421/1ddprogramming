/*!

\page 使用企业开发的方式 : 利用中间件技术和分布式技术淡化非业务逻辑.html

============= 使用企业开发的方式 : 利用中间件技术和分布式技术淡化非业务逻辑

像webserver中的lamp中的amp，就建立起了一套appmodel





企业开发,是一个开发的流派与大类,然而,它本身,也是使编程脱离平台的设计中的独立一支. 这一章将在后面章节讲解

对于开发来说,企业开发与其它开发有很多不一样,因为它是高度面向中间件的,所以它的开发全是业务逻辑.而且,框架中运用大量的模式思想.所以,抽象程序越高,它的复用程序也会越高.

对于应用来说,企业开发与其它开发面向的应用有很多不一样.主要是面向分布式[1. idl是分布式的dsl],然而就重要性来说,代表企业开发的,还是框架和面向服务等这样的东西.分布式只是企业开发附带的一个属性.不是主要的.

企业开发有着它自己的狭隘性.因为它的程序必须是分布式的,而这决定了它是颇为有限的那类问题,但是,企业开发其实跟它上流或下流的程序开发流派有着共同的交集,比如桌面开发,也可以利用框架思想,建立可复用的库.比如ACE；这跟企业开发的框架和中间件思想是一样的(虽然它没用到分布).


------------- 组件与分布式的关系

appserver实际上是generic appcontainer(based on uniform lpc,rpc compentsystem)，比如，这种appserver还可以是sceneviewer,它与viewer(实际上是app updater,content viewer)一起，取代了跨本地，远程 的c/s框架(local,romote uniform generic distrubtor appmodel)。

跨越tcpip的rpc是非常不对的,,,所以minqw 的unifrom lpcrpc,,仅仅是lpc,,,web仅是发布平台,,并不包括开发,管理全支持,,对于发布,,它只保持在"使本地组件呈现分布式的部署"效果
分布式应用，，可以很多解决办法，，大到架到，小到应用，，LDAP这样的东西都是

网络交互,协议往来,不应被内欠在组件的框架中,,成为rpc,,,而要用minqw的connector/reactor serverframework(实际上也是clientframewrok)来居于组件之上,,这样就还是native dev的框架下,,,,而不致于出现一个"基于组件的分布式",,这必须波及到根桩,二进制接口,甚至服务消息封装,资源定位等WEb效果非常SB
gcf的lpc做得很好,,可是它的applicatserver,,,rpc部分就走了传统web的俗套了



引擎小件，组件，widgets，无架构未端，用户逻辑
codeness but not only codeless,tag and description language


一门语言的组件机制，，只应是动态载入的可执行单元（比如用于web的修改即载入是受语言直接支持的，所以web的语言，，一般都是虚拟机语言），比如支持在运行期动态载入.class文件的jvm，而fear,activex,,gcf based on activex,,这样的手动assamely所谓的动态组建，，，也是组件吗？？
况且ativex所代表的组件意义，，，和gcf这样的也好像不同，，，activex直面二进制接口所代表的组件，，，语言的组件机制是类级的语言虚拟机和运行时直接支持的，，而gcf解决的是组件的开发，，和动态assembly，为组件开发提代一个框架，，这三者也不甚相同，，所以说？？？
进程间的分布，ipc，or 组件间的分布,icc
active x 是组件a p i ,g c f 是组件框架库
组件应成为可执行逻辑的唯一单位？
这样才更uni form
d l l s 是动态载入的，但是却是在静态指定的
组件开发(组合)的框架却用脚本来解决？组件本身用q t c p p ?
binding runtime is just like cfront transloter
组件应是提供服务，然后别的客户组件能够根据内省，发现该服务组件的服务，而非仅仅被动地被链接
进程不一定是组件（由二进制契约组成的可装载可发行单位），q t 支持任何源码级类族抽象团间的i p c
基于组件的跨internet分布，，，不好，应是ipc的组件分布在先，，然后用tcpip居于其中作分布
使用根桩（其实就是二进制interface）是activex,kpart的固有特点，，所以也是gcf的特点，，，微软的atl是什么东西
gcf的唯一特点，，和作用，，就是可配置的运行时单元？guixml够强大吗
它实际最主要的组件形式不是activexqt或kpart,,而是自己怕那套组件


------------- 利用DCOM谈化通讯逻辑


这样的机制,对于网络程序的开发者来说,他们得建立一个服务端和一个客户端.在确保二机存在一个正确连接后,程序才能用http通讯.程序员(比如它开发一个web服务器)需要在源程序中处理http逻辑(request,response模型).

然而,其实对于网络程序的开发,这样的工作其实显然是走了一个大弯.因为程序员,得处理通讯(http),然后才能处理关于进程的通用事宜(web server对于broswer创建一个进程或线程).第二个工作,是每个网络程序必须涉及到的,甚至是每个程序必须涉及的.不可避免,然而,第一个工作呢?其实可以谈化掉.

即,我们可以将网络逻辑隐藏在进程背后,使网络程序的开发,弄得跟本地程序一样,只需处理正常的程序本身的逻辑,程序员只需调用内置在一个dll,exe进程中的过程(即使它是一个网络程序).

这样的手段,就是RPC(它是二进制层面的解决方法,需要用到根,桩这样的东西,因此需要IDL语言,它可以映射为C++)
>旧时的各种协议都是直接调用或基于tcp或udp的，然而这些协议都有明显的request/response特点，可以利用rpc重新实现，利用rpc重新实现的各种应用层协议(尤其是利用oo的rpc)，如soap这个object web协议，它就有别于原始的http协议(原始的http也有类rpc的request responce结构)，其它的协议也可以跟soap一样被做成rpc based internet app level协议
一个正常的dll,跟一个网络程序的dll(假设它使用了rpc),是不一样的,后者中,在被执行形成一个进程后.其实在dll体内,就有了网络逻辑 – 在dll体内经过了网络配置(因为它是一个网络程序).这样才能被访问.其内的例程,是另一机器的进程里的例程.

Soap,xmlrpc,就是把tcp+http一起,弄成一个如上这样的dll的手段.与这样的dll形成的进程合作,其它进程只需直接调用其函数.(http://这样的位置信息不用去管,因为dll体内已经完成了这个工作),你看,(对这个http联网程序[2. 这是指http程序,不是指web程序,而是指http网络程序.]的开发变成了不关乎处理任何联网逻辑的工作)这跟普通的lpc调用没有区别.计算机间以进程交流为主,不是通讯及网络传送(它们在进程的后面,对于开发者不可见,看到一个http://,其实只是形式,还可以是ftp://...some.dll?some过程,其实,他们对于开发者来说,都是没有意义的,因为它们根本不是apache webserver的显式的http://,而是rpcserver的隐含的http://)

Rpcserver就是一个普通的进程.我们说rpc server,是说rpc 程序,如果有另外一个rpc程序与之通讯,这个rpc 进程,就是rpc server. 其实,一个rpc server,比如一个web程序,xmlrpc,soap,可以去掉tcp+http中的http,使得xmlrpc是真正的xmlrpc(而非名为xmlrpcserver,实为xmlhttprpcserver这样的东西),即我们要去除rpcserver网络程序的协议部分,只保留连接部分.

这样,对于一个网络程序,其实可以从根本上改变tcp/ip协议模型了,因为一个rpc server的东西,在开发上是lpc,就像本地进程间不必处理http一样,只需保证rpc server与rpc client进程通过tcp连接就可以了(只是这样,对于“变成lpc”,它就显得足够充分了.).于是我们可以把tcp/ip协议族,整个地去掉http,ftp这样的东西,因为它们不再被需要了.(其实当时提出一个tcp/ip协议族规范,不是为了如此这样般地被应用,比如http,而只是历史原因 – 需要在厂商间制定标准.)

一句话,rpc使得http无用.本地程序间,只要保证相连证明它们可以通讯,不必提供一个http保证它们之间怎么样通讯.因为rpc已经包含了这样的机制(根,桩),**基于rpc的联网程序的开发,不再需要深入http和socket底层** 这就是说,因为通过rpc本身进行通讯,不是通过端口,网络程序(http rpc server)本身不必处理http交互,只要连接就可以,交互由rpc提供的进程机制来完成(替代http及所有其它应用级的协议为根,桩).

*/