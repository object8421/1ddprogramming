low level system programming
=============

当高级语言提供了映射手段,数据结构和算法有能力将解决问题的方法接上软件后。这二种手段立刻被用来实现系统。形成了实现编程。

软件系统作为对由cpu组成的pc硬件存储（数据指令地址）处理（存取数据指令即io。运算。）系统的再发挥。自然首先是利用数据结构与算法对cpu的这两大功能转为软件抽象。这导致了os的任务系统.

当系统实现完成之后,基于实现之上的系统应用编程也会发展起来了.

如果你是从本书开头看到这里的,那么实际上,现在的你已经离编程实践非常近了. 为什么编程要讲解平台呢，

我们在前面讲到,任何语言都是有门槛的,但经过前面一到四章的学习,我已经把实践的门槛降到足够低了(因为这是系统编程，前面我们讲解了系统与语言，那么这里将二者结合起来的时候了，即系统编程),从本章开始,我们将正式进入编程实践.从这里开始,你可以分析一般的中型程序了.因为系统,语言,数据结构,方面的东西已被前几章被初步解决了.
如果说在前三章里我力求向你们提出一个思想体系,那么在这本书的这部分我将要讲述的就是代码控制和实践能力了(从这章开始,所有的讲解都会带有代码,这是跟其它部分不同的,这是程序设计的基础二部曲.这本书完成之后,你应该具备基础的编码实践能力(用C来进行实现式的系统编程).
编程是体力活,从最微小的代码写起,一个看不起小代码,和不注重从微小到巨量积累过程的人,他的实践编程水平一定不怎么样.每一篇代码后都有作业.有的是练习型,有的是创新型的.
当然,在本章的书写中,对于系统编程,有一些方面我没讲,比如&lt;虚拟现实之3D,数值计算,等等&gt;





何谓用户程序
-------------

用户程序跟内核程序相对,其实在内核中,最重要的程序是C例程(它们的模型是api和abi),和那些内核内置的守护线程(它们是C/S中的S,是一个CUI程序或干脆没有一个界面),这就是内核程序的模型.而用户程序建立在内核上,直接利用内核的某些关于程序模型的东西(比如malloc这些程序向系统讨要内存的逻辑,还比如IO和文件),二者并非毫无联系,虽然如此,但其实用户程序跟内核程序还是有着根本上的区别的,比如,内核程序面向机器,所以不需要在视觉上有特别的要求(虽然它跟用户程序在讨要内存等方面存在程序模型上的共同点,即内核程序模型,有一部分是用户程序模型的基础),但用户程序面向用户,比如在现代OS上,通常都是图形展示的GUI.

>当然,GUI只是用户程序模型的一个方面,我们前面讲到QT库时,曾讲过qtapplication=network+DB+gui+io,这些,是一个用户程序的关于系统的其它模型.系统模型问题其实是操作系统问题.因为操作系统都对它们有实现.比如程序讨要内存,在内核程序和用户程序上都是posix模型,比如GUI在windows上是gdi,在类unix上是x11,但QT作为一个用户库,它为什么也要提供操作系统已解决了的关于程序模型的那些逻辑呢? (其实QT跟wxwidget这样的并没有“解决”GUI问题,只是抽象了对GUI问题的解决途径,QT和wxwidget依然是平台相关的,它们的低层不是x11就是gdi), QT,wxwidgets这样的库只是起了一个封装的作用(它们只是一个库和一个用户组件,并不是系统的组件),在它们本身体内,并没有独立实现GUI的能力(framebuffer,3d)这样的东西,终来自于平台.

除了解决程序模型问题,(软件)系统开发,往往还指基于系统开发之上的系统应用开发.

其实,用户程序,都建立在内核提供的系统调用上(linux有300来个syscalls,windows有上千个syscalls),和操作系统各个层次的OS API上(在posix以下的API是用户程序看不到的,对于用户程序,OS仅从提供syscalls开始[1. 系统调用,只能是用户级的,工作在第三层,而在内核中,所有的例程,都将工作在0级,开发上没有可用的东西.]),所以,一般很容易将“系统实现”与用户程序的开发分开,因为它们之间的分界线就是系统调用,然而,在用户程序的开发中,很难分清“系统开发”和“系统应用开发”,因为它们其实,都是相通的(系统开发,往往本身就是一种对系统的应用,所以也属于系统应用开发,一般把“系统开发”等同于“解决处理程序模型的系统应用开发”,它已经十分接近“系统应用开发”了,当然,建立在已解决程序模型之上的系统编程就更接近系统应用开发了[2. (软件)系统开发,它其实指一个很狭隘但又很广泛的体系,即,驱动程序,系统实现(这二者是系统开发中的系统实现),和系统开发(即建立在前二者基础上的,跟系统逻辑有关的高阶开发),应用开发(它建立在前三者基础上,它已经极大程度地跟系统逻辑没有关系了)]).在类unix操作系统中,它们的开发,历史上都是固定的,系统开发和系统应用开发有着很不明显的分区(类unix系统只提供基本的OS内核API,对于用户程序员来说,他们只看到一个一个的发行版[3. Unix内核本身并不是一个完整的产品和产品线,跟windows不一样.本书这部分,是以windows为例展开的,为什么不写linux呢?因为linux虽然是一个完备的现代意义上的OS,但是它的产品线是分开的,比如内核是统一的,但桌面环境,数据库接口这些东西,都是厂商各自为政的,故我们选择windows,要正确看待windows的好处,不要总是带偏见看它,其实linux开源界的产品,全是不太完备的.为了实务与功用起见,windows永远是一个好的开发平台)] – 这些发行版的主体是各种应用,内核还是原来那个内核,故类unix指内核不是指通俗意义上的操作系统,它强调的是内核而不是应用,强调的是向各种发行版提供机制而不是直接的策略,历史上类unix系统的各种应用并非unxi本身的一部分,对于内核以上的应用部分,它基本没有什么规范和标准API(故不是unix操作系统的一部分),它没有类ODBC这样的统一的数据库drvier规范,只有统一的X11,就连桌面环境库都不是操作系统标准,而是用户标准),而有的操作系统,比如windows,整合了很多“系统开发”到“系统应用开发”中(它有大量策略上的OS API,这些策略是操作系统的一部分,当然,在windows上,也存在大量存在于windows内核之外 – 但并不独立于内核实现的第三方解决方案.),因此我们得手工制定一些区分点.比如我提到的“程序模型”,系统应用,与脱离了系统应用的一般应用.这三个层次,根据java sdk的说法,前者是“桌面程序[4. 桌面程序,即建立在图形环境下的开发,GUI是程序的必选模型,即win32 GUI程序.其实,桌面程序还是“系统程序”的代名词,它表示的不仅是系统上面图形GUI的开发,而且,还是整个的系统开发.]”,后者是“企业程序”,于是,我们说,桌面程序的模型有: 对于GUI,在类unix上是x11,在windows上是GDI,当然还存在第三方的方案,比如SDL 对于数据库,在类unix上未知,在windows上是ODBC,在JVM是JDBC 对于网络,大家都是TCP/IP 以上三者,是“桌面程序”模型的主要方面.其它小的方面有: 对于讨要内存,在内核已有实现基础.用户程序跟内核程序是相承的. 对于处理IO,讨要文件资源,如上 其它...

如何对系统开发分类呢?要根据它们的抽象层次来进行. 各大小系统问题层次不一样,有的是随着C和系统实现而来的系统开发,于是“系统实现(驱动程序和系统内核)”加“初级系统开发(IO,获取内存,并发)”是二个层面.,即从C带来的系统开发, 基于系统内核以上的系统开发,一般用C++开发(C++所涉及到的开发,绝大多数是系统相关开发,而非系统无关的应用开发),网络,ＤＢ,可以不是一个程序的模型,相比之下,ＧＵＩ界面是一个程序的必备模型.

>即,GUI,网络,DB,这三词代表着多方面的意义,GUI,代表着程序关于图形界面的模型,网络,代表着程序关于联网作为网络程序的模型,DB,代表着程序关于持久的程序模型,但它们三者,又是桌面应用的典型例子,它们不但是解决程序模型的那类问题,而且,还代表着桌面上典型的应用.(GUI,其实还代表着“2D图形”的多媒体开发)