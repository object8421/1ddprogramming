
/*!

\page C++,.net langs与基于平台上的一般应用问题.html

============= C++,.net langs与基于平台上的一般应用问题


------------- cpp as high level native programming language(C++的第2层)

C++其实是另一种Python. 我们知道C++的 better c+OO,因为其架构在本地上,其编译器内置类型太过低级,它不可能是我们这里说的“另一种python”,template+Boost才是,它们组合,实际上将C++变成了另外一种高阶语言,即以template为脚本语言(此时“在C++的编译器中,模板实例化机制就是这个脚本语言的编译器,而 C++的编译器本身,又是这种脚本语言的运行器”,所以,它完全是一个图灵完备的“语言系统”),以Boost为库的语言体系.

Template可以模拟动态类型,ducking type,这就有点接近python这样的语言了.

但是,稍后我们会看到,C++的第2层依赖第1层作为基础,这使得第2层虽然很高级,但带有它比不上标准脚本应用类语言的弱点.(C++的第2层虽然解决了设计手段问题,但它并没有解决平台问题,我们还是用基本的C级平台类型作开发,而这,给通用应用开发,带来了不便,C++的第2层提倡用高级类型.)

我们知道,C++的三大层(betterc,oo,template),各有各的益处,于是在C++专注的领域,也就有了sql属于betterc接口(只需要这样,没有必要用OO或template ),qt属于OO体系(因为界面是一个树形的递归结构,用OO最合适),而ace用了template(因为socket和网络开发的复杂性,它采用了大量建立在template设计体系上的框架)

本节,我们将介绍BOOST库中,描述一般应用问题的那些库.即除了我们上面已经描述过了关于BOOST的部分其余部分的部分.

--------------------------------------------------

vala其实是另一种C#,而qt其实是另一种C#

cpp 解决了显式化早期版本的cpp仅是对c的translator的问题，而c#解决了qt enhances cpp关于它的pme模型的问题。。

cfront,,cpp的早期版本

c# is really perfect except for its speed,and sudden changes for origianl cpp dever
this can be compared with ,,when ,,c must offer oo ability ,,,so early editon cpp offers transltings to c,, versu the way vala to gnome runtime

很奇怪地发现，(c系第一代是ansic，第二代是cpp,第三代是c#)第三代C系语言几乎都有pme的痕迹。。无一例外，甚至包括gnome对oop的模拟以及vala对它的translating 2 c

真正的oo，流行的oo，是pme，是基于对象保护机制上的adv oo,即pme

vala,gtk,gnome的组合是极好的教育范例，ihave2say

but,c# or mono,is actually the best-fit one for next cpp generation language

------------- 另一种正在流行着的方案

开发的三叉W结构：low level native programming，然后花开两支为：high level native programming（better c runtime，cpp），high level domain programming（soft vm，c#） 

CPP是极其尴尬的语言，前有C，后有c#，它不过是abstract programming中恰好有local runtime而不是soft vm的一支，，c和java,c#都盛极一时，而CPP一直被诟病，，至今

native programming中，C modules + .net不可以完全替代cpp native programming(qt被弃用，不及gtk和winforms是有道理的)，语言从来被设计成相互补充的，而不是替代的。比如.net and .net language并不是one lang for all solutions

*/



企业级应用实现与开发[1. 实际上,python的设计手段往往比C++的高级,只是OO这一地方,二者都有.](Java)
=============

近年来,软件与开发界出现的最显著的一个变化,就是企业在软工方面的巨大影响,这导致了分布式与服务导向,及构件技术,最最显著的一个例子就是web开发.





------------- .net架构对于企业级开发的意义

.net体系中，最终的范式和代码书写的取决，要经过clr,bcl(system.reflection,,etc..)这几关

比如编译器逻辑和运行逻辑vm都经过了bcl的封装，，clr是在这个架构上是最上层的，起到管理和调用vm的作用，然后bcl封装它们，形成软件上的（语言系统软件化，而不再是面向硬件平台，如传统语言所targets的那样）语言机制，即库，编程上可用的东西。。

<b>这样可以做到编程与平台相分离，就像当初的os技术一样，它的目标是做到软件与硬件相分离</b>

System.Reflection.Emit、 Remoting和动态语言运行时（DLR）。.net体系是把这些BCL当语言功能的扩展(clr扩展)来用的，，这是它提倡语言库化，语言即库即语言的体现，以做到编程和平台一体化的动作。


什么是企业开发
-------------

企业开发的基础和应用跟以前任何开发都不一样,它要求跨平台,跨语言.它的程序必定是个网络程序(网络在历史上是学术的工具,然而,随着企业的出现,它成为企业的工具,而企业开发,也使软工进了入新的境界,这就是企业分布式计算,大规模构件技术,支持强大扩展的服务导向)

对于企业计算,首先要解决的,就是隐藏掉桌面开发的关于程序模型的问题,这就是中间件的功劳,它带来的,对于开发者的效果,就是:使企业开发极度面向业务逻辑.比如,JAVA这样的跨平台语言,为脱离平台的编程提供了基础,这样就使JAVA这样的语言被用于企业开发有了可能,而且,JAVA本身跨平台(跨平台的真正意思是“建立在JAVA之上的开发不需对平台本身进行编程,而专注于脱离平台,即传统桌面开发,的开发”),JAVA的RMI,又给跨语言提供了(构件和二进制服务导向)基础.这些,都为企业开发成为纯粹的“业务逻辑开发”提供了可能.

企业开发的三个大特征是相互联系的:比如构件技术,为二进制服务导向提供了基础,而这二者,又最终为分布式计算提供了基础.

当前,企业计算与开发的主要潮流是EJB这样的方案.它以WEB(WEB本身就是一种分布式应用)和为容纳beans的构件容器技术为中心.作为服务的WEB和传统的WEB是有区别的,以前的WEB,只是传统的桌面应用,而作为xmlrpc和wsdl的web(即建立在构件技术上和服务导向的WEB),却是“企业开发的web”.

中间件
-------------

大约在出现企业开发之后,软件的概念就改变了,因为在硬件和软件之间,出现了所谓的中间件

OS是一种“application server”,中间件,也是一种“application server”,前者的application是桌面问题(GUI,DB,NETWORK,这些既是解决桌面程序模型的问题,同时也是桌面的应用问题,这就是说,它的业务,正是它的应用),后者的application是业务逻辑.

中间件,是一种application容器性质的application server,企业开发,是一个有别于以前任何开发流派(硬件,基于OS之上的驱动,内核实现与开发,桌面开发)的新流派,它是整个编程体系和编程理念的变革,因为它提出了,一系列新的编程理念(特别是框架,构架,SOA,构件,模式等东西),一系列新的基础设施(JAVA,IDL,XML,中间件,容器,SAAS,分布式计算,构件,注意,构件,服务导向,和分布式是企业开发的三个最大特征)这就是上面说的,它改变了软件的概念.




分布式计算
-------------

UML,IDL,MDA,COM.CORBA,WEBSERVEICE,XML软工新潮流,企业的一个特点就是分布,所以容易跟corba,dcom这样的技术结合. 网络提供了分布式计算,它与OO结合点就是RPC,RMI啊---这里体现了组合思想(注意这只是在网络间传送接口而非传送整个OO对象的方式来实现二个异地对象之间的交互),它与XML结合点就是JAX,OO与 WEB的结合就是SOAP啊,这些编程领域的东西都在随着人们的认识进行不同的分解与重整合,而且轴渐脱离某个平台.向跨平台发展,,这也就导致了构件的产生,人们希望用一种类似搭积木的方式(相对一门语言外部来说)来assemble(组合)一个应用,这些积木就是用不同语言开发的构件,因此需要提供一个交互用的统一接口(因此经常需要跟IDL技术结合),构件要相互协作发生作用形成最终的可运行系统因此需要部署,一般用XML来表达这种部署.比如我们一般说部属EJBS

也即,语言内部的只能是一个一个的CLASS,当这些CLASS脱离语言环境被分发(在二进制级以库的形式供外界使用)时,往往是以一个一个的组件的形式存在(而且要向外透露接口供使用它的客户使用)的,,

这些构件都是零碎的不能独立发生作用的,而且要实现比如对象同步,负载平衡,安全,持久等需要(这些需要统称为SOA需要),因此发展出一系列的中间件(对SOA的实现)来管理这些构件.

领域逻辑与框架
-------------

当编程深入到使编程者要做的工作具体到参照一个框架进行对框架下的各个部件进行编程时,这样的编程叫框架编程

首先要从SOA说起 SOA:面向服务的架构,这是一种为了直接提供高效能的服务而提出的中间件抽象(普经有一段时间各个企业都用不同的中间件,而当EJB提出后就统一了这种局面,而且一方面独立开发这些可伸缩的中间件的技术因素太多因此一般企业都选择直接购买然后在其上构建应用,这些MOM负责数据库池啊,,负载平衡啊,对象同步啊,线程啊,新旧系统集成啊,安全关机,重启啊),这样人们就不能写这些抽象了,只要wrapper它们然后在上面直接写业务逻辑就行,比如EJB容器就是一种SOA,,而在EJB容器内写EJB就是写业务逻辑了 面向服务架构,服务导向的概念还有接口. 实际上在企业信息化过程中,企业的业务逻辑才是重要的,,EPR方面的事能越简单就越好,因为业务上的事才是重要的,投入在EPR方面的资源要越少和响应突变的能力越强才最好 当设计中出现的元素太依赖于业务了,就选择发展出一个领域模型 今天人们都很关注 SOA,我想说,我们的构件对外提供的就是不折不扣的 Services.” 怎样解决粒度的问题?黄柳青说:http://home.donews.com/donews/article/7/79165.html读一下这篇文章就知道SOA是什么,,,SOA是一种比对象要大的构件,,,逻辑粒度大,,软工复杂度中的很多东西都会解决了,因为逻辑就是可拔插的

Corba与J2EE中的EJB EJB可以相互之间调用,也可和JSP和SERLET(Let是小的意思,applet是小应用程序的意思)发生联系. 一般直接把应用服务器跟容器服务器混为一谈,而SOA一般是指面向WEB服务的SOA J2EE,是构建在J2SE之上的一种规范集合(主要是一些面向SOA的服务中间件规范),,如果说J2SE是一些库代码,那么J2EE就是规范集了,如果EJB容器规范啊这些应用服务规范,每个商空都有自己的J2EE产品,,SUN会为满足这组规范的他们发一个SUN认证的J2EE兼容证. 要满足的J2EE技术和规范有:EJB,JAX――RPC,RMI-IIOP,JNDI,JDBC,JTA,JTS,JMS(一种MOM),以上是应用服务端,还有后端的SERLET,JSP,JAVA IDL,JAVAMAIL,JCA,JAXP,JAAS,等等.. 也即,这些规范只是SUN定义给别人的“接口”,是抽象类,别人可以拿来实现.接口可以拿来实现(当它是一种思想的形式),接口也可拿来组合成软件(当它是一种代码或构件级的可复用形式比如API时)