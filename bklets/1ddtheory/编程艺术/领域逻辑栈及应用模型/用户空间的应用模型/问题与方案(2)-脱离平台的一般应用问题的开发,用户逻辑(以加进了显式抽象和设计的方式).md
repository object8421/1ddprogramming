问题与方案(2): 将问题与编程Web化(基于平台上的一般应用问题,脱离平台的一般应用问题的开发,用户逻辑,以加进了显式抽象和设计的方式)
=============


硬件程序员,解决驱动硬件(在没有一个OS,或有一个OS的情况下)的问题,用的是会编或C

内核程序员,解决系统实现问题,用的是C

桌面程序员,解决系统应用,用的是C,或C++

企业程序员(比如WEB程序员),解决的是业务应用,用的是JAVA这样的脱离平台语言

C++中有二种语言体系和编程体系1,是better c面向本地的编程 2,是template面向编译器的编程.(其中第2层编程,就有点接近python+py库这样的语言,因为template对应高阶设计层Boost对应标准库).实际上,C++的这二层是相承的,不是相对的,比如C++可以用template+Boost的方案更好地解决系统问题.

在这里为什么把C++,Python放在一起呢?因为它们有着某种共同点,它们都是开发语言,而不是实现语言,况且都是加入了设计的开发,不过一支在本地,一支在VM上.

Python与脱离了平台的应用问题与开发 (以倡导标准化的脚本方式) 这种标准化体现在2个方面,1,高阶的设计手段,2高阶的直面应用的设计方案,对于一门具体的语言来说,比如python,这些都深刻在体现在其标准库内. 当然python是脚本语言,它除了不善于直接深入本地平台之外,这并不表明,脚本语言一定不是通用语言.一门语言是不是脚本语言跟它是不是通用语言没有绝对矛盾.Python是general purpose scripting lanuage.





------------- 平台无关语言系统，高级应用域

初级系统实现与开发，是软件和应用最初产生的地方。

后来有桌面编程。当桌面开发稳定以后（桌面上的应用作为应用的基础建设，假设对它的开发已经沉淀，比如直接用名声良好的那些c,cpp runtimes作为桌面应用，桌面开发不存在纷争，不必要发明任何轮子的情况下）

在桌面开发稳定的情况下，出现了.net这样的，平台无关语言与系统，这就形成了这个系统特有的高层开发领域，虽然它们往往与桌面开发有相似之处，但其实并不完全类同。

在前面就说过，与桌面基建有关的开发，已经形成了他们自己的领域。 

脱离了桌面领域的ui,sql,都是，比如.netfx的wpf,wcf framework等等

可以同时是脱离桌面或高于桌面的专用领域。



硬件程序,内核程序,桌面程序,以及什么是企业程序
-------------


本书关于问题的第二部分,就是这里了,前一部分(本书第三章)介绍的是问题中的“系统实现与初级系统开发”,这一部分继承着上一部分,讲解了“高级桌面系统问题,企业程序问题”

我常想,将问题按程序划分,这样的方式到底对不好?

>在前面我们讲到,作为教授通用实践的书,本书并不打算讲解应用,而本章标题中有应用二字,实际上,那些是关于应用的方案.这些应用被作为基本形式被确定下来,作为编程的基础

所以,我们讲解的,是对各个领域通用问题的解决.

企业开发,是一种,相对于桌面开发来说的,在整个基础设施,编程理念,应用基础,进行重新改造后,形成的新的编程领域.在这个领域,大量存在着,框架,之类的概念.

企业开发跟桌面开发相比,有着根本不一样的需要基础,企业应用要求跨越语言,系统和语言整合协作,分布式,面向服务和组件化,高扩展性，高度采用构件，等等,它决定了这样的程序运行在跟桌面不一样的,绝对不同的环境的.

这样的环境,就是中间件[1. 中间件,对程序模型问题的封装使之谈出不为开发者所见,和VM,对系统编程问题的封装,虽然它存在,但程序员已经不需要对它正面编程,是一个道理]和容器,就是企业应用的OS,所以,所谓中间件,其实,不但指API,而且是程序运行环境

当然,作为编程体系和应用技术的新发展,它并非整个地对以前已有成果的颠覆.比如一般企业应用服务器,都是用系统编程的方式实现的.

Os本身就是一种"application server[2. 中间件,也是一种appliaction server,只是,它与os的application内容不一样罢了,中间件的是业务逻辑,它极力摒弃了平台逻辑,而平台逻辑,正是OS的application 内容.]",我们知道,编程基础设施,不光包含OS,这只解决了程序运行环境[3. 分布式计算,从计算二字可以看出,它必然关乎着某种开发,因为冯氏解决方案从来是计算平台与开发平台共同解决的,这个我们在前面就已经讲到过],对于语言呢,它还是运用以前的语言,比如java,下面我们一一道来:

对于企业开发,首先,在这个领域,对于基础设施,有下面几大要求:一,要使用java这样的语言,java这样的语言,是为了跨平台,因为企业根本不需要为平台开发,java存在的意义不是为了跨平台而“进行平台开发”,而是为了“隐藏掉任何开发其实都建立在某一个平台上的事实”,“而只专注于平台上面的问题”.这样的问题为企业问题提供了可能.这样就提出了问题,那么问题方面,有什么要求呢?首先,企业程序,大部分,都必定是个网络程序.以前的开发是桌面上的企业网络程序开发,现在的开发,要是,“有一套与桌面不一样的,自成体系的运行环境(比如中间件技术,容器)和语言(比如java这样的语言),支持下的分布式,面向服务,构件程序”.是真正的现代意义上的“建立在分布式计算上的企业程序”,三,对于开发的要求,此时的企业程序,隐藏掉了桌面“企业程序”带来的一系列问题,比如,GUI问题,用java这样的封装式语言和swt这样的非平台库可以解决,其次,网络,可以用RPC解决,数据库,可以利用现有的关系数据库,隐藏掉诸如此类的“桌面程序的现实模型”问题之后,企业开发就可以纯粹是业务逻辑了.

>“脱离了平台与语言考虑”的语言主要指python这样的标准化了的[4. python从二大方面标准化了,1,平台不相关,2,移殖无语言类型相关.这二大方面区别于C++,以直接支持应用问题.]语言.Python解决的那一类问题,不是以先后解决系统问题,再解决应用问题的那一类问题,而是一上来直接就面向应用问题.而且倡导以极大化地复用的方式(因为python有一个大标准库和第三方库) C++这样的语言其实是平台相关的,所以它的类型是语言相关的.但还是把C++写在这里,是因为设计模式,这样的东西,其实和python有重合之处. 为什么它们有重合之处呢?实际上,高级系统问题,比如游戏开发(其底层是系统逻辑direct x或gdi),但实际上,也是一种应用问题,C++必须跟python一样提供支持面向越来越抽象的应用设计手段.故此,在某些方面,C++跟python有相同的重合点. 但是正如C不可能增加OO一样(否则它就成了另一种C++),python也不可能增加平台无关的类型,否则这样的话,它就变成了另外一种python. 也即,C,C++,Python是共存性的,缺一不可的,不是互可以替代的.它们面向解决不同的问题,这个要求决定它们是共存的.

开发中的分布要求,产生了二个复杂度,1网络开发,2软件要独立于平台和硬件架构,,这就是WEB的特征

即,在解决程序模型方面,系统开发和企业开发,都面临着这二方面的需求(这本身成为区分这二种程序流派的绝好分界线),但系统程序解决模型的手段,也正是系统应用的重要方面,所以,系统开发,对于复用,必定要限制于具体平台之上.换言之,不可能对这些系统模型方面的问题(GUI,网络,数据库持久)产生的复用问题进行免疫.(也即,复用从来都只是一个狭隘的词)

而企业开发,它的程序本质上跟桌面毫无关系(虽然它也需要一个界面,一份持久方案,一个联网机制来解决作为“程序”意义上的模型的东西),所以对于极度复用化,它反倒提供了一种可能,所以,它摒弃了桌面程序(桌面GUI程序,联网程序,持久数据库程序)解决程序模型方面的所有问题,只为了能做到“企业程序全部是业务逻辑”,而这一切,都是中间件的任务.

中间件解决上述问题的方式,就是将这些模型的问题,都跟业务逻辑分开,当变更程序模型方案时,不触动到业务逻辑.这就是中间件要解决的主要任务.

**比如web就是一种分布式企业程序,当然,它只是现在最主流的,分布式企业程序的解决之道之一而已(分布式程序是一个大类),**

抽象方向的不同
-------------

桌面开发将抽象保持在桌面层，所有程序都是抽象上的桌面ui,db,network抽象堆栈，而不是像web开发一样继续从业务逻辑上进行抽象，以提出更多的抽象体系。

**web开发较桌面开发，最大的一个特点是，不再以桌面上的抽象以“程序”的抽象依据。而是更注重具体的业务逻辑**,它对业界未能抽象的领域继续进行抽象.这样才能发展出新的领域并对其进行编程.

WEB开发的出现，表明关于程序的非业务逻辑已全部得到抽象。平台支持已趋完善。

>什么是C++在历史上能很好解决的那类问题呢?

说到这里,我想到一个有趣的现象:QT库有一个功能可以定制程序界面的CSS方案,它是作为桌面环境底层的,所以在结合桌面GUI和webkit GUI方面“顺便”做了一点整合(使之变成了RIA开发).但其实,QT这样做对于桌面程序员来说反而是不对的.
因为网页的界面跟桌面界面的要求完全是不一样的,这是因为历史上,桌面只需要设计成那样(一个简陋的frame加上widget - 即跟rwc,ria相对的simplewc,simpleia,及内部的诸如消息处理等的逻辑就行了[5. Windows有一个rich gui wfl的库]),桌面开发有着成型它在历史上业已形成的方案域,不需要加上CSS这样的东西,那已经超出了桌面程序GUI的范畴,有点向webkit和web靠扰了(而且,QT还跟ACE这样的东西一样,定义了诸如qtapplication=network+DB+gui+io这样的东西,这跟MFC完成的工作有些雷同了,做了太多它本不应做的事).
对于历史原因,在计算机开发界已经成了定例的那些事情,所有的人共享一套共同的认识(这就是程序员必须面向的“历史遗留现象”),如果再超前一点,实际上不是受鼓励的.因为那超出了你“能解决”的范畴,至于如何能解决好,那只是智者见智的事情,并不是统一的东西.
C++, 实际上,C++的用途主要用在OO的程序模型上,这是C++的主要历史用法,比如GUI,数据库,网络开发.所以,界面,网络,数据库,只是极为有限的那些东西(比如django解决的问题极为有限,它名为web开发框架,如果着重最后二字,实际上可以看到它只是减少开发python web的框架性重复劳动,还比如MFC,JFC,是AFL,application framework library,是基础的foundation class.),.C++在历史上一直为的就是能“很好地解决这些框架性的事”.当然,这三大框架也足够复杂(每个领域都可以产生很多专家,学术流派,写成几十本书),解决了它们,也就相当解决了大部分非业务的问题.
当然,对于一个程序来说,这些程序模型相对只是表面(即,对于系统开发来说,它们是业务领域,对于应用开发来说,它们是非业务领域),要解决的实际问题,最主要的问题还是业务领域[6. 所以,实际上,我们的C++编程活动,往往只是表面的“解决程序关于系统的”系统编程.而不是纯粹的“解决程序关于业务”的应用编程.这就是我们日常用 C++来进行编程的主要活动(实际上是相当狭隘的,因为系统抽象是我们所能理解的很小一部分正确抽象,业务领域才是广大的,而实际上,没有纯粹的脱离系统的编程　－　用C++开发,我们总是完成一部分系统编程,再在这个基础上完成你要完成的应用方面的事情,只是层次上的多刮问题).Python就是用来突破C++语言的.],广大的问题永远只会来源于此,比如游戏开发等(我用它来举例,是因为游戏开发几乎涉及了C++的关于处理程序模型的三个主要方面,而它还涉及到很多世界逻辑方面的业务领域内的事情),C++再强大,库再丰富,它也不能解决业务领域那些我们未抽象的事物.任何语言都不能[7. Java强大,是因为它抛弃了桌面开发(C++)的那些不可移殖等问题,并做得更好(j2se)后以后,引进了大量新的编程理念与新的领域抽象 (j2ee),所以,它的贡献主要在这里(jdk完成的抽象和解决了的问题,而不是java本身的语法机制,实际上,java本身并没有像 C++,lisp,smart,ada一样,提出一个属于自己的编程理念).],而界面,数据库,网络是我们业已正确抽象了的事物.所以C++会有这方面的库.
所以,在学习C++的过程中,务必要学习这三大模型.在本书对C++的讲解中,我们主体上,也将讲解这三大内容.