/*!

\page 设计.html

============= 设计

当逻辑很大时，，，一个抽象体系是不是必须，得有，，或自然形成为，，某种架构





------------- 软件过程与软件结构


###### 预设计

软件开发过程分设计和编码,组织这二者(以及对其它细节的工程可控性要求)的工程化方法就是XP啊,UPS啊什么的,设计阶段的工作是可以涵盖整个软件开发过程的,而且可以跟编码同步(一旦已经在写代码,那么你就开始在设计了)或异步(最好还是先想好设计的每个细节)进行。

大设计是一种动用一切资源,从整个思想领域去设计计算机应用的过短,,这完全是一种预设计,编码过程变成了纯粹的被设计预见的集成的一个过程,,这种设计往往首先从思想出发,,完全不考虑计算机实现,语言机制对应用的限制或表达能力,,,提出一种标准和理想模型,把思维过程出现的任何一个过程都作为设计的一部分,设计过程中任何动作都不跟计算机和程序语言相关,,最后仅留一点余地作为编码,在编码时考虑其跟计算机实现和语言机制实现的结合,编码的地位很低很终端..
游戏是什么呢?如何设计一个游戏呢,,游戏这个字眼可以无限被放大(根据我们在《应用与抽象》中说到的,应用领域可以无限深化),WEB论坛可以是文字游戏,3D游戏也是游戏,,网游也是游戏,,是不是要在你的设计中体现这所有的元素呢(一个具体的设计总是针对某个应用域寻求它在计算机和语言域的对应,如果你知道算法和数据结构你就深刻理解这个说法了,我们总是向语言和OS中寻找某种可能适应我们问题的数据结构,即使再通用的逻辑,比如库的设计,我们也不应),并用一种“设计模式”中的模式来组织这所有的元素呢,,不能,,而且不应该..你不可能在有生之年把它们(设计中出现的需要组织的逻辑们)的地位作一个组织或你自认为合理的排列..
你可能会说我不直接提供这些无素的实现,,不直接在设计中体现这些,我只需预见它们,,并在设计中为他们预留接口,,但这样也是不行的

预设计,大设计是一种“一次性设计”,企图把应用设计中的大大小小所有过程整合到一个大设计中,,,这样的代价当实际编程开始时如果遇到不能前进的错误会损失很大,而且设计本身花费精力也不少

>明白了原理跟实践,细节与思想之间的关系,我们就会有选择性地去学习细节,,一定要研究细节,因为细节是重要的,你得用这种技术细节实现某个东西,不一定要研究细节,还是因为你要不要用到它,然而思想是重要的,明白了这个思想,你就明白有些知识是技术细节,有些思想却是根本,当然,没到考虑思想的水平,技术细节永远也还是重要的,不要企图去钻研一切细节,因为很无聊,除非你是在满足自己,一生学习细节,这又是多少无聊的事



###### 从上而下或从下而上

大设计就是指从上而下设计,较之从下而上设计,**它是一个强一次性架构设计的静态过程,所以它要求的设计能力很强,因为它违反由易到难的原则**,而我们通用的设计方法,往往是从下而上的动态过程.
当你看到一个功能,抽象,架构,扩展,接口体系上都很复杂,丰富,完善的软体时,千万不要这是一次性设计的功劳,以从下而上设计的观点来看,复杂性都是积累来的,不是像从上而下设计那样的一次性就计划好的过程,所以,动态的原型在敏捷开发处处可见.因为它把软件开发设计过程看成一个动态增加复杂性和设计元素的过程. 其实,软件设计没有任何捷径,这跟其它艺术事物的设计,道理上是一样的,设计没有通解[10. 没有标准的“软件开发过程”.可以以一种简单原理促成其最大效率,所以,也就没有银弹.],只有具体到某个点上,才能获得一些所谓的通则,比如软件设计的DP,他们也只是具体某些问题,才显得有意义的那些设计罢了.

------------- 软件的复杂性

软件的复杂性在于相似的需求很多但各各不同（定制性很强），，通用的轮子往往要推倒重来，所谓接口和组件组合（对于追求天然一体设计的程序并不合适），组合的复杂性往往有时超过一切轮子都重新发明，这也就是为什么维护过程反而比开发过程更难更费时,多次重构，动态构建，就是统一开发（设计的第一次定型——原型）和维护过程（后来的重构带来的设计上的改良）,,,追求有层次的抽象和合理的设计，，，这样的编程过程不应引入可能打乱它们的外来库（比如需要的抽象恰好在外来库和自己的程序中有交集，简单的wrapper外来逻辑至自己的逻辑体系可能不合适）

软件的复杂性来自于规模，当软件本身规模本来就很大时，所需的语言技法，接口组合，越来越难解决最终的维护，所以，任何软件的设计，原型设计的规模都不大，你看到大型的软件，是因为他们不是一次就设计出来的而是多次重构来的，故要制mpge设计的规模，把更多问题后来化,,比尔盖次对大规模软件有一个航母的比喻

软件的复杂性根本上是对一大团抽象聚集进行操作，而且是层级，或并行错乱的抽象。软件的复杂性由此看来是必然和不可避免的，是本质的（逻辑系统的改动，动则重来），银弹不存在，，这就跟事后调试一样，是人的智能完成先前而后的顺序的过程。


------------- 软件活动的时代特点

**现在是软工时代,而非手工作坊的个人英雄时代,软件需要你考虑每一个细节,几乎每个中大型软件的设计都可以是以真正工程规模来较其大小的活动.所以修改和维护是需要付出重大代价的**.因为这不比盖房子,软件制造跟实物工业制造有一点不同,软件主要是抽象出来的软件产品都是某些体现为源码的有机概念体系而已,做软件需要你从大量小逻辑促成应用(每一个部分都可能需要你造轮子).

有些程序是规范（提出规范然后然后厂商特有的API），，你必须导入第三方厂商库，，如果自己实现，往往跟不上或不必要

经常碰到为了某套程序，，将基础标准库颠倒重造的情况都有。比如mpge之于minqw
idlib,qt,这样的东西，都是从开发的0基础入手，颠倒重来，轮子重造，改造语言系统甚至运行系统的典型。
真正的领域引擎不光是本身领域的解决方案。它还是对语言，工具的上流端进行的改良或修正，这就是开发框架和开发方式上的，还是对引擎下流端的各级用户支持，除开发者引擎支持外的工具，用户开发支持的整套方案支持。



而且现实生活中软件活动通常都是变化的:代码在变化,设计在变化,连需求都在变化.别空想设计,设计也是源于迫切要解决的问题[1. 设计是受需求和应用问题本身驱动的,设计根本就是处理”问题--程序--人（需求）”这三者之间的关系],你说的设计需要可能是一个空想的禁固..

比如编程可以从方案端出发，，不考虑应用，做一个大而全的可复用产品，也可以从具体应用出发，做一个只实现了一部分上述大而全的可复用产品的其中一部分抽象的产品。


现今，人们都不太宁愿所有一切都发明轮子(这是当今软工的特点之一)。所以,编程作为一种混合了语言和其它各种因素的混合模型,第一步是找轮子,包括找什么语言,封装使用什么库,选用什么语法机制,都是找轮子.这就是那些被称为开发的现实性的问题.理想中的大设计跟具体的大设计完全是二重天的区别.

在本书导读中我们就说过，一切都是工程，有软件工程，数据分析，数据库工程，硬件工程，用户编程，数据制作，媒体设计3d制作，等等，本书的组织，是“从工程眼光看编程，从工程眼光看problem domains”，本书的组织是先谈软件工程（冯氏系统上的编程），再谈问题（“桌面开发，图形开发，游戏开发”），最后谈设计和用户编程（dsl,数据库分析与设计）等等，其实，在建立一个应用的所有中间过程中，所有阶段，都是工程，统称为“软件工程”

设计不是为了完美地抽象事物的各个方面,即,作为编程工产业的设计,永远不是为了设计而设计,而是为了产出目标面向需求,然后兼顾复用及以后维护,等等这些目的[2. 这二个过程不可逆转,脚注这个并非画蛇添足,软工是一个只需要死定义,不能灵活化的概念.否则就是多做了工作.明白这个的确没多大用,但如果说出来都不明白..这就是你的错了],为了减少重复工作量,利于扩展增加新功能等这些从人出发的实际要求,故,软件都源于需求,没有无源之水的设计,就设计和需求的关系来说,设计是现象,需求才是本质.

------------- 影响软件过程和设计的因素

###### 平台中的设计

其实,影响你设计方向的还可以是平台,因为编程的另外一种意思是“必定用到语言的,为问题在语言内找对应物的映射过程”

###### 编程语言中的设计

**这个时代,我们是用表达算法的语言表达映射,用表达设计的语言表达功能,是用同一种语言混合表达编程多个方面的时代（比如C++和它的better c及多泛型）**

算法,设计,抽象实现,接口,功能,源码,软件..-----》编程就是这开发的综合,设计和编程并不可区别看待.设计即编程.从你写下第一行代码,你就在作设计和抽象(只不过你显式或隐式地利用了语言的手段,即使你在源码中没有写任何抽象)

因为任何语句都是一种设计语法(是语言赋于你以流程控制的手段写程序的,所以也是一种设计[3. 程序设计语言的各种语句,其实是设计,比如四种结构化语句,就把语言弄成了结构化语言,现在的语言,都不可能不是结构化的,而且大都是在结构化的基础上加入了OO,,所以又成了OO语言.计算机界的高低级成果之间,往往不是相互替代的,而是相互承接相互补充的.])

源码就是设计,,源码就是那么东西的综合,故它最能体现在中间阶段,我们做了什么样的设计工作,故设计自然就清楚了,我们要得到的,就是那么种在理解一切后自然懂得如何设计的道理.

虽然语言和工具只是外在的表现,问题,抽象,设计,可以独立具体语言被解决,然而在我们现实的开发中,解决问题,对问题进行抽象,是受语言支持和支配的,它影响了我们如何思维,甚至如何抽象.在语言端,如何选用库,都会影响我们抽象和设计的方向

用设计指导抽象,什么时机引入面向程序的设计呢,使用语言如C++决定了你思考问题的方向

设计期聚集于程序员,运行期聚集于用户,,比如当设计深入应用时,语言的设计和运行功能都要很强,,设计时不可能预测用户点了什么菜单.
当然也存在显式化设计的语言级的具现,这就是设计模式,如果一个源文件是singlton.h,那么它就是显式的设计作为抽象,一般称隐含的设计和抽象为设计

再次,设计需要对代码逻辑的控制,即,设计是对工具(编程语言)的设计,因为是由人来写代码而且也是由人来维护代码的,所以选择一种能切合人类层次又靠近语言支持的方式是必要的,过程式使人类能以发号施令的方式写计算机逻辑.面向对象力求单方面站在人类抽象的角度将计算机逻辑封装为一个一个的对象.并不需要考虑对计算机的实现过程(当然在每个class内部也可以有过程式),相对面向过程来说,面向对象是更抽象的(当然,仅仅在“这个层次”上我们才能获得OO的复用好处,实际上我们也只取它的这个好处).当然,这些都是大的代码逻辑控制手段,和高级语法机制,小的可以小到“流程控制,循环”这样的Core C语法课题.

在语言选择方面,如果是通用编译型语言,因为类型是语言表达客观事物或客观逻辑事物的机制(使之成为语言的数据使语言成为一个DSL),所以代码逻辑的抽象首先是一种类型抽象的过程,比如把科学计算机能用到的数值抽象为INT,FLOAT这样的语言Primate 类型,进一步地,我们还可以对他们进行代码层次的抽象,C++中有OC(面向类化),模板范型这样的对类型进行抽象的机制,如果是通用脚本解释型语言,它将类型动态化,这样就能更好地表达领域词汇,DSL抽象.相比通用编译型语言来说,这二者都存在设计的抽象和实现(因为都存在类型),但显然脚本语言更靠近实现,,这二者的唯一的区别在于,编译型语言用了严格类型的抽象来表达DSL逻辑,而脚本型语言采用了活动类型的方式来抽象DSL逻辑.

###### 对于事物抽象中的设计
程序设计还是一种对应用的抽象过程,因为任何软件的编制在于解决目标问题,面向一个目标领域,无论是架构师还是程序员方面,都需要面对程序设计要解决的问题和领域进行抽象(当然,程序员并不考虑全局应用的抽象),,提供一个科学组织的抽象框架以更好利用复用或更下一步的抽象,软件产品的用户有三,最终用户,最终脚本用户,程序员用户.其中,2,3是能有机会进入到程序逻辑内部的用户.如果是写代码的那个人来维护程序,实际上就是下一步的抽象,下一步的抽象和复用不过一个词说法的二个方面.

>当面对一个未知领域的设计时,我们不懂里面的抽象,因为它是一个未经正确抽象的领域,所以从下而上往往被用于未知领域的抽象.比如,一个不懂业界图形学抽象体系的程序员,他只能用从下而上一步一步的设计.而从上而下往往用在高手的作品上,因为它对业界关于这个领域在程序上如何作抽象,有相当的了解,甚至形成了一套抽象体系(抽象用的抽象体系).并能作基于这种抽象体系之上的设计指导抽象.
这些在本书第三部分《corely and minly learn graphic programming》都可以找到答案.

对于具体的一个问题,程序根本上要解决三个,1,能否用计算机解决这个问题,这就是数据结构和算法要解决的问题,2,能否用语言进行映射,怎么样用设计的方法映射好.3.它要提供什么样的功能以满足这个问题最终呈现在现实中要解决的问题.

问题与人是最最内在的,是问题与功能需求方面的事,抽象与设计是编程方面的事,是相对外在的,它是承上启下的,最后一个是语言,工具,它是更更相对外在的.然而,在任何一个具体的编程活动中,这一切都是综合的.不可分的.

对于同一个需求的理解，会产生不同的设计，这就像现实中做房子，各种经设计后做出来的实物房子，的触会产生不同的效用（对于各种房子来说是抗震等，对于各种程序来说是可否利于扩展），所以一次设计代表了一次源码过程，代表了一次产物过程，需求是人的东西，它不代表编程，一次具体设计才代表着一次编程。

###### 对于人的设计

这基本上是设计的最高境界和最终归宿了。

为什么人们都喜欢设计优先呢？因为人们想要得到这样一个结果：编程时，最重要的是先完成一个设计，然后其余的工作只是一个可每天都增加的代码机械过程，它是UML图？

设计并不仅仅面向于创新,有时是形式的重组,而不是内容的创新,应用形式的改观,设计出的产品,要源端是面向人的,因此要提供足够简单的使用和访问形式,在目标端是要达到足够丰富的应用逻辑(比如XML统一文档交换,但可由node,root这些形式导致足够丰富的深层功能,深层这里是指上层),因此越复杂越大而全越好(但是如果没有足够人力,我们应考虑设计出别人想不到的商机),应用形式和应用逻辑作为设计中应主要考虑到的问题,有很多人想到用一种形式来统一既存的东西,比如在jvm搭建Windows和其它一切软件,然而这是多么无聊的事啊?

扩展需求一般来自哪里？软件的窄扩问题主要出现在哪？？

1.同类算法的欠入
2.可替代组件
3,对平台移殖
4,可与多个第三方库对接
5,用户的定植


对于语言（比如langs on .net,langs on jvm），编程工程越来越集成化的表现有：

1,将平台集成到语言
2,库即应用，将应用集成到语言
3,语言即库扩展，，将语言实现集成到语言，，第一个语言指具体语言，后一个语言指语言系统。
将应用的发布机制集成到语言

4，集成多种语言系统，如CLR，DLR，可以让多种语言共享基础设施，并且做进同一套平台。
5,将一切集成到语言，包括方法论，比如传统的调试，<b>当纯粹用编码来完成时，而不仅依赖仅是工具的调试器，就变成了测试</b>。而且还能跟方法论接轨。

用编程控制的部署，，应是disutils这样的东西吧，不应是构件？构件属于艺术了，就相当于，如何搭网络，如何uml

集成固然是好的，然而，我们有时不但要学会集成使一切变得更简，而且有时要创新使一切变得更简，比如java 与vb visulprogramming,trigger programming,data flow programming的对比

我们上面说到设计首先是一种对应用的抽象过程,然而,虽然抽象过程并不需要预先考虑软件复用能力,但是科学组织了的,松偶合,紧实现的抽象过程显然可以为整个设计中的所有阶段带来好处.

为了维护既有的源码”,设计也是必须的,为了使问题清希,开发者共享一套认识,抽象也是必须的.

基本上，一套软件最终的设计成品不但包括文档，程序（这其中最终产品有着鲜明的为最终用户服务的特点，比如IDE等一条龙产品，比如2d editing之于photoshop,3d之于maya,3dmax）等

综上所述,无论如何,设计的最终目的是使软件产品具有更强大的生命力,对其内要做到科学抽象和组织,对其外要做到利用复用,易于重构

------------- 架构

框架让你先设计(虽然搭建框架的工作也是编码的一部分)，后编码

框架就是设计的编码化

框架是整合的可复用吕，框架让你先设计(虽然搭建框架的工作也是编码的一部分)，后编码，尽量可将预见的更改和扩展做到预设计之后)，，

因为有了好的架构，所以源码有了不同的质量，架构非但是抽象的架构（面向程序员使之清希），也是产品的架构（面向应用使之多用好用）


软件的工业化，要求软件本身，甚至开发过程，必须都是可复用的，为了支持可复用，，必须平台，语言，应用，人多方合作（最终要反映到编程中，特别是编程语言中），，历史上，不可复用问题首先来自于平台，首先来自平台逻辑不可移殖：

1,平台的不可移殖，带来的不可复用问题，这种不可复用是OS层面的，解决方法可以像qt一样，smoothing平台相关的部分(src/general/foundationclass/native/system/platform)，，也可以建造一个VM，，将编程移到专门的软件平台(建立在OS应用层面上，某种强烈面向编程的软件平台)上，这样，移殖问题就纯粹是面对一个统一的环境了，，而不再是分散的硬件和OS。

2，代码的不可复用，如果不行,,可以用跨平台的组件来提高可复用，甚至可以将跨网络问题包括进来，比如在VM中提供统一的组件机制,它可以有效地解决跨网络的分布问题.

跟OO一样，组件化也曾经被认为是软工的银弹产生过一次革命。

3,语法和开发方式上的不可复用，可以用pure OO的oop来解决。pure oo首先是一种，如果pure OO不行，那么可以再次提高复用的层次，即上升到高级语法方案域，如DP,,abstract idoms,design patterns.

>>实际上，在C这样的第一代高级语言中也存在abstract idoms,它往往是隐式的。cpp这样的有显式OOP的语言可以用一种明示的方法去展现，

这就是design patters.

4，应用方案抽象方式，开发文化上，的不可服用，可以用语义。或提出更多语言或DSL的方式来解决。

5，软件过程的不统一，首先，OO的object tree的源码组织特别适合多人协同开发，可以进一步用USP的方式，或AGILE的方式来解决。


*/