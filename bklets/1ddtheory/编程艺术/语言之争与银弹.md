title: 语言之争
prev_title: war3 gameplay suports
prev_url: war3 gameplay suports.html
next_title: 计算机,编程及CG,ai中的科学基础导读
next_url: 计算机,编程及CG,ai中的科学基础导读.html

语言之争
=============

经过整本书的论述，现在，是我们真正能作一些独立自主的语言选择的时候了。

这不妨从Blubs的失败说起:
Blubs 指代这样一类人,他们希望用一种语言来表达所有的应用,这样的语言叫Blub Language,然而,业界最终没能找到这样的语言,甚至于连尝试做这样一种机器也失败了[^1].

因为我们在导读中就说过了，语言外部因素有平台，应用，人等，内部有数据类型与运算系统等，在接下来，我们在讨论任何一对相对语言的对比时，都首先会先内部开始然后作外部比较。





C与C++之争
-------------

C++之父在他的一本书中透露说,1/3的人反对在C++中加入OO[^2],1/3的人积极推荐他向C++中加入这些功能,最近一次,Linux之父跟一帮C++的拥护者在一个论坛上吵得可以开交.

那么这两帮人争的究竟是什么呢,难道就是传说中C,C++孰优孰劣这样的语言间存亡的问题吗?知识分子们当真会这么粗鲁?

首先,C++是必定离不开C的,C对于C++的作用应该说在这个话题的最前面.如果C++一开始没有用C作为基础来进行++(cfront),那么在那个人们只会“函数+过程”的年代,C++就只能是个早产而死的婴儿了(从技术上来讲,从来OO都是建立在过程式上面的况且,C++本身也是一个better C).

实际上,函数和类都是代码结构,只不过函数和三种控制结构要简单,比类要简单得多,但其实他们都跟解决实际问题没有必然联系,伪码图,C函数,C++类,都能实现数据结构,只是当问题要被编程实现时,我们左手有C而右手有C++却反而陷入二难一样.而如果只有C,大家都只会C,谁都会明白用“三种流程,一个函数”的写法去写,这样的争端根本不会存在.
C的程序员在用C++表达数据结构与算法时,出现了二种情况: 要么写出来的东西虽然被套一个Class名字,实际上还是过程编程,要么虽然能类化相关概念做到真到的面向对象,但是感觉不如C的三种流程来得直观,感到OO很别扭.(参见STL的写法和对STL的使用,还有你能找到的OO实现的数据结构库)

在系统编程界，业界对于数据结构,实际上人们已经习惯于用三种流程来表达数据结构(你会发现用python实现的常见数据结构和算法，和用C实现的神同而形异),跟类比起来,三种流程加简单数据类型的语言机制已经足够.如果再强制他们使用C++来表现(当然,我们这里指的是真正会用OO来写程序的人).那么他们实际上做了二件事: 对数据结构和算法能解决的问题做了解决(数据结构) 对代码进行了抽象(代码结构),使他们刚用C++呈现的数据结构与算法的实现如何能被下一位程序员更好复用,我们知道OO是C++带给程序员的抽象机制,对于了解这层抽象的人来说,他可以很灵活地写出质量好,逻辑清楚的类(比如STL的作者,虽然那是Template class类,泛类,但我们这里还是把它作为OO的类来看待),但是如果回顾对STL的学习过程,大多数人会觉得诸如迭代器,Type Traits榨汁器这样的东西是晦涩的东西.
所以,简单的语言机制都能解决的问题,为什么硬要套上一个Class,还要造出诸如迭代器之类的东东?

这是因为还需要抽象，语言的内部可以无限接近原始的机器指令形式，比如C，但语言的外部，一定要借助抽象，让它成为能很好面向人，面向应用问题的方式被用于编程。

然而抽象本身是分高低的。

面向对象程序员之间很容易写出质量参差不齐的程序,有的人写的程序用了大量迭代器之类的抽象概念,有的程序员写的程序全是Class pig,Class cat之类的实体概念.对于前面程序员写的程序,如果不能理解,基本上很难复用(即使有class public member在那里,他还得看懂背后的抽象意义).后面程序员写的程序,有时又会显得太繁琐(比如他会把一些不该抽象的东西抽象成为猫爪子,而实际上并不需要这层抽象).

这就是过度抽象给程序员带来的麻烦.对于了解它会使用它的人来说是利器,对于不会使用它的人来说实际上是障碍.抽象的好处是某一个层面上的相对容易性(比如OO将复用维持在public member,protected member等接口上,当然OO远不只这些.),但是在另外一些层面会对不理解它的人造成更多层面上的迷茫(OO的缺陷不来源于OO本身,而是来源于对OO的滥用).
所以，本质上C和C++的比较也是抽象多少的问题(对硬件架构和软件系统,构成的系统编程环境进行抽象,以靠近人脑开发),linux之父还跟别人争得起烟,,在Windows的GDI中,用C实现了一个对象系统,连C都抽象了桌面对象,还有什么不能抽象的,,,只不过C++在语言级实现了一个OO而已(而ＷＩＮ的桌面环境对象系统是在逻辑库级),

然而，就像必须指出C++曾经依赖过C并且最后又深刻区别于C一样，最后一点必须也被声明，C和C++是相承的,不是矛盾的,它们的区别,反而正是它的互补.

>C语言最新的标准是C99,然而除非特别说明,当谈到C++的并拿来跟C作比较的时候,人们这时指的又是C89而不是C99.如果把C++当成包含是独立的语言[^3],那么C就是C++的一部分,如果把C不当成是C++的一部分,那么C++(除去better c)就只有OO和template了
C++在C89标准上面加上Exception,更严格的类型检查, (Better C部分)再加上OO,加上Template,就形成了C++[^4],最初的C++语言的实现(就是C++作者写的第一个编译器)实际上本质上是一个C编译器,他在C编译器的前端额外加了一个过程(由C++到C的翻译器),把C++代码映射为C语言作为目标语言.再把此目标语言映射为机器语言..
关于C89与C99方面的差异有一些是根本性的,因为实现的原理根本不一样(是编译器方面的差别,而不是库级逻辑上的差别),比如C++直接支持真正的char类型,而C的char是一种再声明(是用int typedef出来的)

###### 过程式与OO式的比较

对于C，C++比较，一个方面也是过程式与OO的对比

对于OO,即使对一些已经似乎成为常识接受的OO,许多人都抱有疑问.他们问,OO真的就简化了人们编程的工作吗?遗憾的是许多人并不认同这个说法.

C和C++的争论高潮就在这里,系统逻辑本来就是固定的,死的离散,而C++的OO对他们作了极为灵活的封装变换[^5],因此造成即使对原来C能很好表达的系统编程的理解,,也变得在人们之间不够透明,,这造成的可复性反而会降低.这是抽象不够和抽象过度问题.

所以,总结一下,C与C++之争的关键的关键在于:并不是所有人都会C++,会C++的不一定会用类,用了类的不一定在面向对象,用了对象的一部分只会写Class Pig这样的东西,另一部分却开始写Class iterate了,这就是问题产生开来的关键.

于是，C跟C++的区别就在于其名称,我觉得第一个加号是一种理念上的叠加,第二个加才是语言要素上的改变(而非第一个+是ＯＯ,第二个+是模板),C跟计算机离散和底层接近,解决的问题是如何实现,专注于计算机对问题的实现,因为C语言就是系统的观点,用OO表现的现实事物,相对于C用结构和函数表达的现实事物来说,,,后者更接近系统编程的惯例.但用了OO的系统编程却加上了OO这样的代码逻辑.而且,对于非系统编程的应用编程来说,C本身的那么有限的语法机制,即使离开了语法级的OO,C也可直接用函数级的第一类型(组成的模块)和结构体数据抽象,和指针,,这些东西描述应用领域(虽然不够C++抽象),比如Windows用C表达消息,,jxta用c表达管道,端点这些概念,,,

###### 对于工程

那么非得在编程中使用OO吗？C++有一天会退化成C吗？

>在这个新技术日新月益的今天,C的开发早过时了[^6],系统开发现在有点过时了,现在是高层逻辑开发时代和Web编程.现在的Web开发(这些架在逻辑上的逻辑(TCP,HTTP,WWW,SOAP一层一层而来)是某种死角领域,,用到的逻辑很单纯,所以也称为高阶开发,因为它有别于普通开发,即数据库.界面,3D,等等),,,提出了一系列新语言,新的框架,,设计哲学,,这些都是远离计算机底层的(甚至远离数据结构和算法这样的通用实现逻辑),,更像是一种逻辑的配置,,然而逻辑的配置比开发更难,因为它接近应用,有因为本来就很复杂和不断发展的应用端带来的新问题,,,这个道理就像:这个时代GUI远远比CUI常见,,但反而CUI才是主流
现在再也不是早是不是要用OO还是不要用OO的问题了(这个问题已经早过时了),因为JAVA和DOTNET出现了,它们的出现表明,这个时代,OO已经假设作为任何编程的标准被继承下来.它被证明是很好的东西,任何人不必再对它进行颠复,不但要用OO,而且还要用虚拟平台上的一套OO,(也即所有的应用应该从平地再加一层逻辑,加到虚拟平台上去,以前我们是从汇编到C,这是对CPU编程转到对OS编程的改变,从DOS到WINDOWS的编程平台转变,,对网络编程和对本地编程平台的转变等等.因为我们OO编程时总是用一套OO库来进行我们的开发嘛,以前我们是直接用本地平台上的OO库,现在好了,我们被迫用虚拟的OO库,因为它建立在平台之上,同平台独立,因为这层抽象最大的作用就是1.使我们利用JAVA或DOTNET开发出的程序是真正的OO程序 - 因为JAVA和DOTNET提供的虚拟编程OO库都是严格组织和科学划分的,专门为OO而设计,而且更重要:2.它们独立平台,这样编程的时候我们的眼光就会不再局限平台而专注跟平台无关的通用应用领域,问题域,如J2EE)

这些在接下来会谈到。

C不能满足大规模的开发,因此出现了引进了OO的C变体C++, **C,和C++都面向真正的计算机环境，这样说是因为它们都以native runtime为运行目标，而native runtime是直接寄宿在本地OS上的一种本地环境**,C可以做C++做的一切事情,但是C明显不能大规模开发需求,当面向本地编程时,当逻辑过大时,一定需要C++这样的语言作辅助.提倡对本地编程只需要C就够了而排除C++的这种论调是极端的,而C++也并不是做得完美,既然OO这么好,为什么C不自己++呢?因为OO不是C的任务.因为那样就变成另一种C++了,比如objectivec而问题还是没变,

>所以说，C,C++的最终目的是统一的,C++是对C的统一,而不是隐藏掉C及C要完成的那些东西(C++为什么不叫++C,因为C++这个名字表示,它还是C,只不过在C的基础上++了,是为了将C的工作进行到底的加强与促进,而++C,有“C++是一种已变质的另一种C,它可能叫D”的嫌疑,因为它并不以C打头,并不姓C),只是C++有可能,注意只是有可能,“有可能,或提倡” 而不是“必须要”在一个更高层次上进行系统开发.因此,C++可能描述高级系统问题.也可能只是C(即better c),但这二种可能,都是为了把原来C的那些事情干得更好.而不是一定得处处不干C的事情.当C++有可能描述高级系统问题,体现高级设计手段时,它又跟Python有异曲同工之妙,因此,C++是一种二面三刀的中间语言.

C++跟人接近,解决的是如何更好地复用,关注于问题本身,脱离了实现逻辑如平台逻辑,人们如何更好地写代码服务工业化,OO就是人类的观点,C是实现域扩展,C++则完成了一个从实现域到问题域的一个维度变换而已,

C和C++解决问题时,,只是它们站在二个根本不同的维度而已(于是导致的纠份只是仁者见仁的事,因为各个层次的人所需要的不同所认同的也就不同). C语言能用简单的语法解决那些对于计算机实现要迫切解决的问题,而且这种做法已经成了惯例,比如算法和数据结构,比如内外排序,当要排序的对象远远大于内存时,需要设计一种好的算法来解决其对于计算机的实现问题,,及效率敏感问题. 因为它跟硬件和汇编相对接近最近,可以向后发展,而其它语言只能向后发展却不能向前发展..即使是在冯氏结构过时之后,C语言的地位也是最好的.嵌入式就说明了这个道理..因为C几乎能控制计算机内部所有离散(而PC应用就是计算机离散的向后发展,C语言的强大在于它是PC离散抽象的源端,可以向后发展.并可兼顾前面的应用开发,而Java早就抽象到后面去了),而Java,c++语言对应用的设计,解决的是站在人类逻辑角度的“设计算法”问题,比如如何进行架构设计才能更好复用以利于软工的开展,它的JDK设施,是一套充分考虑了OO与复用的编程逻辑体系,这二者所处的维度不同,决定了他们解决问题的目标与方法根本不一样..因此OO反而没有C的直接底层控控制能力强大(况且C有位操这样的东东)

C语言重点不是为了来开发应用的,而是为了开发跟计算机本身(远离应用业务)那一层面的逻辑(要说这是业务,也是系统业务).C++几乎是C的再造但更多的是增加,而同时作为Ｃ的替换(better c)与增强(OO,template),C++既可以面向开发Ｃ的那些业务(而且在复用上做得更好),也可以完全开发应用,虽然它对C的兼容性是天生的,但是C++又带有C的很多陷阱,这些陷阱一部分来自对C的better 改造,一部分来自系统编程本身,一部分来自C++语言本身的复杂细节[^7],平台逻辑和语言本身细节带来的复杂性是阻碍开发者前进的二个拦路虎,而且它的语法语义非常之复杂

###### 学习曲线的比较

对于学习的曲线问题,Core C的语法机制简单.是Ｃ进行实现和编程仅用到的一套语法语义.
在开发人员这端,C++代码复杂难解,因为一个会读C++源码的人首先要理解语言本身OO,才能理解作者要想在代码中描述的现实事物(机器逻辑通过C++对于应用逻辑和现实事物的变换),,,而这里面,有过多的代码逻辑的东西 (甚至过度抽象的设计手段)
C++在语言语法级集成的抽象就太多了(它号称多范型,不强求用一种范式进行设计和编程),而且它的库级抽象也太多了[^8],BOOST,编译期的泛型抽象,运行期的OO泛型抽象等,,OO抽象等,,无一不表示,与C比较,C++更适合当一门靠近应用的语言(只有高层应用要求如此之高的抽象,底层开发就要不得太多抽象,因为C就是对应系统的,无抽象必要),,,这造成的结果是要全面掌握C++要求人们掌握的知识太多了,C++的这么多因素使C++变成了多范型,完全密封远离低层(然而你要知道,抽象意味着对底层的迂回,对人类思维的靠扰,这迂回多了,对底层的访问就少了),,,,其实C++也明显没有损耗C操作底层的能力(c89),,,,但是C++的意义主要在于它的OO和模板导致的那些范式,它提供高级的语言级和库级的抽象反而对人们要求掌握它的成本变得过高了,(在提供的语法语义抽象方面,C只有指针,UDT系统,这些有限的东西,而C++呢,有OO,有Template导致的泛型和元编程,有STL,BOOST这么多
所以,对于有些人说的OO是种鸡肋和遗憾,到此如果你能得出自己的见解,那么你才算理解了这篇文章

better c,,better runtime based on os,,,or soft vm ????
-------------

C,C++,Java都是系统编程语言. 然而，**C++和java都不局限于仅对它们面向的“系统”编程**。JAVA天生是为internet编程存在的,它产生的历史就是受internet编程导向的,internet是有别于系统编程和普通编程的。

虽然都是通用语言,但C跟JAVA是二重天,因此对它们的开发理念完全不同,一个是面向本地,一个是面向人,可以不管OS平台的任何差别(这就是说不用学习程序运行环境给语言带来的机制问题和复杂细节,不用学习关于JVM的任何知识来进行JAVA编程,人们只需关注那些他们要完成的逻辑,而平台逻辑可以忽视不顾,因为JVM被移殖到任何地方时,人们将面对毫无差别的JVM和JAVA代码,代码不会因为平台不同而产生新的要解决的问题,,这是指移殖,,而且,要写JAVA代码,也不必了解任何JVM的知识,,因为根本没有必要为JVM编程[^9],,JVM虽然能给你进程,,给你SOCKET资源,但是在库中已经被妥善地封装了,人们对它固定了一个认识,,不必从JVM中再对它们经过原始理解,再引申为JAVA所用,因为关于这些资源的接口足够简单了,减少了人们对系统的理解,一谈到虚拟机的语言,就要明白这跟C,跟C++这样的面向本地的编译语言是二重天).

Java和c++都是真正的OO语言[^10],独立平台,然而它不是本地平台,一方面,不由本地OS直接分配内存,另一方面,它们是编译期静态语言,因此速度上会比Native普通程序慢好多(虽然也有JIT技术的支持),但是据称,,JAVA速度越来越接近于C++(不知道是本地C++还是C井,这里说的JAVA是指JAVA库和JVM的综合)

###### 提供虚拟运行环境与不这样做的对比

JAVA中,是一种综合了编译跟解释的合体,怎么说呢,首先,JVM能执行JVM目标代码,首先把*.Java这种高级语言源程序翻译为(这里是通过编译翻译,JVM中也有编译器支持)*.class这种中间代码,然后JVM中的解释器把*.class再翻译为jvm的目标码,这样就能达到二个目的,1比纯解释要快2使得JAVA代码能complilr once ,run once 总而言之,编译与解释只是翻译过程,是对高级语言码到目标平台码之间的一种过程称法,动态静态语言这种说法是指运行期,,静态语言也可以被解释(像JVM执行通过其内置的解释器翻译中间码再由JVM来执行),反过来,动态语言也可以被编译,

>.NET语言的公共语言运行时就相当于JVM,它们为一种语言或多种语言的代码提供运行的平台(比如运行时为它们分配内存,,普遍认为在.NET的运行库支持下可以运行多种语言的代码,在JVM下可以运行JAVA原生代码 虚拟机与语言的关系很密切,像Jvm跟Java语言的关系就很暧昧,有人说,Jvm虽然名为一个开发平台,但其实仿佛并非一个通用的环境,用Java对Jvm编程久了,会觉得像是吃饭的时候去了一家只提供一种口味的冷饮店,因为有些Jvm的机制,比如RMI,,只限于用Java语言去开发(故需要像JPython,JRuby之类的东西可以帮你改善下口味). Python这样的语言跟Java在出发点上还是有点区别的,Java的出发点在于跨平台,jvm才是Java体系的主体,而Python的出发点在于语言本身,所以Python的那种简单的语言机制才是Python体系的主体,Python从来不是平台标准,而只是一个语言标准而已.从Python vm太高级的那些指令就可以看出来.

net的虚拟机就是把所有的语言不直接放到CPU+OS这个二次本地上了(纯CPU是一次),而是放到了同一个虚拟机内这个三次平台之上.因此各种语言规范写出来的代码一者相对另一者来说是native的.可以共用一个类库,而Ruby,Java由于是从C发展而来的,它们只视C为native,如果是其它代码要为它们所用,必须改变别的语言中的函数入栈压栈规则,,,通过一种bind的技术改造..IT界的整合与分离无处不在

但是要知道,原生不原生是相对的概念,如果能在JVM上实现一个Ruby的解释器,那么Ruby代码也就是原生的Java代码, OS跟虚拟机的关系,比如用C(更严格地说是C的一个编译器实现比如MSVC,BC,GNUC)写出来的代码就是直接在操作系统上运行的(由一个叫运行时的抽象层向OS请求内存时空资源比如CLS的托管内存说法),,这相对OS来说,C代码就是原生代码,但是当为一种语言发明一种虚拟机运行平台时,这个抽象就大了,我们不再称这个抽象跨度为原生,而是过度了的原生,也就是说,不是原生,而是相对虚拟机的原生,比如JAVA代码之于JVM的关系 (在一台裸机上写出一个虚拟机才能调试代码和执行代码),并且直接在一个业已存在的OS上抽象出一个虚拟机实现也是可以的,,,因为这样可以独立很多平台执行这种代码,,这样做的目的(在业已存在一个OS的情况下)就倾向于"为了语言而创建一个运行平台"也即一定程序上"JVM是为了JAVA而出现的",而本来不需要一个JVM就可以直接在OS上写JAVA语法的代码的 ?那么JVM与JAVA解释器的关系又是什么呢?一门语言的最高级公民(first class)往往存在于栈内,比如函数啊,OO体啊,但是JVM又不是JAVA解释器,不属于运行时抽象也不属于OS抽象,而是编译原理抽象,学习的过程中,我们必须格定这种"抽象所属",才能

首先,它们的运行环境不相同,产生的目标码根本不同,前者是为机器加OS这个本地产生目标码,而JAVA为JVM产生目标码,由于这二个平台的不同导致的理念是根本的差别,JAVA不能称为系统编程语言,因为大凡提到系统,都指本地系统,即OS,C是编译成本地目标码的,而JAVA码只能称为JVM的系统编程语言. JAVA却根本不擅长操作本地,因为这是它的设计目的导致的(JAVA就是为了独立平台,使得开发时可以不管复杂的平台逻辑,而且即使是对JVM的平台逻辑,JAVA的那些库也作了很好的封装)
关于JAVA的WEB应用是发展在这个平台上的,JAVA变为WEB开发语言不仅仅是因为JAVA代码可以一次运行,到处执行，历来不是语言成就应用,而是应用成就语言,就像ROR成就RUBY一样,人们发现J2EE框架库的出现适合WEB开发于是就导致了JAVA作为WEB语言的流行,而且关于JAVA的库和先进的框架越来越适应Web开发,由于这个历史,天时地利原因,JAVA最终成为Web开发的主流．

###### 对于工程

其次,C在“语言级”能直接提供的最小复用单元上,C++可以提供类,接口这些的抽象,但函数只能是一种初步的调用接口,不是数据也不是类型,甚至不能直接表达实体,既使能也只能靠拙劣的抽象手段得到(就跟C++的元编程一样)

数据化,唯有数据化,才是计算机和人共同理解并加以利用的东西,才是软工要首先统一的目标所在 typedef int myinttype; typedef myinttype (*myfuntype)(); struct,pointtype,简单类型你指望c的这些“数据类型”成为软工中大量的开发人员理解并大量使用的东西吗,并以此为基础抽象大量复杂的领域逻辑?那恐怕是专家作的事吧,怪不得有本书叫《C专家编程》呢,而Java是平民语言!!仅仅懂得设计就可以拿来配置出逻辑的语言.
Ｃ与C++比较的那个问题,即OO最大的功劳不是它的三重机制,而是它桥接了现实和语言之间的映射,即使是大众也能理解并独自开发内含大量逻辑的软件,这是语言对于它解决与人有关的设计那些问题的本领,所以,如果大学是培养软件人才的地方,Java为什么没有比c很多的理由成为教学语言呢所以,Java绝对是很好的软工语言,但c不是

就提供的调试功能来说，JVM,CLR的确比pyvm之类的要好，就编程侧重于抽象还是实现来说，java,c#比C++，IRONPYW之类的要好。所以，JAVA,C#更适合工作更适合作为工业语言。
JAVA,C#比…的要简单


###### 学习曲线

人们说JAVA并非好的教学语言,因为JVM毕竟不是我们真实的系统,,它是一种架空的虚拟的完美的人工运行环境,而OS加硬件架构这样的本地才是我们要认识的本地(而大学计算机教育重点在于教育计算机系统的理解，其次才是编程，这二者前者是基础必不可少),当要设计真实系统的时候,Java的那些设计思想根本派不上用处(是一种过于迂回的办法)..所以C跟Java的理念是二码事,前者解决实现,后者更多地面向人解决复用.在下面一节会进一步谈到.
通常用一门语言写出来的程序都被用在诸如Ｘ８６加OS的架构上运行(平台移殖或编译通过时,我们总是说,在某某某架构上加某某OS上编译通过),当一门语言为了实现跨平台(一般是跨硬件架构,硬件掌有真正的运算资源即芯,而OS核心将硬件能力供软件服务,包括进程,等,对一台裸机编程就是汇编了)考虑时,

>对于学习曲线问题(Java和C有有限的语言机制和学习成本).其实Java这样的语言因为面向Web,面向业务,,,它要学习的东西反而更多更难,,,学习Java,如果不学Web,这几乎是件可笑的事情,可是Java易学,Web就不易学了,JAVA后面的应用问题永远有新的东西需要被学习,,因为JAVA后面的东西是异常灵活的高层应用而非固定的底层...面临的问题永远有新的解法,WEB领域永远有新框架新理念甚至新语言的提出.. (Web问题和系统问题是一个不断可以深入的话题,需要新的语言机制的支持),,Java和C解决的问题永远没有一个头,,永远都可以是新的话题..因为应用无形而语言有形 在C的时代,我们以为语言细节和系统知识才是难点,,在提供了VM式OO语言的时代,我们却发现设计更难.应用更难,如何开发被别人复用更难,如何复用别人的逻辑更难,一个时代有一个时代的问题 这就是说,抽象远离了计算机底层,,在高层又变得异常灵活和难于掌握,, 这就跟C一个道理,,C易学,,但C面向的系统问题涉及到大量数据和算法,又显得很难,,,如果学C,却不是为了解决系统,这又是一件可笑的事情,,,永远不要以为学好一门语言就是全部目标了 懂了C,却没懂系统底层一样没有用,不懂数据与算法也没有用,因为C就是面向并开发这些的 但是C语言要解决的问题永远是底层,系统永远是简单和形式的,大不了把数结与算法学精.学透,把系统本身学透,,C的开发就到家了,学好C语言在于将C语言包括指针在内的所有语言机制习惯用法,跟数据结合和算法的结合,,C用于实际问题才是重点要学习的,就像我们学习其它语言一样,都要保证自己做到:我们是在遵守大传统,大方向学习,而不是一味去钻那些不实用的tricks(有些甚至是语言或工具的workround,临时策略).

所以我说,,,其实Java比C难..!!!!! 似乎有人嫌Java过于简单,而且非C++不能体现他们钻研到底层的精神,要知道语言级的形式才是羁绊,现实问题才是复杂和急需解决的,如果抱这种习惯久了,就出不来了 不要去干追逐技术的蠢事,,你只是用户,,只需学会一门工具开发,但是也不要走入另外一个极端,就像我崇沿Ubuntu,我并不会动则就把Windows和Ubuntu作一个彻底的分离,并一有时间就抵制Win并使用Ubuntu一样

C++语言体系的确比其它语言复杂,然而如果真的想做程序,却担心连C++这样的复杂性都把握不了,那么不如不做程序.其实,通过改变开发语言而改变开发上的难度与方便性,其实正说明了这些被发明的语言(Python,ruby,java,etc..)不够通用[^11] (它们都强烈服务于某种领域逻辑,而且有某种速率上的缺陷.功能大受限制),而C++是一门通用语言(无论从哪方面,它都平均,而且面面俱到).正如C++之父说的,语言应通过扩展库来扩展它的功能(设计能力和逻辑表达能力),而不是扩展语言自身,而且,C++有从库扩展有它自己的绝好优势,这就是模板,它可以达到“给设计建造一个统一的层面”的目的,而且可以以类脚本语言弱类型的形式和自然语言的形式进行.

>Todo:这段移走 C有全部的离散而RUBY相对来说就少点,没有指针这个离散因此C产生RUBY,而RUBY只能BindC,RUBY不能写我们现在能看到的WINDOWS(因为它关于C的底层用到指针),而C可以出RUBY. 所以,业界一般使用二种语言,一种作为实现语言即系统编程语言,一种作为设计语言,即脚本语言. 1,OS用LINUX内核+Ruby shell,比如Ruby,底层开发一律用C,比如驱动程序,游戏底层硬件渲染,RUBY可方便调用C,而且直接用于硬件编程时十分科学,比如embed c,C的运行也十分快 有人会问了,当RUBY BIND C时,那难道C的模块不也成非本地代码了?其实不然,当C模块被BIND时,它只提供一个接口给RUBY使用(只是在RUBY这边产生了一个使用逻辑),真正的执行体(被调用者)还在C模块中,还是native code. 2,RUBY与C混然天成,当作高级非系统编程时,应把它变为一种SHELL加通用编程语言..让RUBY也同时成立软工时代标准语言 C面向底层,很好地解释了学习一切C泛化出来的其它语言的底层知识,比如字符串,比如IO,比如进程,线程,对学习是极为有利的,而RUBY

###### 函数式与过程式的比较

举一个例子,再比如虚拟现实领域,,一个“虚拟世界”这个说法是用OO来表达呢,,还是用LUA的具体语言机制来表达呢还是用语言实现的某个库逻辑来表达呢[^12],那么“虚拟世界”是用语言语法来表达呢,还是用库来表达呢,,是用语言的OO机制来表达呢,,,还是由语言的一种更好实现的机制来表达呢??[^13]这就是语言机制基于应用的要求(还比如,只有在提供有指针,引用的类C语言内,才能表达出OS所需的句柄之类的概念).. (C的抽象在于抽象底层机器因素,提供程序员可见的那些稍微高一层次的因素和机制,,这就是抽象,,对于人的靠扰,C的接口在语言级的细微度接口主要还是函数级的接口,,编译器级有.out文件,,,底层=算法加数据..接口提供了功能模块如何交互和复用的机制)
对于最真实的机器逻辑,只有机器语言是最直接的反映者,C语言毕竟还属于机器语言的封装,,它也并没有反映绝对真实的机器逻辑,除了它的指针和用指针表现的东西,,因为它终究是某种抽象品,比如C的函数,所有一切语言的子过程,在汇编语言和机器逻辑中不存在这样一个概念,函数和子过程相对汇编语言来说就是一种高级语言机制,而并非想指针那样的底层相关语言机制,而C++就更是差系统底层远去了更多,C++除去C的那部分语言机制,比如OO,只有当它封装了C的函数时,才能控制底层,否则C++根本不能称为系统编程语言,还有STL这样的机制,,根本在系统编程阶段用不着..

再比如JAVA,,提出了很多语言机制,,也是为了能更好地远离本地发展抽象,,,它把什么都OO化了,这很利于对开发人员的抽象,但反而对一些迫切需要底层能力(比如指针和设备驱动开发)的应用没有利用之处,,,
就像在理解Delphi为什么能提供过程内过程一样,为什么函数语言可以避免不用设计模式,为什么函数范式的语言可提供eval函数(流程控制,等都是语言间通用的),为什么动态语言适用于WEB开发和XML结合,线程和异常．等等,这是因为语言也是抽象品,在它上面可以构建其它高级抽象,但是如果能了解一种语言抽象的得来过程,那么许多问题也就不问自知了(因为抽象跨度很小,中间很多的透明抽象现在可见了)．学习一门语言的好方法是学习它的抽象由来．．虽然这是个巨大的学习过程,涉及到很多其它非程序语言编制领域的抽象．．
当然,如果仅仅是想开发一个应用,那么不必了解这么多,有人不理解STL的设计原理和架构,照样都可以用STL技术快速开发,有人对JAVA不必作如上我们所涉及到的分析,是因为每个人都有自己维度上或科学或不科学的理解(有人甚至因为JAVA是编译器哈),正确的思想级的理解对开发不是一定必要的,所谓死读书也是有用的,不一定要理解到那个层次,能学会使用就够了,细节永远是重要的(有一句很出名的话:别无它,唯手熟耳),与开发应用最结合紧密,但是思想和学习方法也是重要的,我以前看过一本参考书,因为把所有的知识来源都理了一遍,抽象达成从不大的跨度说了一遍,比纯粹的一堆细节性的教科书更能让我明白很多东西,也即,细节不是一切,只是关键,思想仅仅只是重要的.

在C时代(也就是汇编后时代),CPU内置了操作码指令码,又提供了对内存和寄存器的控制,因此程序=数据+操作(换言之,计算机再怎么样,在其内部都是用操作码操作数据的机制).以C中对数据还进行了结构体这样的封装,后来数据经过了CLASS抽象和封装,一样都可以最终解释到这个机器过程(只要它是某种运行期语言).

###### 动态式与静态式的对比

但是不要认为动态语言就能提代OO静态语言(这种说法真可笑,复杂性有它的好处,复杂性同时也是相对的而已,RUBY在一些领域导致的复杂性比起JAVA来说会更多,只是不同情境的问题而已),哲学指出,任何问题都要实事求是,我们需要在问题需要什么类型的语言才去考虑选择什么语言,,考虑一门语言优劣时,并非纯粹技术问题,有时是多维的问题,,比如语言的优劣还得用它适用不适用软工这个指标来考虑呢

还比如JAVA的动态机制(反射加代理),这种历史复杂性是为了实现动态语言的"由行为决定类型",,,这就是AOP,,JAVA居然站在它本身是个静态语言的基础上去做动态语言做的事,造成了很多历史复杂性,讨厌

而且,RUBY这些宽形式,自由的语言,正是因为太自由了,就像C语言一样,太自由,反而不能成为软工的首先,因为软工要解决复用和简单意味着统一的形式的需要,即编程语言的离散形式和人的关系(所幸RUBY本身也提供了OO)..

所以,JAVA在WEB开发中,OO以后的那些WEB框架,是现实所导致的,并非JAVA本身导致的,,,改变J2EE框架就行了,并不要把JAVA改造或加个JRUBY就行的,,,相反,我们应更多地解决现实世界的思想模型,而非增大或扩展JAVA或JVM平台自身,感觉在JVM上集成JRUBY实在是个蠢的作法,凭空增大了抽象和运行时开销,就像把车拆了放到车库里明天又拼装起来再开一样..

C++与Python的比较
-------------

在本书第一部分第五章《真正的函数指针》中.最后一句“这样的语言留之何用?其实我的本意在于表达:“C做做系统还是可以的,然而处理高层编程,比如web就不太好了”
因为C是文言文,Python是白话文,而我们是人

事情总是往高级的方向和抽象的方向上发展(从本书开头导读到这里的结语，我们一直重复着各种抽象过程和享用着抽象的好处),因为我们是人,不能和机器处理细节的能力相提并论.就像文言文一样,它灵活和绕之又绕的用法就像极了孔乙己说的“茴香豆的茴有三种写法”, 文言文,Python是白话文,而我们是人文言文是一种低级系统，其词汇，语法等都是低级的，在语法方面表述过多，是特定历史条件下用的，现代，出现大量新事物这正是白话文的用武之地，白话文只提倡一种通用的用法,即Python所提倡的“任何一个事情最好只有一种解法”c太拘泥于语言细节和平台细节,而Python极力专注于高级的应用(在后面的介绍中你可以不断看到,在Python语言中有很多高级语法机制,甚至设计模式),而现在的web开发,需要语言提供直接而显式的白话表达方式(派森的另一特点是其自然语言特性,即文本处理厉害比如语言直接支持正规逻辑和高层设计模式,适合做web)

###### batteryinclude 与非batteryincluded的区别

Python强调解决任何问题都应只有一种方法[^14],Python中看不到像C++和C中太灵活的语言机制,甚至大量的Tricks[^15],用Python表达应用的习惯用法(那些被称为Pythonic的东西)是平滑的,人所共知的.这对软工来说是一个无比有利的因素.
c,c++都有他们的理念,c++之父说“c++的理念在于多范型开发”(原意大概如此),而派森的理念是“一定程度的自然语言编程”(其前身就是某种abc语言),用这个理念可解读派森的一系列语法机制,在派森中,元组和语法糖,都是无比厉害的猛药, 是一定程度自然语言编程, 仅有的复杂性都被极力而蓄意地掩盖了,这几乎是条主线,我会一一谈到. 我们注意到在派森(语言和标准库)中,除了字典,字串这些数据结构方面的逻辑外,就几乎没有其它的比如树,图这样的数据结构的直接实现,这是因为树图都是底层的数据结构,字典本身就是由这样东西抽象而来的,这说明我们往往从来都需要高阶的那些数据结构,这也说明,派森很高阶,甚至将数据结构这样重要的编程手段都将其极力抽象化到不需要编程者掌握.用字典数据结构表所有的东西,同时做到了简单,统一,而又不失强大性,,所以这是好事呢?还是坏事呢?语言的功能是不是被削弱了呢?
其实不是好事也不是坏事,你当然能够封装c的那些底层数据结构实现库来作为派森的逻辑,不过这样的话,你其实已经走出派森的Pythonic的范畴了,因为派森本来就只提倡用那些高阶的逻辑编程.虽然因此派森显得不够强大不能向低级发展[^16],但如果你真的大量需要那种一切从头开始的语言和逻辑,那么只能说明,你需要c,c++这样的语言胜过语言派森.(c的缺点是太不抽象了,但可以向后发展,派森的缺点是太抽象了而且这本来就是它的特点,不能向后发展,然而它可以很好地向前发展,因为它的姿态本来就站得很高,比如c和Python都有时间库,然而派森可以直接用tuple提取出需要的时间,而c还得自定义时间的各个字段,虽然可定制性很好,然后事事巨细都要自己动手,只是专家的做法)

>还比如python的zipfile库,ftplib库,它的open(),ftp(),等方法,非常抽象,这就相当于shell调用os,我们知道shell也是一种编程(功能调用的方式,这些调用方式非常接近应用),而py的这些库,让你用直接调用这些功能,这就使编程变成了一些对OS的应用能力.其实,编程会越来越抽象,最终的编程是对库的一种应用能力.而不是像C一样,什么事都要从基本类型,数据结构,算法而来,事事巨细.

Duking type在Python这样的语言中是天然的,而不需要C++强类型语言中,用模板来模拟的那种吃力的方式.



为什么选择.net而不是java
-----------------------------
 
首先： 

1，.net集合了RAD元素，如事件驱动，可视化组件编程，这对于降低新手的入门台阶是一个很强大的工具； 

2，其次，.net的rad元素，其实也是软件工程的极大化的表现，在计算机领域，提供对该领域的建造支持工具是很流行的现象，比如，photoshop之于2d图像处理，maya,3dmax之于3d视频处理，warcraft editor之于war3 map making，这些都是某些特定领域的例子，但其实这种“支持人以可视化的方式建造复杂领域逻辑”的方式（它是一种由低层理论到高层可视实现的工程过程和工程手段），是涉及到“人的设计”的所有领域都应具有的，在编程界，IDE，OO都是这种例子，如果说IDE是对开发环境的设计，OO是对编程范式的设计（更多不同层次的编程设计手段和工程手段你可以在我的《编程新手真言》第三大部分设计篇找到），那么.net的RAD，即是对“降低新手入阶难度”，“减少老手重复劳动”之类的设计工作的工程支持。 

故.net的rad元素，其实是无比珍贵的东西。而java中，这种支持除了swing之外，几乎在java的其它部分（如web和ejb中）不常见到，而.net的rad在console,winform,app services,webform这些.net重要的编程模型中都存在着。 

3。另外.net的集成度的确要比java高一点，这种集成度降低了程序员理解编程的难度（因为分散的元素被整合成了一套相似东西）提高了编程效率，上面谈到的，.net将rad元素应用在从console到webform的所有方面即是一例。这是一个很鲜明的例子，另外，.net提供的类库中，是很多元素的集成粒度是java所不能比拟的，比如.net中对于各种不同语言的支持(cls,system,runtime,compiler sevrices,interop services)，这根本上是因为.net定位于“一种跨多语言的跨平台”，而java要偏重于定位于“单语言的跨平台”。


python与javascript的比较
-------------

js的原型是cmm，一种旨在简化C++的脚本语言(因此它有过程式，也要具有动态性语言的特征，动态语言是天然的范型语言，故js又有范型编程方式。)，它面向非专业程序员的用户，故入阶简单（这点在结合了dom的web cli事件编程领域就能看出来，因此它有事件驱动式范式），与py比较，因为它没有在C系语言的基础上增加“元类，属性分流”这样的东西(而是直接利用表达式计算这样的过程式语言本身就有的特征)，就实现了脚本化C系语言的基于对象或面向对象特征(因此它也有对象范式，python和objectiveC都是与js在目的上有统一之处的语言)。

另外js的原型还是schemda,self这样的lisp变种语言[^17] (其函数式也是通过表达式和函数来达到的，就跟其达成OO范式一样，**因此js的元语法就在于其表达式，更准确地来说是过程式**)，此类语言通过函数和计算可以消灭过程式语句，这是函数语言的基本特征，因此js也支持用函数范式编程。因此说js也有复杂的方面(即函数式，函数式语言能很好地用于并发，因为它的语法单元的原子性和可计算性，因此js能很好地用于并发范式)，这使得js可简可繁，要编复杂的程序，就要掌握js的高级部件，但是js的主体还是其过程式(这符合js是简化C++，为用户准备的脚本语言的目的)，其次是对象式和函数式。

web的原型是server端独大(C++,dephi等isapi编程)，客户端只是简单的html标记逻辑，所以后来会将一部分工作分担到client(以前是用猫上网的时代，客端将填的表单填入发送到服务端审核，要等个几分种才收到“你的电子邮件格式不正确”这样的消息，这种情况明显是不合理的，故这部分任务本来就应是客户端的),这导致产生了js,这也是所有bc(bs是bc的一种)架构的软件所遵守的原则
Python定位于通用语言，它装配了很多库（battery included），由于是通用语言，它有别于javascript这样的非通用语言（虽然javascript跟python极为类似，但至少有这么一点不同，javascript一开始就是被作为非通用语言这样被设计的，故没有明显的IO，一切依赖于被运用的宿主，即脚本环境。 这就是通用式脚本语言(侧重利用这门语言作主要开发)和嵌入式脚本语言（侧重将这门语言作为表达另外逻辑的辅助）的区别。


###### 真正的OO与原型继承的对比

py用元类解读OO，这显得庞大而又费读，好的软件抽象应抽象简单，尽量用已有概念设计，这点js做得很好，因为它用表达式这种编译原理内部的过程式机制来解读OO，而且做得很好。


###### 跟web开发有不有关

搭上web的战车

###### tag language

这种情况一直直到后来，我发现有些语言具有“tag language”的特点，就像xml是关于文档语义的tag (or marked) language以后，我选择了在使用C，C++外，还使用一门脚本语言，这就是javascript，我预感到js这种”tag language”会有很大的发展前途(参见我关于对元语言和元数据的解释，在设计那一部分)，为什么这么说呢：

rwc,ria大战中，rwc优越明显 js本身的声明性语法就有tag lanugae的特点，编程查看效果时可以很方便，再加上jslint这样的东西，在编译时也可以跟静态语言一样严格。 js中有一派commonjs中的nodejs正蓬勃发展，很多人为它贡献了模块。 对于gui,webkit所渲染的html gui一直是前端web的主流，这也是nodjs这样的项目没有明显关于gui的模块的原因。 qt中的qtscript,qml等东东,js与mysql集成良好，而mysql中的sql脚本就是一门明显的tag language,比如其select * from * where *语法。 3d游戏开发中有有unity3d，它使用js作脚本语言，还有dxstudio这样的东东，也许有一天我会将书中所有关于py的部分全换成js,以配合game making那一部分使用脚本语言的需求，届时可能使用js而非py. js中的数据库有sql,文档数据库等等。
Js的事件机制源于跟.net一样的目的，即改造对象交互，消息发送的方式(js采用了事件触发，而非.net的代理消息机制)，因此这种trigger机制，实际上是将设计和visual OO集成,当它运用到界面开发等强烈用到OO的地方，可以让设计者提供一个回调函数，形成了跟js一样的事件驱动机制。

**js的对象更应被称为udt**,它包含函数udt,数组udt,对象udt，在js的源码实现中,js是用关联结构实现的，因此它用来实现udt的数组就带有关联数组的痕迹


###### 不同集成度之间的对比

xx

银弹问题思考
-------------

银弹问题思考(2)

抽象给人带来的好处和坏处并存,对于多人合作的软工项目来说,一些语言的机制是禁忌,比如模板,他越抽象,就会造成越来越大的混乱,OO虽然统一了代码形式为类,但并没有统一设计和抽象的方法(在同一个应用中,有人会写迭代器,有人会写阿猪阿猫).所以OO并不是银弹,银弹是那些能统一人类思想,形成契约文化,经验的东西(比如我们写小说的那些套路),而不是简单的class这种面向复用的小技俩[^18]. 而在软工界,除了OO,实际上还存在很多很多其它的过度抽象.
对于一门具体的语言来说,只有将其实现语法和设计语法[^19]彻底分开,然后弱实现强设计,银弹不是那些对实现的深入,即那些对语言内语法机制的完善,而是对设计的深入,对独立于语言之外的那些东西towards programming的设计,只有统一了设计的方法,并将其深入到一个很深的境界(比如在设计层增加抽象语法,设计语法,大粒度的逻辑 – 框架与库,对二进制构件的支持),这样才能一步一步到达银弹

总结：
-------------

其实就语言本身来说,并没有汇编,C,C++和Java,Python,Ruby这几个语言之间哪个语言绝对要更强大一点的说法,大凡用其中一方能实现的功能,用一方都完全能够抽象得到,Java所关注的Web编程领域,C++完全可以提供同样的功能实现, 只有抽象完成,整个Windows系统都可以用Java来写,这就是说,在软件的抽象里,任何事情都可以以抽象叠成的方式来完成.但是,“决定用什么语言干什么事”这个前提是“它善于干什么事情”,而不是“能不能”(而这,是由应用本身和人的要求所规定的),所以显然地,在Wintel上装个Jvm,再用Java实现个Windows,这是个傻瓜行为(舍近求远而且有应用的瓶颈问题存在).比如用C进行C++能很好工作的事,这也是个傻行为(仅仅因为C没有显式的OO设计手段虽然它可以抽象得到) 一门语言提供什么机制,,是由它能表达的应用逻辑来决定的,历来是语言适应并决定应用,什么语言开发什么样的逻辑(人,应用逻辑,语言及其机制永远是三个相互依存的矛盾,应用逻辑要求语言提供什么样的逻辑,而人开发应用逻辑也要求语言提供靠近人的机制比如OO,,因此用该语言开发的逻辑都可以用这语言本身的机制来解释),比如JAVA适合做WEB,LUA适合做游戏(因为它的协程机制),XML适合做数据(因为它提出的元数据理论解决了浏览器文本交换的异构,并一度深入到数据库领域),比如Windows是用C开发的,那么C的那些语言机制就可以用来解释Windows原理的一切,,有一些应用,是受编程语言的能力直接影响的,比如,强编译期语言不能写corba,无运行期侦探能力的语言,不好写数据库这类应用(因为此类应用要求编程语言的程序,必须将一定语义维护在运行期).
但是，各种语言提供的各种语法也确实有对比的效用，比如除非对C++本身进行改造,增加如Ruby那样的新语言的新机制,让C++成为容纳一切范型的多范型,否则它并不能直接实现很多Ruby能干的事情(RUBY构建在Ruby虚拟机上的OO机制和其它语言机制多了去了,比C++简单但比C++的那些范式强大,比如C++的模板,虽然可以让C++带来ＧＰ,但是Ruby的ＧＰ要科学和有效得多,还比如JAVA用反映和代理技术去模拟Ruby的动态语言性质),

这根本是因为应用太多变,而语言适配应用的工作永远只是疲于奔命. 什么样的应用用什么样的语言,所以需要知道达到什么样的逻辑就要选择好语言。

其实以我来看,所有语言都是一种形式,要解决的问题才要弄明白,如果这种形式不能表达更深的问题,那么问题就出现在形式上,,,,OO最大的特点不是继承,不是多态,而是"OO接上了计算机离散和人的思想中的因素体,促成了软工时代的出现" 所以,不要去为了技术而探索技术,,,现实世界才是我们要最终解决的问题,而不是那些表达现实的形式语言..语言终究是形式.技术问题的复杂有时是历史原因导致的,,,,细节和理论,形式和应用,,是二个可以并行发展的维度...其中现实应用更重要...RUBY声称它能提供编程对于的简洁性,这就是一种很好的作法.
你该选择什么语言,这最终决定于你要干什么事,尽管谁也不想浪费精力花费时间却发现学了一门不太讨好的语言.但是千万要相信我,没有通用永远有前途的语言,永远没有最好,问题的本源只是在于你要明白你的需求在先,而不是语言,很遗憾给了你一个几乎没有用的答案,我们将在接下来讲解。

>语言的协作实际上永远大于它们之间的区别，这是因为开发是分层次的,这些层次是共存的,各种语言都不是用来相互替代的.而是协作解决问题的,py替代不了c的地位,甚至替代不了c++,所以,我们学编程,其实是C,C++必须要学的(只要你在那个领域开发.).而不是学了py,就不用学其它的.

那么你到底需不需要一个VM式的语言呢,首先如果你是作本地开发,虽然VM式的语言可以通过JNDI这样的本地接口和BIND技术来进行访问,但终归是一种绕之又绕的方法,而且Bind和改造技术也不是万能,有时你并不需要全部的原语言的逻辑,此时你需要定制Bind来调用你需要的部分逻辑,这是第一,第二,带了VM作执行环境的语言过于宠大,当一旦有这种语言写成的源程序当被执行时,其执行效立造成的影响不容小观(比如游戏开发,在一些实时碰撞和消息互发时要求不要有迟缓,Web除外,Web的瓶颈不在IO) 第三点,要搞清Ruby等这些语言的目标,Ruby被设计成通用编程语言,但是更接近一种DSL,它就比较适合搞Web,
那么你到底需不需要一个动态语言呢??动态语言就是在写代码的运行前编译期不需要为变量指定类型,因此类型宽松,写作起来不需要考虑类型之间的静态期转换,只需像对待普通简单类型变量一样对待抽象CLASS类型(变量),源程序可读性也很强(因为没有很多关于类型约束的逻辑和信息),但就是因为类型信息在运行期,因此在编写时IDE不能获取到正确的类型信息,这给编写造成了一定的麻烦．
那么到底需不需要一个解释语言呢?解释语言就是边翻译边运行,程序可以被实时调用,这几乎是脚本语言的一个通用特征(一般脚本的意思就是通过一个Shell调用,Shell就是解释器,脚本这个说法相对于系统来说的,实现比较简单的DSL方面的东西,系统编程语言是通用的,那么脚本往往实现某个领域的逻辑,比如文本处理,但Ruby和JAVA走的都是通用脚本编程语言的路子),类逻辑可以先存在于持久化状态,再被实时加载,每一句新写的源程序都可以被即时执行．
那么到底需不需要一个类RUBY语法机制的语言呢,如果没用到协同线程,那么Ruby中的Coroutine你就用不到．如果这些都刚好对应上你需要的功能,而且上面提到的其它方面都基本满足,那么Ruby还是比其它语言要适合你的． 因为脚本就是要实现一种DSL的东西,所以Ruby即使很强大,Blizaard还是愿意用Lua这样的东西,困为Lua的一些比如协同线程很适合游戏开发,而且Lua不必通用,而且游戏就是要轻量的VM,脚本语言的本质决定了它不好被发展成为一种通用语言．
没有一种通用最好的系统编程语言+通用的最好的脚本语言,不要去寻找它,因为历来都是应用决定语言,而不是语言成就应用．．

[^1]: 比如以前的lisp机,参见死亡计算机协会

[^2]: OO引进了编程向人的思维靠近的理念,是一种抽象,它假定人们只要理解了OO,就可以仅在这个层次上进行编程工作.

[^3]: 还有一种C++叫ARM C++

[^4]: C++是C89的超集,当你手中拿的C++教材没讲基于过象面向对象和模板并且你需要的不仅是一本C的教材时,你可以现在就扔了它

[^5]: 编程应该是死的东西,把语言中那些机械的东西从人脑考虑的必要中去除,而C和C++的罪恶在于使它变得很灵活,而且会产生各种各样的陷阱

[^6]: 当然,有人可能会对我使用这个字感到反感.也许这个字换成“谈化”了更佳,其实,计算机开发界的事,没有过不过时的,就像C++和JAVA,当回到本地时,用C++解决那些问题依然是主流,有它用其它方案解决时所不具有的特定优势,这是历史发展所规定的,而新的发展,如JAVA也有桌面版它也能做C++做的事情,但总存在它某方面的缺陷性,开发界在提出新的解决方法和解决理念之间,从来都不是一上来就以后者替换前者的,而是互补的,作为可选方案存在的.语言选择也如此.

[^7]: C++的库并没有把平台复杂性封装得让开发者可以不管它,而且语言细节带来的复杂性比如指针是用C++这样的语言让程序员自己维护类型的语言进行开发永远不可避免的,而实际上程序开发只需要值.类型只是设计接口才需要,或者为开发中的调试才要,如果不存在安全上的需要,类型就是一种语言的累赘了

[^8]: C++虽然在语法上提出OO,泛型,解决了“怎么写”的问题,然而,对于“写什么”,即对于库,C++走错了二步,而且都是历史性至关重要的二步,第一步,它没有及时(及Java之时)地提出一个对于应用的标准库,而只是初步处理数据结构和算法的STL库,第二步,它后来提出的BOOST等准标准库虽然对这些应用有涉及,但依然显得很零乱而且是用高抽象的模板写的.

[^9]: 除非是C的扩展.Native dll

[^10] C++有运行期多态,这集中体现了它的面向对象,,是用虚表这种不直接的方法来实现的,这就是C++面向对象的精粹,是C++特色的OO,相比Java,.net来说,它们一般被称为真正的OO语言.因为它们的类库是严格被规范了的,是语言一产生就作为标准出现的.

[^11]: 汇编除外

[^12]: LUA毕竟还是属于语言,可能在库级逻辑提供对游戏的支持,并不直接在语言机制里,,即它的语法支持里支持游戏逻辑,,因为它还是属于不同于SQL这样的高度面向领域的DSL语言的

[^13]: 诚然,OO作为语言机制能够表达一切,比如“虚拟世界”,但那是代码结构侧面的,而且并不总是直接的好方法,有时对于一个特定应用逻辑,LUA可能提供了一种更好更快速的语言机制,或库级逻辑,,反正要记住,OO并非一切

[^14]: 这就相当于一家冷饮店,虽然它供应的某种冷饮很好吃,但其长年累月只供应这一种的现象,比如,由于jvm对于java程序是不可见的,所以他们不知道如何“判断一个字节有多少个1,并且做到尽量高效”诸如此类问题的最佳解法.java给程序员一般解法,同一种手段的同时,也使得java程序员很被动,很单调.

[^15]: tricks往往是钻牛角尖的用法.是Pythonic“每件事都应只有一个解法”的理念相抵制的,它会造成代码的混乱,是软工的大忌.对于学习,比如对语言的学习,本书一直以来都强调应把学习传统正规的理念作为着重点,而不要一味钻tricks.除非你有多得花不完的时间.

[^16]: Python的用处之一,就是作为一种可抛型的,一次性的“快速原型”语言,再用c++等实现.

[^17]: js之父说它是c与self一夜情的产物，因为发明js只用了大约一天

[^18]: 当然,作为一种可工作的形式,它实际上,跟“形成一种规范,契约”是统一的.就像中西方尺寸,人们明知道不同的人有不同的尺寸,即便大楖起来也不会准,但人们还是有《中西方尺寸表》,因为它仅仅是可工作的参考

[^19]: 设计和实现的区别,可以参考整本书的组织《第二部分:实现编程》,《第三部分:抽象编程》,《第四部分:设计编程》,可见,任何语言都分三个层次.至于抽象编程层次,可以整合到设计层.开发分执行层,语言层和用户层,那么语言层就分这三个层次.