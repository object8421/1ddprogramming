



抽象
-------------


一般而言，抽象都是为了人服务，为人而抽象。抽象是为了简单化,抽象=对机器的简单性=对人的复杂性

>设计的第一步是解决将问题由大分解为小的复杂度问题,然后才是是解决像不像的抽象问题,然而这二个过程也是可以统一和整合的,比如OO

那么,为什么需要抽象呢?
首先,计算机科学和编程是一门复杂性很高的科学，人脑往往不适于长辐记忆或直接面对复杂的二进制底层,人们在面对根本无法控制的事情时,往往把它们转化为另外一件可控的事[1. 我们固然可以在会编和机就操作内存,而不借助OS和C来实现算法,甚至实现复杂的应用,但这相当于在黑夜中做一件极其精细的事,不但工作量大,而且这个人本身必须是大侠或夜的精灵],实际上，抽象是人处理任何复杂事物的通例，对编程的抽象正是这样一种方法,它可以隐藏低级层面的复杂性,而在另一个层面上提供新的更为强大的能力.再在这里抽象上构建更为高层的抽象,**即抽象只是把问题变了个形式[2. 顾名思义,抽象抽象,抽取事物形象的一面, 计算机可以记住那么多抽象,而人只能记住那些对我们有利的,简单的东西]，进行了一个层面转移和注意力转移**,抽象完成了之后,只要不是过度抽象,那么所有后来的事情都是另外一回事了,比如抽象了数据类型,那么关于数据的逻辑都成了数据结构学了,再比如OS对硬件的封装就把所有硬件上的工作搬到软件上了.再比如语言的类型用来抽象表达一些数据(类型)或事物,我们就在高级语言上工作了.
其次,**从问题到解决不是一步而就的,所以需要建立中间层**,先完成这诸多中间层,当中间的逻辑被解决的时候,事情自然就变得简单了(从这个意义上来说,世间一切软件都是抽象品,软件即抽象),比如OO,一个大型程序可能包含成百上千个子逻辑,如果是一个人,他可能理得清但是可能写不完,对于多人共工的软件来说写得完但是不一定大家能对这个系统共享一种认识,所以一层一层通过OO来建立抽象(每个人都应管而且只应管好他自己写的类,而且仅复用别人的应透出来的接口 C 这二种动作都是使大量逻辑组成一件有机软件的情况下,使各个小逻辑能做到自冶,以把复杂性分摊到个人和类,类的复杂性总比整个软件的复杂性好控制,是吧),先类化小逻辑,另外,OO还是一种对数据和代码进行统一抽象的方式..这样代码不再是数据加语句,而是统一的类了（这就是OO中的抽象）.你看,事情越来越清了.
**抽象是解决移殖问题最好的方法**,抽象源于一个简单的事实,把事物从逻辑上分开,这样就会解偶它们之间的联系.只有把接口拉高,向高层抽象,那么就可以忽视平台逻辑(实际上正是正面绕过),比如Linux下一个底层函数是a(),Windows下一个底层函数是b(),为了在我的库中实现一个跨linux和Windows的ab(),我就需要在ab()内封装它们,这样复用我的库的用户只需要ab()这个高阶接口,因为这个抽象,我的库就可以堂里而皇地被称为跨平台(实际上是多平台).其实不只是移殖问题，任何软件扩展问题(应用上的,程序本身的)都可以用抽象,增加新层面的方式来讲解.

为什么需要抽象呢？这也是封装的需要,因为**任何时候。我们都不需要抽象一个库的全部**。所以抽象的一个特点就是择部分封装。

抽象即增加层面，对于软件工程来说也是至关重要的，首先，增加新的层面可以使本质为抽象聚集的软件体系进行抽象分层，分开了抽象的软件就利于复用，因为可分才能合，而本来就合在一起的抽象不利分。

**抽象使domain programming变成programming**，因为可以使领域知识封装为高层几条可控的概念，它隐藏了复杂事物内部的情况，程序员不必理解一个领域的方方面面，就可以对这个领域编程（在有人提供领域逻辑支持库的情况下）

也即，**问题域和方案域之间，在有了封装库的前提下，程序员工作重心(他们更关注于)移到了方案域，而不用真正理解问题域**。
在架构[3. 架构是抽象体系的上上层部分,是抽象的模型]中,抽象也是很常见的,比如七层模型(这样的东西称为协议栈),只有解决了前面的问题,才能着手下一层更高级的问题,这是目的也是原因,,是起点也是下一个终点.

>>抽象与软件

软件的品质在于可复用，好用，保持工业和教育上的简单一致。

编程的复用，还是教育上的曲线的降低，简单才能更好被复用


无可置疑地,程序员有时不但要管抽象,,而且要管方案,,,,这根本上是因为软件问题是由应用出发到语言抽象的一条龙,一个处理语言抽象的程序员必须跟处理应用方案抽象架构师配合,,否则无源之水的设计,或无目标的设计,是很要命的.这二种角色不是不可以分开,,它们的重点意义在于它们的配合.虽然分开也是可以的


提供足够通用的抽象,,和解决更多方案的应用.而不是一套有骨无肉的东西。

使软件变得通用的方式是使之多用,在面向编程的抽象方面和面向应用的方案方面使之多用,,可是,除非这个做到极致,否则软件不可能变得通用.抽象的方面千千W,方案的方式千千W,,,故,问题有时候不是使软件容纳多种抽象面向多种方案 ,而是寻求一个统一抽象和方案的核心,,再以这个核心提供足够


所谓软件的扩展性,是指以后增加新抽象,,解决新问题能加入更多方案...而这二者统一于语言端的最终抽象,不矛盾

为了复用,通用,可扩展,这三者其实同一意义,,,,而增加新的抽象,,,它们不是解决语言映射,也并非提供方案以解决问题,,,这些抽象,,称为架构抽象..然而这是一种补丁动作,,重构时的动作,,一次性设计时,,还是寻求一个统一抽象和方案的核心为上策.--------- 比如pme模型就是这样一种统一抽象。

编程是适配应用问题域与方案域的本质行为，可扩展性是其要解决的第一大问题。

没有架构的设计往往指不为未来扩展作任何考虑的设计（比如不提供语言级的接口，或不提供产品级在运行时能动态导入插件的能力）而有架构的设计，往往为一种抽象准备了好几种类似的情况，（以便未来有一种扩展的需要恰好是其中之一）



抽象还有什么最鲜明的特点，这些，在接下来会不断被看到。(加粗的部分)

程序即算法加数据结构:实现抽象

软件即抽象
=============

什么是抽象,抽象是设计的一种高级形式

**软件即抽象。抽象是软件的本质。**抽象是软件的而设计是编程的概念。。

>>从最初讨论的编程来自于类型，目的为扩展机器功能。那么这种类型，扩展功能到底是什么呢？到目前为止谈到的架构，实现抽象与封装抽象等，它们都是软件，都是抽象

分开了才能整合，这是抽象分开的作用之一，抽象发工还可以令逻辑发开，第三，还可以将分开的逻辑放到不同的构件，或组件运行期单元中，比如将客端做成graphicclient和networkcli，就可以换客端的各个部分了(不仅是svr/cli 分开的moddables系统)。。分开这个说法，其实就是设置一个中间层，是抽象的作用，，不仅在源码级是有效的，，可组件级(plugins,compents)也是有效的


**抽象足可以被称为“软件原理”**，设计不过处理软件与人的关系的学问，所以它跟编程还是有区别的。





对于语言的抽象
-------------

抽象还可以是对编程方式的抽象,当抽象了类型,就可以用OO来表达应用,形成抽象了的应用作为语言的标准库,这样编程就可以有意地掩盖了大量细节,只有简单可控的几条高层东西需要掌握,比如PY用LIST,OO等方法表达整个编程理念,把编程真正做到了使它跟一般的计算机应用能力一样(努力的结果就是范式).这就是说,高级的编程就是计算机应用能力.

首先我们来问个问题,程序如何分类呢,从算法和数据结构的角度看我们可以发现,数据结构加算法等于程序.因为数据结构源于从一套相似的算法中找出操作对象的共性这个现实,而从复用来看呢,,又可以产生设计和接口就等于程序这种说法,因此这完全是不同事物的不同唯度而已..根本没有可比性.(至少二者都可以产生程序这个概念,于是,程序=机器加电也是正确的)抽象把事物的复杂度换化到另一层面,实际上也是另一唯度.

解决问题,提出抽象,提供功能,这一切都是利用语言的.我们的源码,就是最大限度分开这些东西(即使有时使用了一种重复的手段来进行).即,**我们现在的语言,同时负责着多个角色,,解决问题,写映射,还生成程序提供功能给用户**.如果能分清这些,对于被教育者,是一个不小的帮助.

然而,抽象在某一个层面,比如脚本编程使得编程手段更高级,然而对于native可编程能力,它变得越来越低,然而,这种越来越低,对于“后来更更高级的可编程能力”,又是一个越来越强的趋势.所以,这是二个层面上的问题.
在算法与科学,程序,功能这三者的每二者之间,都是抽象与设计.而这一切,便构成了编程.
抽象与功能都体现在设计,分层分级是程序上的事,也是抽象上本来就存在的事,所以是设计上模拟这个抽象的事,为抽象分层分级称为架构,架构不仅是功能上的要求,也是工程上的要求.

科学与算法,程序与设计,功能与源码.这是三个层次.这是一个倒金字塔结构,功能与源码包含程序与设计,由它而来,在它的考虑范围之内,而功能源码,程序设计,这二者,都建立在能用计算机实现它的基础之上.

问题,是独立于任何语言或库,或人的,故设计中,可以仅从问题本身考虑一部分事情,比如算法上的事,即使在以后客户需要等存在的情况下,及一些显式,急切的设计考虑因素要呈现时,大设计也应仅从纯问题的角度展开,只是在后来才慢慢考虑进语言的因素,再是其它影响设计的东西.
C的编程就是仅用算法和数据结构逻辑的开发过程,而C++以后的编程,就是在C的基础之上,仅大力完成程序与设计方面的事情,脚本语言就是为更好提供功能(在功能层面编程- 应用性浓烈的编程)而提出的.但其实,C可以完成C++的事,C++可以完成脚本的事.
>c,c++,scripting所代表的系统编程，桌面编程，应用编程等是编程迫近领域的三个前后阶段，前者比后者更像是一种dsl，解决的关于系统与应用模型抽象的事越多
通过C,你可以隐式地拆射设计,以有限的步骤映射,在低层系统逻辑层面,比如用打开一个文件的方法来达到抽象“打开了一个数据的仓库”的设计理念,它照样完成的是抽象,只不过C++有更显式的抽象语法和库,以更好,更快完成设计.

将设计用抽象显式表达出来,一开始不是以抽象事物为中心,而是先考虑设计上的事,在抽象事物前先抽象设计,在源码中显式表达出来,达到以设计为中心的目的(并用它指导了抽象)

从抽象着手,从设计着手解决编程问题,往往是空泛的.比如由接口系统组成的高层应首先去设计,但决不应首先编程.(如果不编程,除非是可弃型的COM,否则,在原来高层设计的东西在后来编程就没有意义,因此,从设计着手解决编程问题,这本身就是错的,最最高层的那个位置,往往是不能被实现的概念)

**我们知道抽象的本质在于对人的简单性**,正如上面所说,比如OO的三重机制制造的抽象就在于统一数据和代码,于是产生了复用效益.抽象的本质在于远离问题,从靠近人的一个高层角度去解决更高级的问题. 但是抽象的优点正是它的限制性,它可能带来再大的复杂性[1. 懂得去抽象并不是问题的终极,而且要懂得怎么样去抽象,如果抽象不好,它就是双面剑的另一面.这就是说,对于设计来说,要善用抽象.],一般抽象到了某个程度,为了获得计算机作为底层的冯氏能力,,就不应该再抽象下去了.开发模型不需要再变了,数据抽象到数据结构级就是顶级了再抽象就不是开发问题了,现在的虚拟机的提出,都是基于已有的模式,直接参照硬件上的机器设计中断,模拟数据类型等,从来没有那个虚拟机,其内部结构不是图灵模型,因为如果那样的话,它上面的开发模型将不再是数据加代码的方式.从来没有人突破过这个创新.仅仅因为大部分人没有想过,或根本无法尝试.

>比如以前的接口是API,是源码中就存在的,可复用的源码体系中默认就存在的,隐式可被复用,而接口就是一种特殊的"API",把可复用的那部分独立显式化抽象提取出来.还比如,OS最初就是为了显式化用软件控制机器的那部分逻辑,而慢慢发展起来的,还还比如,拥有设计设施的语言,只是把设计手法显式化了(C也可以完成C++的OO,可是它太隐式)

封装并不能产生新抽象,产生新抽象的抽象才能产生.

所谓实现抽象，往往是指抽象的起点，就是那种别的抽象以此为基础再抽象的抽象，往往用数据结构算法等系统直接相关的代码结构映射。所以，实现抽象让程序员了解一个抽象体系发源的源头，从这个意义上，算法和数据结构是基本的编程能力，它使抽象接上系统，更使程序员有发展抽象的根本和起点。

应用决定抽象，使得接口开发成风

面向接口和面向组件,使软件开发变成"积木组合",然而,除非提供足够多和足够好(封装抽象适中)的接口,否则,面向接口,组件,只是一套空架子. 

现在基本上满足于从一个源码体系开始,从中(已有的接口)中抽象泛生出新的接口,编成一个程序,,,,库不就是这么回事吗,积木搭建不就是这么回事吗,所以,库本身就是语言体系的一个个接口,程序员(如果他不发明新库)就是接口再抽象者. 

如何使用程序产品，决定了我们该如何抽象产品对应的程序域
复用是指尽可能地分离，而非一定要保证绝对可复用，那是做不到绝对的。

接口也是一种抽象，然而，有的接口是属于内抽象（写给自己看，用于完成表达程序逻辑工作），有的是外抽象（在程序封装为一个二进制组件后，经再度抽象专门供调用者使用），往往后者经过了更科学的组织，然而要注意，作为接口的抽象一样可以是纯程序内抽象。


抽象，，，应注意一个主线抽象，，或称抽象线索(这点像极了文学创作) 

编程最佳方案往往是一种应用方案，代码方案，问题方案的统一，工程需要的统一，而不是一者居大

架构和通用抽象过程中，，最重重的是分清哪是核心，哪是扩展，，它们之间的界限与接口，，如此，还有一点，是兼顾哪种扩展需求，，则架构自然可成。。
架构总是存在和必须的，我们总是，只需要一条线索的方案，那种为了多种实现而准备的架构，纯粹为了复用而不是面向应用，只是不必要的

在软件界明白抽象的界限并分开，这个动作本身就可以形成可观扩展性的引擎，如果能明白它们间的接口并设置一个以之为引擎上的架构（针对应用方向），那更是上剩之作。
比如quake2，一旦明白gameengine中最应首先分开的是gamenon logicengine和logicengine，那么它就会自然具有极强的可扩展性了--the moddable ablitily

从11年10月以来的思考终于可以划上一个句号了，最终的方案根据是，架构应面向应用而不是纯粹的工程抽象，应保持一个核心尽量规避抽象带来的新问题比如过度抽象等，所以，首先提出qt代替legay cpp的多典范这种拉几
那时，问题的思考源来自，，将本地也做成web,这样可以用本地语言统一开发普通程序和游戏程序，尽量减少学习曲线，类restfull web对services web的改进。后来发展为一系列更大的归纳性方案。
如上所述，上升到架构和抽象的范畴
要形成一个可扩展架构，，最重要的是从抽象着手，分清哪些是核心，哪些是扩展，并为之形成一个框架，，后来的扩展都基于plugin在动期或期静态导入进来


编程的基本原则是，就像适当注释一样，为了求得一个清希的源码，我们也要在适当的地方放置，抽象(领域抽象)和抽象组件（领域产品） 一般地，面向组件几乎就是面向使用组件的人进行抽象了，所以它属于设计中抽象过程中较高阶的那层；对于

我们从来都是复用（封装）一个库的一部分，而不是全部。 
好的抽象框架能容纳，接入多种同质的算法实现体系。
总觉得具物名称抽象比逻辑名称抽象要好
重构假设软件开发不是“传统的一次设计过程”（然后就抛弃），而是多次的。这符合软件生命期思想。

提出更多抽象（层）的效用是避免本质作为抽象的软件，发生抽象聚集从而导致不可复用，有分才能合而合不一定能分，对于桌面游戏，在组件层，应至少提出client(media,data,script),game----从人的角度，这样就大致能据此再细分出程序级的抽象－从程序实现的角度。

框架，就是开发界的os,那种既是应用平台又是开发扩展平台的库就是框架(它们往往附着于一个语言系统)，比如，PY有web框架，还有game框架， 它同时提高了开发和应用的层次。有别于普通的开发库。


抽象往往刻意而为之，可以为一小族（抽象族即一组逻辑相关的抽象）抽象设置一整个文件夹的类文件，每个类对应一个抽象，所以，（设置）抽象过程往往是最高级的设计过程。
所以，大量抽象往往形成大量逻辑，（它们不会混淆抽象，它们正是为了清晰化抽象的逻辑体系）除了调用API的能力，合理抽象的能力，干净的文档书写能力，就是实现能力了。
既然PYTHON是一个如此尊重抽象的语言（它的类被分成了几个层次体系），因此，PYTHON程序应不要满足它是由大量工具类组成的，而要，比如，设置大量抽象族（当然，这是从推荐意义上和美感注重意义上来讲的）

讨厌全功能的产品或程序库(因此它要提供很多功能，所以它的源码往往存在太多逻辑结构)，因为一个精力有限的学习者往往不能迅速理解它，进而学会使用它，故,需要将yawar源码进行整合简化
抽象不是越多越好，但也不是越少越好。做到适中的一个基本准则是，高层少一点，便于被教育者切入理解，低层多一点没关系，因为这里的逻辑本来而且接近实现逻辑，抽象可以多设置一点用来分开逻辑同样便于理解。
抽象可以多，但一定要合理安排组织在一个易理解的体系中，比如按现实生活模型提出抽象，把相关抽象放在一起，甚至不是算法需要地提出一系列新抽象（这些抽象形成一个框架性体系来接入其它抽象）而且作为切入点的高层，其抽象要相对稍少。
对抽象如何控制，有二个明显的特点，在高层应尽量少，在低层也应少，但至少应比高层多，不能绝对高层少低层多


对于问题的抽象
-------------

the story arrangement in a novie writting is perfectly like abstracts arrangement in a software dev(such as they have main clues when design 
比如network programming是networking programming的抽象主线就是socket wrapper,connecting,tranferring(silmatlly,syncly,safely,rapidly with compress or streaming,etc..)，game cg抽象无非就是一个scenegraph组织下的RENDER TECH,SCENE COMPENTS等的抽象体系。这是CG程序的主线抽象。

其次,**抽象就是编程界对事物方方面面的范式**[2. 对范式的理解去参照其它章节]**的一个界定**,但一般地,**抽象是抽取对象的可用部分(然后使之变得“像”现实生活中的某个对应物，然后，人们对这个抽象之下的概念或所指会变得更为清淅而已)**,比如OO化一个概念,现实生活中一只猪有毛,毛色,毛还有化学成份,猪由猪毛,猪皮,猪肉,猪骨组成,这样东西在编程时都需要统统被考虑被抽象吗?不.我们从来都是抽取事情对于我们的可用部分,所以设计时千万不能做大而全的抽象(这就是说,在理解抽象与设计的关系时,在具体软件制造中,要明白设计是指导抽象的展开的,而所谓设计,是来自人的需求折射到软件设计的另外一种说法而已). 并形成对于编程界的问题的抽象架构并使这种架构利于工程化，比如抽象使高层置为顶端,而它的可定制部分都集中在顶端作为应用,这有点像网络的七层模型,只有定义了一个抽象而且是合理的抽象,才能为未来的应用预留扩展空间

加一幅具体设计其实就是实现业界设计一部分的图在这里

我们知道编程就是一个以问题和应用为二端的二端结构。问题problem和应用app，共同决定了抽象的方向

**问题指业界的问题，而应用指编程者具体的应用，app指应用程序，但指应用多一点，它是具体的问题，要分清这二个字眼**

在设计一节中，你会看到需求，方案域，问题域这样的字眼，这实际上是问题和应用在设计层的不同说法而已。

**你可以简单地把抽象看成为概念化**.,并把隐式的东西独立显式化(抽象的一种作用是化隐为显) - 即，把概念提出来作为软件抽象。

看出来了吗?**抽象的本质是共同性与差异性分析**(把像的部分显式化出来作为中间可复用逻辑).在本章节,我们将从问题域和方案域二大部分(因为软件开发就是处理这二者矛盾)谈抽象. 抽象都是有维度的,数据结构就是基于数据化类型的维度抽象了开发中组织内存的套路,而高级语言机制或范式基于多样化写代码的维度抽象了开发,设计模式是基于设计抽象了应用,而设计,就是人的事情了,处在前面数据结构,范式,应用的所有上面层次.这其实也是本书四大部分的架构由来.

>这就是抽象与唯度.我们在接下来的章节中将主要谈到抽象对于事物方方面面或特定方面范式的抽象.因为这跟设计中的抽象过程有关.

实际上软件的设计哲学是可以用来解释一切的,因为它是真正的哲学,而真正的哲学并不仅适用软件开发(软工和计算机是二个完全不同的抽象,虽然没有人提出过计算机抽象到底是什么,软工抽象到底里面有哪些抽象存在,我们仅能站在某个或某些维度上给出一个描述性的概念而不是有限集,这也就够了,如果能站在一个大全的维度上说明到软工的全部抽象,虽然这是不可能的,但我们还是给得出的这个结果取个名字,叫范式,范式在意义上是大全而的抽象,然而人类的范式总表现为某些维度上的产物(只是我们在一本无论多么长的书里都写不完而已,如果有那么一种生命力和那么一本书存在,我们也坚信任何一个道理都不可能写完).下面详细介绍这个唯度的概念.

当然,我并非暗示,任何规模的设计时,都要从纯问题开始,只是在建议:当找不到业界的通用设计时,通过仅从问题本身的算法与抽象着手,再考虑一些必须要考虑和坚持的条件(使用DX啊,客户需求啊)下,如何形成一个设计的通用手段.和步骤途径.

对于人(的需要而进行的)抽象
-------------

以上都是；

作为设计的高级形式
-------------

抽象指一种“跟解决问题的算法”并齐的程序设计方面,抽象是设计,但一般不把抽象看成设计,因为设计中的那部分抽象才是设计
最能代表一种设计的，是抽象，而不是设计，因为设计是多变的，它往往基于组织抽象，而抽象是相对稳定的，往往还有领域标准抽象。

在一套源码中，隐藏着大大小小各个方面的设计，我们说“代表一种设计的几大抽象”，是高层的说法，在程序语言技法，系统编程方面，只要是作为源码书写的编程，抽象和设计在这些各个大小层面都存在。

由于抽象和设计在这些各个大小层面都存在，所以重构就活动在这些地方，可以为一个原型，在这些层面，进行重构，添加对应的代码，或抽象，或设计，或语句，或文档。这些都是重构。
如何处理抽象与设计,大设计与现实设计之间的关系,不要受制于现实设计,但要迎合它.
代表一种设计的抽象可以有很多套，但是在一个具体设计中，好的抽象体系往往是特定的，这是因为**任何设计，都有一个或几个领头抽象，在设计中，最重要的事，就是找出这些领头抽象，而不一定要按照业界的方法组织常见的那些抽象**。

设计和抽象都是有层次的,单一职责指出,**要在不同的层次安排不同层面的抽象**,这样抽象的正确性才能很好保障.这就要求你懂如何安排,即面向具体问题,**懂如何设计和抽象它们的能力.而这,就是设计能力**.

>庞大的抽象体系远没有一个仅包含几个可辨认的抽象的抽象体系来得让人易于理解。故所谓的抽象精密体系也是没有的。对系统的抽象应止于对于人来说适可而止的需要。

###### 抽象与设计方法论

虽然任何事在设计上都不可能以统一的层次界定(界定的层次,抽象和设计方法,提出的设计方案可以千千万万),但将人类的编程活动分为原型和重构是再清楚不过的.(其实,这二者是统一的,正是因为前者,才需要动态重构,以符合前者)

人们发现,设计不是一次性就完成的(只能不断地动态定型,第一次就叫原型),而是一根动态的设计链(计划永远敢不上变化嘛！！事实上,那些被称为设计抽象好的库也并不能说明它们就是完美的,只能符合特定广度与深度里的需求)

整个设计过程就是处理设计与抽象关系的一个过程(具体来说,是决定由哪方指导哪方的过程),高抽象并不代表好设计,高设计,只有那种用设计指导(设计是需求指导的,通用设计只能出现在原型中,即只能出现在设计迭代链的最前端)了的抽象,才是好的具体设计(一个设计只能最终是具体到接口设计的具体设计,具体到接口的设计就是具体到API级的接口),说它好,也是相对的,相对某个特定需求来说的,(而设计是一定程度上通用的,不同的通用设计,对不同的需求有差别 C 因为它是不好精确缩放到这特定需求)比如,从学科上理论上完美的一组抽象组成的设计(比如它是一个原型)有时往往的确是通用的,然而,为了符合特定需求,往往需要对此原型进行重构,这个意义上原型是一根到未来设计的拐杖,我们不宜在这原型设计中投入过多设计方面的指导,只有在未来临时应对新的设计需求(比如一个客户需求导致的新情况的出现)才需要在此原型上投入大量设计方面的抽象,这就称为设计指导的抽象,也就是重构了.

设计只能是某种有限设计 抽象不能指导设计,因为设计才是我们最终需要的,而抽象只是这个过程中的一个子过程,抽象的最终目的不是抽象,而是为了成就设计,成为设计的一部分而进行抽象,所以,抽象的方向可以有千千万万,但为了迎合当前设计而做的抽象(对于这种设计来说)可能只有有限的几种.通用设计是在实现级扩展(或设计向重构)上一次设计得到的.
一个程序员,应能理解任何设计,并实现任何设计,并预测它的易复用性和易维护性,易于复用,易用维护是同一个概念吗,前者是客户的事,后者是库开发者的事(任何复用角色都可以归为这二类)

抽象层次高的源码往往具有更好的组织层次

应纯抽象,使用DP也使用设计,固化
为设计分层次是不可界定的,但为问题作抽象是首先要完成的.和第一次就接确到的,也许在现实生活中我们的头脑中已然有了这样的抽象,但能正确地抽象到程序是另外一个问题,对于抽象,我们应尽量不去考虑它被设计影响时的情形.

为重构而设计:将设计预先设计为分步的,但重构所面向的未来需求不可知,也不宜没事就去重构,但要保证不触动原型的根基,,科学与算法,抽象永远不会改变,问题永远都会变,设计变,抽象不变,但这二者是统一的,大于它们的矛盾.因为修改,即可复用的实践过程.

先考虑问题,再考虑程序(接口功能,再开发,不就是重构吗?)三是考虑功能,整个程序功能上的考虑

每个步骤都清希,一定要写得足够详细,这是对自己的链炼,重构在什么基础上重构的问题
设计中对DX进行封装,或对WIN32 API进行封装,在这个意义上,不可复用是必然的(你可以物理性地源码复制的方法创建多个名字空间容纳这些同名名字),没有通用,只有相对通用和可复用

说法虽然是封装,但实际更宜表达为“提取所需的接口”,抽象的作用之一.就是将事物从通用处抽出来,使它象自己的.

重构:比如改造一个库,可定制的千万种可能,一个设计并不能满足所有的功能,而它必须是有生命的,而改造的任务就落在了程序员身上.
设计,对设计的使用,抽象,对抽象的使用(构成了整个编程),其实是一个不断由generic到专用的精确控制缩放逻辑层面的工作.

>实现,不光是有没有轮子的问题,而是问题本身有层次感,可供抽象用,可是在程序上不一定必须将之表达出来,以之为抽象基础.

实现与设计在纵横上都交错,没有设计,没有实现,只有相对的,情景依赖的设计与实现的分区. 从抽象来说，最终的程序是组合的,而不是线性的,更像是一种丑懦的糅合,能工作就够了

程序并不是最终的产品,而是中间产品,因为对于后来从它扩展的程序而言.它是中间的逻辑.
程序也能作为一种解决事物的问题,然而它并不实际解决问题的问题,而是解决人的问题(产生一个源码,完成机器和问题 -这里应说成功能 映射)由于历史条件,我们的编程工作,受平台,语言,库的制约和影响,变成了一种综合的工作.设计,抽象,编程,问题,之间的界限并不清淅可见.
搞好了抽象,就能产生复用吗?复用跟程序员的正确性没有必要要求,复用只是指程序的设计方面,对于人的工程方面,所以它与程序的正确性是二个概念.

抽象方法
-------------


写程序的真正能力在于清楚事物后对事情的描述,而不是凭空建立设计上的抽象

别死抠人家源码里抽象的字眼,能复用就够了,因为限于作者的命名能力和抽象能力,同一个字眼可能存在不同的意义.

别写人家看不懂的程序,媚俗就对了,随主流而不是非主流,这不像解数学题,以新奇取胜.

抽象,只要考虑它的历史所处就可以了,对于他们能很好抽象的,在业界能很好找到它们的对应,对于未抽象的,只能进行全新的设计.

###### 分层，分级，自下而上，或自上而下

**分层分级首先是某种分开设计**

分层设计的核心机制与策略.重构可以作为机制,不一定要触动设计,当然,也绝不整个地改变原型,即进行重设计.一旦原型确定就进入设计和编程的间隔迭代,以后的设计只能是因重构而导致的小设计(相比原型设计来说).

对设计的编程不称为实现(换言之,它还是设计,只是跟要扩展的设计在层次上不同),对使用设计的编程才称为实现(此时,这种编程实际上是写实现,这种扩展不再作为是设计了),设计和实现是天然不可分隔的,只是命名和人们看它的态度不同.(其实都是可供复用的中间源码逻辑,但一者有可能再次作为设计或实现被扩展,另一者只能在实现里被扩展,或不扩展).
分层,分级都是找抽象的过程,但是这种找抽象的途径可能性却有很多很多.设计与抽象在纵横维度上都混合.就跟设计和编程的关系一样,它们也是天然不可分隔的,实际上也是同一个东西的不同对待和称呼,无论是分层分级都促进了偶合,除非不对这段抽象进行再扩展(不作为可供以后复用用的设计部分).

>分层设计与分开设计,从上而下和从下而上 从下而上与从上而下都是分层设计，但从上而下很难把握，因为它不是分开设计，从下而上是分开设计，因此容易把握。
设计和实现都是编程和源码(书写)，如果硬说这二者之间有一个分界，设计就是就是那些鼓励被复用的部分(虽然实现也可以)，因此要被很好被理解（可复用性是软工强烈追求的目标，千万不要小看了它），那些组合式的小件就是最好的设计库，因此不提倡一次性的从上而下的大设计（易理解易复用的设计就像一根串起来的绳，它的每个部分都可被很好地理解和另外复用，那些从上而下层次组织起来的设计就像金字塔，除非塔尖做得很好-抽象很少并且明显，那么才能做得到很另外人很好理解和被复用）。

分层分段,找主干,只在设计者眼中才有,程序员眼中只有API,所以设计师必然是个程序员,设计有一部分必须深入到API级,因为设计是利用语言进行思考问题的过程,而设计跟编程不可分隔
自下而上但并不建立一套架构,抽象层次并不能称为架构,只有那种显式有接口的源码能看到的抽象层次才是架构,未来的不可复用性到底有哪些?我们仅能做到一定程度上的可复用性,更多的事需要等到重构时临时面对,重构并不一定改变设计,只有源码改变了定是改变设计,因为设计和编程密不可分.如果说决于作设计的那部分是设计,那么这样的独立提出来有什么意义

总结
-------------

教学上完美,理论上完美的抽象,固然是抽象的一种方法,不考虑任何现实(比如不使用任何语言,这样就不会一开始,设计就受语言和库的支持和支配了)一切轮子自造,充分考虑抽象的完善性.这样的编程是没有的.

程序即平台加映射：综合抽象

什么是编程(软件与软件工程)

===========================

平台，问题，开发，统一于抽象，又服务于设计

语言在这中间是线索，人是核心

某某牛人说过,增加抽象是解决一切编程问题的方法！！
对于能解释抽象的概念,在编程界一抓一大把.从本书序言开始,我们就不断地提到这个词.足见理解它对理解编程的重要性.(这本书主要是从开发的角度抽象地讲解一系列专业概念)

>在前面我们讲到，**软件本身就是计算机离散构成的抽象**，图灵机可以处理包括数值，文字在内的抽象和编程层，软件平台层支持的高级抽象，数据结构与算法将问题离散化为抽象接入软件。

抽象间的关系即为架构，不只是接口间的，组件间的，模块间的

**讨论抽象的过程将会和讨论设计的过程一个模子，因为这二者本来就可以相互转化。一般来说，抽象是针对程序员的，而设计是针对各种用户的(设计不但包括程序设计，还包括产品设计，而产品是面对用户的)，如果说软件的本质是抽象的话(软件自身是由抽象组成的)，那么设计就是产生这个软件的全过程及后续过程(它是一个工程，即软件工程),希望这段话可以助你分清抽象和设计。**



>还记得我们在书一开始把人类自身比做“计算机”的话题吗？

不妨接着想象一下,如果我们人也是电器化的东西,也有控制器等等,比如我们人可以是一个生物硬盘,那么当人们被接入计算机时,编程的工作,也就变成了用0,1组成代码,,即,机器语言就是高级语言,编译原理这样的知识根本不用去学.因为用不着编译器和汇编器这样的转换用的东西.人机高度统一,而且思想一致,直接交流即行,这样的话,世界也许不是像现在这样.

因为我们毕竟不是生物硬盘,我们具备不了机器分辨位而且能做到巨细无差的能力,而且我们也不能选择改造机器(我们的科技水平只能做出这样的计算机),我们只拥有一种能识别0,1硅材料组合的计算机,这种硬件上的裸机是可编程的,写上0,1的纸带是可以给裸机编程驱动它工作的,编程也的确可以做到机器内部,然而这未免太折磨人.如果不改造这二个东西,计算机将会是一个毫无生气的世界.除了在软件上提出一种像样点的高级机器解决机器的问题之外,我们还得需要一种能脱离了机器层面的编程工作.即,我们要同时改造平台和语言，那么熟先熟后呢？ 几种编程模式 先不说解决平台还是语言的问题谁先谁后，至少，通过上面的讨论，我们得出


纸带,机器语言和裸机是这样的组合的第一步,以前的机器都是用这种机器指令驱动的,硬件程序员用0,1编程,我们在前面讲到了这种局限性,这种局限性不光来自语言,还来自硬件平台的低级性(它也导致在这种平台上不可能有什么高级形式的语言),1950's早期,数学家Grace Hopper 发明了symbolic语言,即assembly. 这种语言使人们用助记符的形式替代传统的直接写0,1的方式,然而,它只解决了问题的一部分(它还是机器语言,解决的还是低级的硬件问题), 我们在前面也一再提到了会编语言编程中出现的所有几大问题：机器功能不够强大，指令由人驱动太麻烦，指令执行需人看管，不受机器托管 所以，我们要提供一种高级映射手段(和程序执行的安全环境)，，降低人管理机器的任务（一切做到软件层），编程语言之系统实现语言，将编程作为系统软件做到系统内，用编程发明系统本身。 所以，为什么需要高级软件平台，高级语言？为什么需要高级语言作为系统实现的映射手段？所有这些，并非没有理由。

直到在为机器引入了一个OS后,问题才慢慢明朗.因为出现OS，就可能出现一门对应的高级系统编程语言。 在出现了OS之后,人们对系统的开发工作当然也不再满足它是汇编(当然最初的OS就是用汇编写的).如果说机器语言或汇编语言是严格基于平台逻辑的,那么高级语言基于严格的语言机制和语言语法,具有严格的图灵装备,,负责产生后来的逻辑和用户级的应用逻辑.所以我们必须得先抽象了一个OS,我们还得给自己造一个高级的开发过程.于是这种系统也可以用这种语言来重写[^10].这样的模式就是在OS下设计一种高级编程语言. 用高级语言编程的方法来解决开发上的问题还是50年代后期业界才想到的事[^11].从汇编到高级语言,步伐几乎一前一后紧逼(汇编1950's早期, 最初的高级语言被发明在1950's后期,.), C语言的前身BCPL语言就是那个年代出生的.那么,为什么需要高级语言呢?这是因为它实在太“好”了，为什么呢？------ 如果汇编开发模型这个模式被另外一种更高明的方法,比如,高级语言代替了,我们就可以专注于正在写的代码和正在用代码表达的应用,高级程序员只需要在语言提供的某种设施上,比如类型上,开始工作,而不用管编译器在背后为你做了哪些把类型映射为位的工作,也不用管OS是如何为你的程序提供一个执行路径的. 于是，OS，高级语言，基于OS上的使用高级语言完成的，系统实现与开发，这种编程模式就出现了，这是我们现今主要的编程模式。

**于是,编程能解决问题的模式是受运行模式控制的,对应用进行编程层面的设计模式是受语言模式控制的,而语言模式是受代码模式控制的**..

######数据模式

数据模式是语言模式的基础，在用语言解说算法和设计的区别时很给力，脱离语法层面，对如何解决问题提供解答的，就是算法，在使用语法，或高于语法语义级对如何形成应用的建模进行解答的，是设计，两者都是一些模式，所以有解决问题的算法模式，抽象应用的设计模式，数据模式（数据结构可以跟算法毫无关系，查找排序只是数据专用）


###### 语言模式

这里又涉及到一个语言模型的问题.任何语言都并非凭空出现，而是跟运行模式相关的，图灵机上能运行“算法”，图灵机上的语言，它们所产生的作品，必定是一些本质上是算法的东西。 图灵证明了，任何一种图灵机，它都能识别与它等价的图灵机能认识的所有符合集。图灵机对于编程的意义在于：它为带有存储装置的形式语言的发明提供了理论，记住，这不是针对计算机的，冯氏理论只是迎合图灵机能处理的东西，而物体化的一台机器。 以上，就是图灵机与图灵语言所表现的算法之间的关系。 为什么开发模型跟机器模型跟是紧紧联系的呢?而且历史上存在很多失败的计算机模型(死亡计算机协会),只有冯氏模型下的高级语言活了下来. 汇编语言的模型只是用指令直接形成电器化指令控制计算机本身(完成“操作系统”的任务),或控制计算机完成计算(“用户任务”),高级语言因为其建立在OS上(此时的语句,是以源文件为载体,而不是电器化的tty),OS可以完成控制计算机本身,os上的(高级)语言模型,就是从汇编发展而来,结构化的语言(比如C语言赋值,流程等),以后所有的改变,比如OO语言,其实际上正是在结构上发展而来的.是以结构化为基础的.如果说机器之于指令,是一种“冯氏计算”(内存修改器,它的本质是迎合冯氏计算机数据处理本质的),建立在OS上的高级语言导面的“语句语义”,它对OS,也要是“数据处理”.这就是直接取材于会编语言的,高级的“指令”,即“过程化语句语义”. 这就是说,因为语言写出来的软件就是为了系统服务[^12],(比如结构化程序语言符合堆栈机),所以这个系统最好就是基于某种语言的,(但冯氏模型太屈就通用的低层实现而不是高层开发抽象,所以它导致了C,C++这样的以类型化和数据化作为设计手段的开发方法),语言逻辑即系统逻辑,这多好啊(从这方面看,图灵机既是计算机模型也是语言模型是很容易理解的),那么为什么我们的PC不设计成与语言直接对应的机器呢,这是因为开发虽然对于PC很重要,但做其它工作时需要PC提供其它通用机制,因此不能仅仅屈就开发模型(比如还屈就机器实现难度上面谈到,CPU+OS才是开发的低级平台,很多软件需要在这个平台上工作而不总是那些高级虚拟机的应用). 虚拟机与脚本语言也是一样的道理. 而一般虚拟机作了高级逻辑,比如GC等,而X86不可能在硬件架构级就用了GC,如果CPU芯片可以用硬件加速的方法直接支持语言的垃圾回收机制就好了,这要求语言跟CPU一一对应,,而且OS也提供了大局方面的GC(并不仅仅针对某个语言,比如WINDOWS的操作系统级的资源释放)

在继续操作系统的话题之前,请先复习前面章节讲的机器语言的初级封装形式,即汇编.并确认你大概了解它的原理

######设计模式

设计模式是应用设计模式的基础。它主要是对应用建模进行抽象，而模式化的一些方案（由语言来体现这种设计方案）

初识设计
-------------

设计这个字眼本来就是多义的,本书一开始,多处讲到了设计,比如,我们说“库更多地是一种设计”,我们还曾提到“流程控制也是一种设计,它允许我们以高级的结构化逻辑写程序”.

其实,任何事情都是先解决它与人有关的那些事情,所以编程,第一件事就是设计[1. 源程序就是设计,我想那个人主要是想说:编程就是设计.可惜他表达能力差,没说清吧](实际上,我们在写之前,总是在事先进行某种无意或有意的设计,说它有意,可能是写了一张UML图,写无意,可能是按照你看过的一份源程序的设计,即人类设计的通例方式,直接写出了源码.所以,第一件事就是显式或隐式的设计,不管你有没有在设计或承不承认存在这个过程),应用分析,很简单的道理,只有在道理上可行解决过的问题[2. 比如工程中经常要写的文档《可行性分析报告》],不存在明显大错误的事,在编程上表达才是可行的,并最终体现为一种PC的应用.

**一定意义上,设计才是真正的编程！**因为这句话最终道出了编程是属于人的活动,而非以机器和语言为中心的本质,只有那种最终提出一个产品规格,技术规范为重的编程,这样的编程才带着浓重的设计原味,周爱民[3. 周爱民,XXX]说:一切软件都源于需求,我想他只是说:设计才是真正的编程.

大设计与狭义设计
-------------

###### 通俗意义上的设计：大设计
但是存在一种大设计,即编程不仅仅是编程,它还涉及到很多其它的人类工作.比如编程领域对事实事物的抽象. 当我说到这种设计时,我不指代任何语言和库,或跟计算机有关的东西,它只是一种人类的文档,可能是W3C组织某一天新发布的规范,可能是某个外星人想毁灭人类电子文明的计划,来自客户的需求,一种CRC卡片.此时,它没有任何跟编程必需有关的东西.我们在前面说到“系统,语言,应用,设计”时曾提到如下这样一张图:
<table>
<tbody>
<tr>
<th>模式</th>
<th>意义</th>
</tr>
<tr>
<td>纸带编程</td>
<td>编程完全是处在计算机系统外部的</td>
</tr>
<tr>
<td>编译器编程时代</td>
<td>编程被置入了计算机系统内部,但是编程和执行还是离线的</td>
</tr>
<tr>
<td>交互编程时代</td>
<td>依然被置入计算机内部,但是却是由人高度实时参与的,查看结果的</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
那么我们可以把设计加进去,丰富这张图:
<table>
<tbody>
<tr>
<th>模式</th>
<th>意义</th>
<th>举例</th>
</tr>
<tr>
<td>编程与语言</td>
<td>把编程做进了计算机</td>
<td>C,C++,Py,各种现今能看到的语言</td>
</tr>
<tr>
<td>大设计(编程与设计)</td>
<td>尚未加进计算机或语言的设计,非具体的</td>
<td>尚未加进计算机或语言的设计,非具体的</td>
</tr>
<tr>
<td> 设计与语言</td>
<td>可能被置入计算机内部,或语言内,语言外具体的,已经有实现的</td>
<td>设计模式(本书整个第四部分提到的东西)</td>
</tr>
<tr>
<td>应用与语言</td>
<td>把应用做进了语言</td>
<td>Python 标准库[4. 我们在前面说到,库更多地是一种设计而不是实现,因为它综合考虑了很多设计因素.所以Python标准库在这里也可举例为“应用与设计”]</td>
</tr>
</tbody>
</table>
看完以上这张图,请确保明白:**设计可以是不一定跟语言有关,甚至不跟计算机有关的那些人类的东西.只不过它被做进了编程,做进了语言,做进了库,所以模糊了我们对设计本来面目的正确理解**[5. 源码,甚至编码,都不是区分设计与实现的本质,而只是现象.].

**而抽象,实际上本身就首先是一种最高明的设计**(本书第二部分抽象开发整篇讲解的都是基于抽象的,对开发中各方面的设计,3,4,3,5,3,2这三节对他们进行了归纳).
**我们在前面说过,设计,就目的来说,可以是对事物本身的抽象(更好反映事物) - 这就是设计中的抽象,也可以是对人类编程工作的一种靠拢 C 这就是设计中的工程思想**,比如基于更好复用,更好事后维护,就设计的内容来说,可以是应用,甚至是对编程本身进行设计(以上的表就是例子),对编程现实模型进行设计(敏捷与方法论),对语言进行设计(很明显..这个不需举例)

<img title="bk1pt1ct04st01pic01.jpg" src="http://localhost/userfiles/lmtpractise/uploaded/bk1pt1ct04st01pic01.jpg" alt="bk1pt1ct04st01pic01.jpg" />

(图)事物(算法),程序(抽象与设计),人(功能和源码),-》机器-&gt;应用

范意上的设计是广泛的,不仅限于计算机的,也不限于软工抽象, 我们必须明白,设计这个词首先是一个表示人类活动的词,比如有建筑设计,艺术设计,,而程序设计只是其中一种.它可以解读为用程序设计语言提供的基本语法和高级语法,以及独立于程序设计语言但跟语言有关的那些手段(比如Corba,设计模式),来进行对方案域到目标应用域的一个逻辑映射[6. 一种能产生最终产品但并不以产生最终产品为终止条件的人类活动过程,它包括选择语言的考虑,应用设计,模型抽象,维护各个部分的整个综合过程,也即设计等于软工].故涉及到不止程序设计语言一个方面.下面我们将就这些方面一一进行解说.

明白了抽象,我们明白一个东西,应做个明确这个东西的抽象所属,即它所在的人类范式.

狭义设计指的就是OO设计,OO based design,它可以发展出interface based design,aspect based design..etc..

因为设计首先是大设计，故，它是范式是多维的，体现到语言上，比如C++为什么不是单一OO泛型而是多泛型的呢,因为设计就是多选题,你无法找到其单一性,这就跟policy based design一样的道理.

###### 三种编程

原始的编程: 不同的编程还是不同的,甚至有着本质的差别,存在三种编程,即未经抽象的编程(或原始的编程),此时的程序执行体是裸机,编程支持也是汇编,裸机是整个计算机在硬件级基本能执行程序的本形,此时并没有出现任何软件上的东西(包括软件上的执行系统,所以更不可能有除了执行功能以后的其它系统功能的软件概念,比如软件上对编程的支持),机器的这个状态跟指令和汇编语言有关,由于没有出现任何软件的概念(我们把出现OS作为拥有软件意义的标志),本书开头处就把握好这个机会,谈了三个方面的内容.即,裸机中CPU与内存是如何作为硬件二大主体进行工作的(主要是执行指令调用数据和实现跳转,所以说冯氏系统是顺序串行的确定的,确定就是说,它是预定义的,它一定是被预先生成为顺序的),汇编语言是如何在CPU加内存的工作方式下天然地引入了那些指令,以及它基于指令选择的初级编程层面模拟sub例程的方式(这是完全没有语法意义的),然后谈到裸机加汇编语言的组合是低级的平台加编程的组合方式(平台模式和计算模型的一个组合),是注定要被改变的.

抽象了的编程,程序执行体是软件的OS,编程支持是高级语言,解决问题的方法上实现了数据结构和算法

这使编程语言按集成的抽象度分为二种,一种是C这样的实现语言,它主要面向系统本身,利用实现逻辑的数据结构和算法(之所以称数据结构和算法是实现逻辑,因为它们解决问题时使用了组织内存的手段,而内存,是初级系统级的东西),解决的是系统编程问题,上面说了,系统软件,包括OS和编译器的制造与设计,都是不断被证明可以用数据结构和算法的那些知识很好解决的一类问题的典型,人们说系统程序员是幸福的,因为系统程序员只需掌握有限的固定的系统知识成型的标准理论,和C这样的语言,外加数据结构和算法以设计和解决问题的手段就行了.

高度抽象了的编程,程序执行体是虚拟机,编程支持是某种工业成熟的高级虚拟机语言(往往它们把执行体和语言作为它们的标准),而且在抽象了数据结构和算法的基础上,语言还把设计模式这样的越来越高级的编程理念加入其中.语言与应用之间是紧密相连的,不同的语言解决不同层次的问题,有的语言善于解决,这就跟语言内提供了什么样的设计方法,它的语言内核中内置了什么样的语言元素,这些元素是Python这些的高抽象语言内置的,它面向比系统问题更复杂的现实问题,涉及到新的框架(比如web)新的理念,涉及到很多与设计与设计模式有关的东西,还涉及到高抽象的语言.虽然这些东西名为“抽象”,但实际上,还是要求程序员对所有这些抽象前面的铺垫知识有一个大概理解的.

###### 语言选择

解决了“什么是编程”，什么是编程语言，我们终于可以稍微向更高级一点的问题，比如“怎么样编程”这样的问题前进了。

为了编程,固然得学一门语言,然而语言与语言间又是不同的,这种不同会直接地影响到你选择的语言是否正是你要表达的应用所需要的,而且会影响到你学习这门语言的曲线长短,那么对于初学者来说,什么是真正最简单最实用的语言呢?

历史上地,编程为了越来越抽象(以更好表达应用,或满足人们使用某种语言进行更好设计的要求,实际上这二者也并非毫无联系),发展出来一系列历史抽象,比如数据结构和算法,VM,语言的语法和语义,设计模式,等等,对某阶段的编程需要涉及到的东西各有不同(因为它们处在高低不同的层次上,解决实现或设计的偏向程度不一样),低抽象的编程只需理解某种固定的平台细节和语言,解决常见的系统内编程,而高抽象的语言及编程,使编程工作进入一种复用和设计多于自己实现轮子的现状,此时他们面向解决应用问题居多,自然开发语言应直接内置某种高级语法语义,或库标准,或设计模式,这些就可以不必事事重新发明轮子,重复那些在低编程阶段就不断反复解决过了的问题(比如,高级开发可以使用直接形成标准的IO,GUI,任务逻辑,或高级数据结构).这二种编程学习曲线自然不可相比.

>处在二个极端的C和Python,C是典型的实现语言,而Python是典型的高级抽象的语言.(C++的better c+OO层次组成的语言,是介于C和Python之间的中间语言)

以同样的应用高度来说,由于c本身不够抽象,所以由C到语言到应用,中间经过了太多抽象,理解曲线过于曲折,相比Python来说,语言到应用中间的抽象相对少一点,学习Python开发的学习曲线要平滑一点,C太靠近描绘底层,细节太多,而C++除了用C的底层能力来描述数据结构它还加了一层设计和代码结构逻辑,它假设人们只需要在高层次懂它的设计就可以编程了(于是它给人们一种这样的假像:即C++进行对系统的编程不再需要涉及到系统低层,言下之意这是跟C比较而言的),但实际上理解这种OO设计本身也需要对高层次下面层次的理解.

Python学习曲线短,是因为它能迅速看到正确的程序结果,让学习者明白,而C,需要做太多的工作

除了C++和Ada,目前的语言都不具有泛型,目前绝大多数语言都是为了运行期[^16]而准备的,所以,学编程,第一件事,就是学习运行时的栈,和运行时的数据(这也是本书程序二大部分,在第一部分先讲系统环境,系统环境中程序的执行路径,然后再讲具体的语言机制和某门语言,这样的步骤的由来),因为运行期语言对它们都做了编程机制上的直接封装.

这里只稍微谈一下语言之争，更多的请参照附录部分的《语言之争》。

因此存在大量争论。

语言与平台，应用，设计是密不可分的，作为软件工程中的编程，需要讨论它在结合所有这些因素时所表现出来的综合优势，而这种因素只能是因语言不同的。这是从语言的外部环境比较。

**从语言内部来说，因为语言是由类型系统和运算系统组成的**，所以对一门语言能力的讨论,总是要涉及到它对数据结构的表现能力和对代码的抽象能力,以及对问题本身的抽象能力[^17],

首先来说数据结构,现今的编程都还只属于某种未脱离数据处理模式的语言(冯氏下的编程就是数据抽象加数据结构抽象,这些都对应着冯氏机作为处理数据的机器的本质.而代码,实际上在冯氏机里也是作为数据被对待的,这就是本节一开头谈到的问题)还未脱离运用处理数据的方式来解决编程以解决问题的方式.所以,对数据结构和算法的运用永远是一门冯氏下的语言编程所要涉及到的(只要这个过程未被设计完全抽象掉).


小结
------------------
如果弄懂了以上，那么，OK！！我们可以进入第一章了



[10. 放大到整个人类,任何现在看起来自然而然的事情,人类可能在那时都有过不小的脑筋转弯期]

[11. 语言被发明,第一件事就是它必须可以用于开发系统本身.所以这到底是鸡生蛋还是蛋生鸡呢?这个鸡与蛋，是具体的鸡与蛋，而不是泛义的。故，是先有鸡，后有蛋。]

[12. 这里有一个posix标准的问题,C语言库里的那些东西是高阶的,建立在这个上面的]

[13. 关于机制与策略,标准与实现,规范与实作,软件抽象与实现的关系请参见后来章节]

[14. 系统语言基于平台逻辑是为了开发平台逻辑,c语言这样的语言表达力足矣,然而为了描述更高级的应用,需要比C更接近应用的高阶语言,而为了提出这样一语言,还得首先提出一个更高级的开发平台,于是它虚拟出一个平台,比如.net,jvm等,所以说CPU+OS是低级开发平台,jvm,.net是虚拟平台,高级开发平台]

[15. 运行期的语言要进入运行期才体现设计,在源程序级,很难见到真正的设计.在C++中,泛型从源程序级体现的设计,要比C++的运行期OO在源码级体现设计来得明显]

[16. 一份具体的代码,总是综合着,写这份代码对问题的描述,和对设计的代码上的直接展示, (一门语言的能力体现在设计上,和对应用的方案描述能力上,这也是本书“语言内和语言外对于高阶设计和高阶应用方案”这样的题目出现的理由)本书以&lt;&lt;抽象&gt;&gt;那一章开始,以Python作为语言范例,先讲数据结构,再讲代码结构,再讲设计模式]


程序即规范与实现

根据前面的知识，我们知道编程是一种工程，而且是一种模式，更是一种编码，

我们可以将编程粗略分为五个阶段，即solutions,implents,design,developing,product.当然，这五个词如果要把概念精确地划分开来是不可能的，我们只能给出一个模糊的描述，借此说明问题，solutions指用系统实现语言和算法完成的那类问题和编程体系，implents，即是导出api之前的那些编程，design其实可以统领其它四个过程，但这里把它看成是implents编程完成之后的设计过程，此时问题不需要被solved,只需要用语言完成映射，你可以把它看成是app设计过程，devloping就是用带有设计性语言元素完成的再次映射过程性的编程，product是产出产品那一阶段的编程。相对来说，其前面就是middleware性的，完成了devloping后的编程。

下面，我们会从平台直到编码，详谈这些过程中的整个细节。

###### 实现与抽象

编程涉及平台支持和目标领域问题.一个用编程语言写就的,用OS运行的,“软件系统”中,必将大量存在这样的“平台编程逻辑实现”,相比之下领域逻辑少得多,(我们将由领域逻辑主导实现逻辑.).
一种方法就是广为谈到的“抽象与实现分开”,我们需要将各个“实现”按文件物理地分开放置(此文件将会是引用的未端,不被“设计”直接作为头文件引用,而是作为最终可用可弃的实现未端,由它引用目标领域逻辑).当然这个过程中,我们应注意模块化(所有的编程范式都是模块化的),然而正如上述所说,模块化不能复合,不能高下相互引用,比如“设计”引用“实现” .(因为设计中有自上而下和自下而下,故也不存在各个模块之间平等不相互引用的情况)但是如果不考虑最终软件系统的实现的话,光就设计来说,确实也存在各个设计模块之间平等绝不相互引用的情况存在.

解决不可复用问题的方法是增加迂回(一层抽象接口),将实现逼回底层,这个动作出现在二个过程中1,对于目标领域的抽象过程中,2,对于重构时的过程中.

然而,所谓的迂回,其实也是系统中的抽象,,也会对可复用产生障碍,一定意义来说,系统中抽象层次过多,,或数量过大,都会直接对可复用性产生麻烦,这为了解决不可复用问题而设计的另一层抽象正加大了某种程度上的不可复用性.所以是一种以毒攻毒的方法.解决问题的方法正是产生问题方法的来源.

>这里有一个实现跟开发的区别存在,在前一篇《理论能力与语言能力》中,我们提到设计与编程是相对的(它的另一种层面上的说法是“抽象与实现”,这里的实现与我们接下来谈到的实现不相同),逻辑间是通过逻辑堆栈[^5]建立起来的,在这个意义上,1.低层次的逻辑就是实现,建立在低层次上实现的实现过程,就是开发.2.那些以“语言为中心”,而不采取任何语言标准库或第三方库的开发动作,就是实现, 比如,对于库,语言就是实现.对于STL,模板就是实现,我们不写模板库时,就不需要掌握“如何写”模板,而只应掌握“如何用”模板,这二方面来看,OO与模板不一样,因为OO的写几乎就是它的用.还比如,对于QT,OO和GDI这样的平台逻辑就是实现. 还比如,api,说明api下面的东西,,是非应用的,而使用API的过程,是一种“应用性的编程”,,言下之意,就是存在“另外一种编程,叫实现性的编程(对于API来说,这就是API前面的那些东西)”这二者不同的是,后者往往是为前者所用的,不过,如果这二者是使用同一语言,那么,应用性编程,跟实现性编程实在很难分清界限.只能根据问题的层次来分,不能根据语言来分,除非脚本语言对API的封装情况,这种情况下,就很容易分得清实现跟应用(虽然它们都是编程) 因为实现是相对的,所以我们不能说一个东西绝对是实现,人们一般把以下这些东西(在OO的复用角度上把以下)称为实现: 数据结构与算法.高级语言语法,比如template, 而把stl,语言标准库,QT这样的应用库,称为只需拿来应用的开发. 这也是本书鼓励大家在实践时学习这些知识的先后顺序.

当然,最后,抽象的方法不同,产生的抽象结果不一,由此产生的不可复用问题是最严重的.因为复用者一需要理解你的设计抽象,,在理解了之后,才能进行复用.如果你的抽象过于复杂,复用者不会有太多兴趣.

编程能力就是学会如何面向可复用考虑去进行抽象.当我们设计自己的系统时,为了提高它的最大可复用性,我们将它设计为与语言无关,与OS无关,与复用的库无关.这种工作是相当难的.设计中的目标问题抽象永远是自己的.那么如何将这些如上的“实现”逼到未端呢?

除了上述不可复用问题来源于不可移殖之外,还存在以下几点不可复用问题产生的源头:

程序即API与复用:利用第三方抽象


###### 大中型软件和复用与逻辑达成

所以大中型软件的形成,,有的是库逻辑和实现逻辑,即设计能力,,有的是复用逻辑..即编码能力..因此那些说程序员是简单的复用员的人是可笑的,,因为一个程序员在编程中总会涉及到设计能力(即那么比如设计一种数据结构库的能力)...

可复用到底追求一种什么样的效果,又能最终达到什么样的效果?运行期的效率或重构期的不可复用和窄扩问题(这是二个并非绝对统一的东西),一切都可归究到设计期的问题(因为那才是软件问题的源头[^7]).

首先,要想做到与语言无关,就要用那些最初步的语法机制和开发范式,比如函数过程式.三种控制结构(事实证明它们可以产生一切逻辑).或者自己开发一套自己的语言,在自己的语言领域之内作“固步自封的复用”.但我们知道,这(当其它语言不存在)实际刚好阻碍了其它语言对其的复用.

其次,要做到与OS无关,当OS不存在吧,不要引用OS的任何东西,,,照样是在自己的语言的基础上发展自己的GUI库,等(这实际上也是很多语言提出可移殖理念最初的出发点),一系统的系统平台相关的库.

要做到与可复用库无关,只有自己开发功能相当的库了.即一切轮子自造,包括语言.然而你可以改造语言,却不能改造英语编程语言,那是一个未知领域,你更不可能在冯氏模型之外发展这样的语言,你不能改造PC模型,也不要指望改造OS,更不要指望改造电脑的能源为光脑.

所以,一切好自为之吧.既然轮子的创造是一个无底洞,,何不直接就复用别人的库呢,用大家都用的语言呢?更重要的,作大家都在做的领域设计方案.这样别人才能理解你的设计.


程序即一步一步扩展栈:系统抽象与桌面应用

抽象
=============



我们看到从机器开始，都是一级一级预留扩展和再抽象接口的，对于图灵机是中断编程接口，对于OS内核，是IO接入中转到系统服务核心的接口，对于OS上的软件是用户程序接口，对于语言，是用户类型扩展机制。而所谓编程，其实就是一个中心及中心接口+扩展和修改它的机制，只不过他们工作在不同层次而已。

在第一节中我们谈到,整个PC系统是一个经不断抽象后形成的构架,在最底层是计算模型,即图灵模型,然后是冯氏架构和CPU在这个架构中发挥的主导作用(整个冯氏计算,实际上解决的是以CPU和内存作为执行平台,如何形成并运行程序的事,这也就是冯氏计算四个字的本意所在,当然,在没有出现软件之前,这个平台和程序只能称为指令形成的硬件世界和硬件程序逻辑),在抽象了CPU为保护模式并发展出一个OS后,所有的硬件问题都转化为软件问题了,开发也是一样 (软件既然出现了,基于软件上的开发可以出现了,而这首先是提出一种同针对给机器编程的指令语言迥然不同的语言).

历史上第一个OS是会编写的,我们在前面谈到会编加裸机的组合的缺陷,它造成了OS的出现,这解决的还是运行平台的问题,那么针对映射手段编程语言,能否利用一种更强大更易于人理解的方式来编程呢?甚至实现操作系统本身?

在第二节,我们选取Linux,具体谈了这个OS的架构.认识到其内部架构也是经科学抽象的.具体到OS的每个子模块(为了执行程序用的任务模块,负责程序运行时IO处理的IO模块,GUI,等,或其它与编程不是必然有关的其它模块如网络模块 C 并不是每个程序都是网络程序),其里面也是由一步一步的从硬件功能到给应用程序提供运行功能的抽象过程组成的. 可以看出,不论是对计算机本身,OS,还是为后来的对基于其上的开发工作作准备,,都是一个不断由底层向人抽象的过程. 以及本章将要谈到的高级语言设施本身,也是如此.抽象从来都是解决和解释计算机领域事物的最好哲学.
我们还谈到编程有三层,系统和开发层出现的问题一般是同时进行和解决的,而要给某种平台提供什么高级语言的问题,就是解决平台问题然后解决语言上的问题的最集中体现.

*注:在具体讲解各大语言要素的时候我们仅讲解它的语法,语义原理(甚至会涉及到运行时内存模型的解决),这些与阐述一门语言内数据,代码产生模式有关的东西,而不打算讲解它们的后端实现,比如优先,最终目标代码生成.

任何桌面程序都是一种抽象堆栈
-------------

**程序设计，最重要的事，就是对被设计的东西有一个清楚的程序上能“表达完”的界定。**

任何程序都是系统编程和其它领域逻辑堆栈成的APP，把什么作为“一次程序”（代表一次抽象和一次程序过程），决定了你采取什么样的架构，什么样的从上而下或从下而上的方式。



