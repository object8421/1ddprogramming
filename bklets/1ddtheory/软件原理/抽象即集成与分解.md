/*!

\page 设计 : 当编程考虑进与人有关的那些东西时.html

============= 设计 : 当编程考虑进与人有关的那些东西时


**编程即设计。设计是编程的本质，**编程是创建抽象组织抽象。进行抽象间的映射。编程就是对软件进行操作。对抽象进行操作。设计是为了产出可扩展的产品，一定意义上，是对抽象的安排和管理。

设计是软件的现象和形式。

需求是对影响程序开发维护生命，，或一次设计开始时的所有对程序的抽象的变更（架构上）和改动（算法增添，代码修改），， 

需求如果在一个软件过程中（或软件一次设计开始时）被变动，那往往关系着程序上大部分的改动，因为它是反应到软件在程序上大部分业已形成的大局抽象或大部抽象，但是绝不是重新开始新软件的生命，或重新设计的过程，它是温和的过程不是打断。。 

抽象间的关系即为架构
算法抽象往往是实现抽象，语言技法，对应用方式的设计往往是架构抽象

这样分抽象是不对的，问题与算法，工程与设计，都是抽象，前者是建立抽象，后者是使抽象适应人，方案就是范式，有算法范式，也有复用范式，比如设计模式


我们曾在本书开始的时候就谈到什么是编程(它的狭义),编程的广义就是软工,软工的广义就是设计,而设计的广义是大设计，下面我们主要谈软件编程中的“编程工程“






------------- 面向需求，抽象应用

范式，就是人们理解应用，形成方案的模式，，设计模式就是设计范式，代码有范式， 是OO，应用有范式，是DP。问题有范式是数据结构和算法。

云端软件平台,是操作系统上的安装反安装军刀,这就像游戏开发中的MPQ shadowable and hookable file system,应用决定抽象.决定使用什么库来作为轮子进行封装开发. 现在看来，软件应用也满足软件开发的抽象原则，设置一个中间层可以解决很多问题，如云端，svn

**任何软件的问题都首先是一个设计问题**,都一开始并不跟语言,跟编码相关.软件的设计,是先解决它与人的那些关系(需求及可行性分析等),再完成它具体到一门语言某种语言机制或库逻辑进行编码的问题.**编程问题处在开发问题的未端.**
比如对于一个应用来说,**界面就是表现抽象**(我们是人,需要一个界面来与我们开发的应用交互,没有界面的系统或应用,是荒诞的),**它首先是一个设计问题**.对于界面问题,一般将它设计成与界面要表达的逻辑分开,这样当逻辑本身发生变化时,界面可以脱离它进行”换肤”.看,多么妙的思想.可是这需要在编程时精妙地迂回(进行抽象)因为编码不应常变动,源码往往是一个复杂的体系,任何改动都是致命的,因此要么不改,界面就可以自由变动,或者即使一旦如果要改,我们也应保证改变时不涉及到太多的工作量(显而易见,这就需要当初在写的时候认真设计,在那些大的思想层面,先把当初能避免的对于源码的改变预见下来,进行对界面和逻辑的尽早分离)[4. 当发生问题时,你可以说,but sir,我一开始就把它设计为分开的啊,怎么会出现界面与逻辑偶合呢?这就是界面与逻辑分开的设计原则,更多的设计原则和设计方法请参见《综合抽象之设计模式》]

###### 代码模式

**以下来自转载** 范式就是编程习惯,比如函数编程法,,OO编程法,AOP编程法,但是这些都是狭隘的.真正的范式是一种大的概念. 在最开始,可将范式想象成一种特别聪明、能够自我适应的手法,它可以解决特定类型的问题.也就是说,它类似一些需要全面认识某个问题的人.在了解了问题的方方面面以后,最后提出一套最通用、最灵活的解决方案.具体问题或许是以前见到并解决过的.然而,从前的方案也许并不是最完善的,大家会看到它如何在一个范式里具体表达出来.尽管我们称之为“设计范式”,但它们实际上并不局限于设计领域.思考“范式”时,应脱离传统意义上分析、设计以及实施的思考方式.相反,“范式”是在一个程序里具体表达一套完整的思想,所以它有时可能出现在分析阶段或者高级设计阶段.这一点是非常有趣的,因为范式具有以代码形式直接实现的形式,所以可能不希望它在低级设计或者具体实施以前显露出来(而且事实上,除非真正进入那些阶段,否则一般意识不到自己需要一个范式来解决问题).范式的基本概念亦可看成是程序设计的基本概念:添加一层新的抽象！只要我们抽象了某些东西,就相当于隔离了特定的细节.而且这后面最引人注目的动机就是“将保持不变的东西身上发生的变化孤立出来”.这样做的另一个原因是一旦发现程序的某部分由于这样或那样的原因可能发生变化,我们一般都想防止那些改变在代码内部繁衍出其他变化.这样做不仅可以降低代码的维护代价,也更便于我们理解(结果同样是降低开销).为设计出功能强大且易于维护的应用项目,通常最困难的部分就是找出我称之为“领头变化”的东西.这意味着需要找出造成系统改变的最重要的东西,或者换一个角度,找出付出代价最高、开销最大的那一部分.一旦发现了“领头变化”,就可以为自己定下一个焦点,围绕它展开自己的设计.所以设计范式的最终目标就是将代码中变化的内容隔离开.如果从这个角度观察,就会发现本书实际已采用了一些设计范式.举个例子来说,继承可以想象成一种设计范式(类似一个由编译器实现的).在都拥有同样接口(即保持不变的东西)的对象内部,它允许我们表达行为上的差异(即发生变化的东西).合成亦可想象成一种范式,因为它允许我们修改——动态或静态——用于实现类的对象,所以也能修改类的运作方式.在《Design Patterns》一书中,大家还能看到另一种范式:“继承器”(即Iterator,Java 1.0和1.1不负责任地把它叫作Enumeration,即“枚举”；Java1.2的集合则改回了“继承器”的称呼).当我们在集合里遍历,逐个选择不同的元素时,继承器可将集合的实施细节有效地隐藏起来.利用继承器,可以编写出通用的代码,以便对一个序列里的所有元素采取某种操作,同时不必关心这个序列是如何构建的.这样一来,我们的通用代码即可伴随任何能产生继承器的集合使用.

抽象在软件开发中的重要性是不言而喻的.如果一个系统有了正确的抽象,那么这个系统就更容易理解,更容易维护,开发起来也更为高效,最为重要的是也更容易把事情作对.Grady Booch甚至认为抽象是应对软件复杂性最为有效的手段.在面临一个复杂的系统时,往往只要再提升一层抽象层次(当然要是正确的抽象),那么该系统就会立即变得清晰、简单,理解、开发、维护起来也更为容易一些.不过,值得注意的是,虽然有了一个正确的抽象后,可以大大降低理解、开发和维护的难度,但是要想得到一个正确、合适的抽象却是非常困难的. 提起代码自动生成,可能大多数人立即会想到这样一种情形:只要获取了系统的需求,那么就会自动地从这些需求生成系统的代码.这种想法固然很好,但是在目前的科学发展水平(这种技术不单是软件技术的问题,它还和人思维的生物基础有密切关系)下却还无法实现.需求和能够自动转化为代码的精确的形式化规范之间有一个巨大的鸿沟,目前这项转换工作还只能由人来独立地完成.因此,这种技术在目前来说只能是一个神话.我们在本文中所指的代码自动生成是针对比较局限的领域而言的,即需求已经被正确的理解并由人转化为解决方案领域中的抽象模型.代码自动生成并不是为了替代人去完成系统的软件开发的,它只是一种支援抽象的工具而已. **结束转载**

###### 架构

成熟的程序产品应是大量人参与完善的。这种架构之一就是core+pluggins比如wordpress,甚至linux,故**架构一词,其实指应用反应到软件抽象上的模型.**

**架构最重要的，应是提供正确的领域抽象体系**（在复用了其他外来库的情况下，也至少应在它那个层次提供正确的抽象和接口），而不是设计模式语言技法等复用抽象，正确的抽象对专业程序员的复用目的的参考价值始终是第一位的

我常想，架构的合理性到底在哪？首先，它不应该隐蔽领域抽象，而给复用它的程序员一套纯粹的复用抽象（而这是面向接口的编程积极提倡的），因为这样一来，专业的程序员看不到这个程序在这个领域的抽象所处。

软件主要是面向应用抽象出来的，抽象出一个新领域然后对其编程，这就是架构

程序最基本也是最先应被考虑的问题是抽象，构架，和产品之间的关系的讨论，而往往，这些主题又是编程的高层主题。

**库一般都是General purpose的**（除了纯粹的工具库），因为它是被设计成供程序员使用的作为产品级的东西，所以它强烈面向可被扩展，从抽象上应提出一套架构，包罗一个领域尽可能多的抽象。

所以库的抽象架构应保证将其核心部分保持在顶端，因此，库的抽象架构关系着这个领域的产品体系的实现架构，这二者并非是一点关系都没有的。

什么是架构,架构是设计的上上层部分..比如网络七层模型,甚至PC的冯氏模型..这些设计的上上层部分深刻影响了计算机后来的东西.不可轻易更改. 设计都是作为一体来考虑的，是这样一个“产出一件有机产品，而不是大量产品材料”的过程，所以任何设计都是一种产品设计，故都是一种同时顾了可扩展又是作为顾本自守的一种产品设计，而同时存在的，对内它宣称是可扩展的，然而对外它一定是一个“一次性完成”，“一体的”(而不是组件化，零散的小件)，独立产品一种独立设计 所以,如果你不是专门为了通用的目的考虑,就根本不需要开发一个库 为什么说架构是重要的?架构使抽象置于高层,使实现置于低层未端或者完全独立高层逻辑成为plugable的东西.(想象WIN的HAL.DLL) 往往有时候,,真正的再编程能力在于对架构的掌握与分析与学习,,,而语言层面的细节比较容易学习,对物件事物的对象拆解也是仁者见仁智者见智但在有文档的前提下也不会差到哪里去的问题. 在进行一个大架构开发时,应该为使用它的用户隐藏一切底层逻辑,而向用户提供高层应用逻辑(注意这里的说法与前面不一样),而即使是这些高层逻辑,也不应让用户完全理解它们的实现逻辑,系统应该隐藏那些实现接口,而向用户提供那些直接能驱使系统逻辑工作的接口,,比如参数填充,或数据驱动,这个应用一个具体的例子就是OGRE图形引擎,它的rendersys的render()接口是一个callback,,,仅仅在用户指定加载到场景中的资源并由rendersys确定渲染后它才开始自动渲染(由ogre调用),无须用户调用, 而且,如果要为一个大构架增加调用第三方组件时,最好能保证这些组件是可拔插的(而系统原先为它们预留过接口),,即这些组件与主构架是相互独立的Dependencies,portable,plugable的

大层次称为架构,可能是不必显式在源码中(可能在文档中或应用中)显式表示的模糊抽象层次,即它是一种相对源码来说,概念上的层次,属于设计中可以不跟源码相关的部分
**有些时候，对应用的设计（形成的方案）也对程序设计有所影响**，设计好了，程序自然就清了
所有的事物都可以被重新定义,对于指代这些事物的名字,我们所看到的都不会只是像它们今天那样,而是发展变化的, ,因为事物本身是会发生变化的,而编程界对他们的抽象,,也是一个从不完善到完善的过程,.,,体现到具体的编程,设计是变动的,软工过程是一个动态过程,游戏是什么,魔兽世界,斗地主固然是网络游戏, 但BBS论坛为什么就不能和魔兽世界一样被归为网络游戏,,退后一点说,古代的” 蹴鞠”是一种游戏,今天的足球运动有它的国际惯例标准,可也许明天会出现其它另一种叫手足球的游戏. 超前一点说,其实火星人可能也在玩一种叫＂游戏＂的东西,,,这就是重新看待一个领域的抽象,,给一个术语重新格定它的含义的范围,如果性质相同或相似,,就整合它们为一个新的或更大的概念, 我们所看到的概念,,如果重新被设计,,会产生很多新的抽象(在另外的维度上甚至会产生更多抽象,只不过我们是人,有限的生命不能允许我们同时或异时站在多个维度去想东西)

这种分离与整合现象其实在IT界每天都在发生,,facebook是个例子,还有adobe的Java developer ide? ecillpe??,Java?平台开发库将内存流,网络,本地文件都看成"流",,这就是对一个术语重新进行定义,格定它的范围,,而这是合理的,,因为我们对一个术语的定义本来就是历史现象,当历史发展了,,一个术语要么被增加新的内容(量变),要么被完全演变,,成为一个新的术语(独立发展成一个新东西,虽然原来的那个术语也有效)

再发展形成一个架构,将它们发展成此架构下的分支实现,,比如facebook,它以技术的形式统一了很多web2.0的应用,,,这就是说,应用这个东西,,是可以以技术的形式被统一的,,,从架构web2.0的眼光来看,,blog,视频点插,,,诸多web2.0应用,,都可以被看作为web2.0,,,

比如XML,这是Sun递交给W3C的,知道由XML产生了多少技术和术语吗?反正我都不用再举例了,这种现象的本质恰恰正反映了XML本来并不是一个大领域,本来只是源于Web上文档交互的标准化,这是泛说(把XML泛化到了一个标准),当它与数据库结合时便能产生XML Native数据库(还有XML-Enable DB等),当它与J2EE的JMS结合时产生了JMX,当它与数据打包结合便产生了XML作为最外层的Wrapper(比如WOW用XML+Lua,它的XML封装了界面编程代码等) XML只是一种思想,所以为什么不能把它发展为一种数据库呢 再比如J2EE大领域架构的提出,结合设计模式和当前很多流行应用提出来的,这其实是一种再亲切不过的技术规范了,当然并不是每个问题都大到跟J2EE相当,但是对J2EE的研究行为几乎就代表了其它事物的研究行为. 这就是Sun的泛化与组合的思想具体体现,他们玩的不过一种“抽象叠加”,“原语泛化”,“组合成繁”的玩意罢了,然而,这就是导致今天这个世界潮流的思想根本.

>你真的以为计算机领域每一个知识点都可以被写成一本书吗,对,可以！但是这种现象反应了什么呢,这其实正反映了每一个知识点都是有限的(一个再小的问题都可以自成一个领域这是对的),只要在当把它放置到一个大领域内看待时,当它跟其它知识点或事物产生联系时才能发生更多的知识,这些联系和原来的事物本身便构成了这个知识点或事物,这样说终究难免有点深奥,但其实我真的有所指的,下面道来 记住:有时只是为了纯粹创立一种学说,而不管这种学说有没有用,很多理念与概念就会产生.

计算机领域的大量概念本身就具有具高的思哲性,需要你从思想上突破去认识它.
感觉Sun公司全部都是思想家,他们特别喜欢做架构,而Microsoft的全是修理工,特别喜欢做细节,珠不知,有些思想一出来可以省去好多细节,有时不是缺少细节的问题而是缺少一种思想的问题,微软连这个道理都不明白吗?还是微软有它自己的更大智慧?

**所有的设计(和由此产生的新知识新应用),都是一种人类知识的由繁到简,那些好的生存下来,不好的消失,所以,都是一种临时品,总有随着历史发展出现的新的替代品的出现(我们不应该全盘学习,比如如果不用到讲究极度求业务逻辑的企业开发的EJB,就不要去学它),**那些好的,会最终保留下来,和由此而生很多应用,,这就是sun所玩的游戏,,比如它提出一个"xml",,实际上xml的最高境界就是＂文档互换的标准＂,,由于xml的成功流行,这由于它是符合应用的,它就成了标准,实际上如果随着历史发展,xml就会过时(Ｊnos出现了),,xml只不过是人类知识的临时品,,,总会有它的代替品出现,xml相对"文档交互的标准"这个说法是个实现,而＂文档交互标准＂这个说法是个思想,一种思想反映在ＩＴ界,可以用代码实现(细节级的),,也可以用构架来形成一个观念上的应用规范,,比如ＸＭＬ规范,,这种思想一定要理解, 也即, 有时,不只是创建新事物要求定义接口和定义抽象层次,,有时对现有构架的集成与分解的需要使我们需要接口和重定义抽象层次(这个从JAVAEE的一系列架构中可以大量被看到,客户端层,表现层,业务层,数据层,整合层-也即Middle ware层,资源层)

火星人也把他们玩的一种东西称为＂游戏＂,,任何到现在为止我们能耳听目见的东西,,其实都不像我们想象的一样简单,,当你学习西红柿的单词时,如果你不能了解到它其实是一种外来词,,这种现象,,这种对一个术语的＂历史抽象＂,,那么你就不能有效地学习它,只能说片面了解了它,,而这对学习是不利的? 应用越来越接近人了,比如web2.0,3.0的出现,这是指软件产品的应用,实际上在软件被作为产品被产生出来时也作了靠近人的调整,编程领域的三个东西,问题域,方案域,人都在相互影响,这种影响产生了一些技术,导致了一些编程的变革,并最终与人们的观念结合,比如OO,比如设计模式,这也将导致架构变成软件的功能性"实现"要考虑的,在某个维度上加深了复杂度,然而却在另外一些维度上提供了简单的形式和更有效的应用

游戏多设计性就像OS一样，有hosting www 的appcloud,hosting webapp 的webos etc..语言可以是各种层次的DSL一样。

以上谈到的对一个问题的解决（这里是解决设计问题）往往存在多种解法，每一种设计法都只是万千可行方案中的一种（理论上，方案域不止一种，设计是多样的，但**业界有对问题形成的固定的方案和抽象，这些称为方案域，实际上更适宜被称为标准方案域**）

多维这个字眼本身就提倡从多个方面(可见多维就是多方面,当我站在某个维度为我自己说话时,我将同时失去另外其它的维度)
某些东西越来越统一和规范了,这加大了学习的门槛,比如xml出现,就统一了文档交互的格式,并导致了很多逻辑知识,产生了一些新的逻辑,需要被学习,但这是合理的,因为形式更加简单了统一了,并改变了一些应用的形式,比如软件分发delopy的统一形式等, 另外一趋势,应用越来越分布了和趋向web,这实际上是很多年前某些大公司的战略,总有那么一群人(有些人研究应用形成架构,有些人研究编程低层形成架构和思想),先知先觉地认识到一些东西,比如.net的出现,网上的资源服务器越来越变成一般应用服务器,富客户端的flex,silverlight等等,只是它们是慢慢被民间所识所学习. 一切技术都是面向被应用,因此人无论如何都是主导.将反过来最终影响技术的被利用形式而隐藏了低层实现,一些离最终应用跨度太大的低层实现不必知道其原理,靠近人的一端要提供尽量简单的形式,比如xml,比如oo,面向机器的一端永远有它的实现.

越来越趋于WEB这个粒度(粒度是我们作原语设计时用到的一些辅助用词)这个事实表明,分布式计算和面向构造软件设计的企业部署需要被学习. Dcom是微软用来抗争Corba的东东,,微软是一个很有自己理念的公司,Java等的崛起,使虚拟平台呈现多元发展

比如j2ee的规范,数据库系统的完备性规范.只有这样东西在思想里被界定了,才能着手实现.(也就是“接口与实现的关系了”)所以我们常说“符合j2ee规范的实作品”. 抽象要适中,不能抽象得太像了,为程序员复用的相对低阶接口变成了为脚本程序员的高阶接口.而且,设计要从下而上,从小积蓄成大的,不能一开始就怀着整合的思想从大处着手,否则即使完成设计,在后来也会发现很多设计时未知的东西,因为有小才有大,而大,只能更大.这也是过设计产生的原因.

在上面提到的标准一字是什么意思呢,其实这是个很重要的词,比如XML,,W3C,,ORB这些都是专门提出标准的机构,,corba为解决分布式处理环境(DCE)中,硬件和软件系统的互连而提出的一种解决方案；编程只是为了能为思想提出一个实作品,,J2EE提出一套WEB服务器的标准,然后有各个商家去实现它,通用验证的"实作品"才能称为符合J2EE标准的,因此J2EE只是一套标准而已,再如ISO的TCP/IP协议,存在一种叫RCF的东西,人们提交标准,只有那些考虑到可以作为合理的,通用的标准才能被通过,并作为以后开发的标准,如果这个新标准在一种老标准之后提出来,那么基于老标准的开发统统都要"移殖",这样造成的历史复杂性就是人们给自身找的麻烦,只有事先提出一种好的架构(当然,这是一种设计,有时并不跟编程相关,因为在其它领域也存在设计,设计模式居然是建筑学部分大于软工学,可想而知,真正的设计是不分行业的,是一种考虑到历史,过去,现在,与实现无关的思想世界,)

复用由二次开发的程序员决定(这个事实决定了你将向它们提供什么大层次上的功能比如ogre的复合模式,大的逻辑或小的接口),所以复用是程序员面向的,纯dp的设计方案要求二次开发的程序员也要了解DP. 对api的调用在此设计的最下层,由二次复用者提供.(即数据由它们提供,代码逻辑由我设计) 其实你可以将复用抬高到场景这样的层次(这就是领域逻辑,当然设计也可不深入到这么高的境界,这就是代码模式,设计模式和现实模式之间的整合设计所在),这是由复用面向决定的即需求决定的.而不仅仅是单方面的设计. 首先来对游戏进行划分.

------------- 抽象开发


设计能力是显式类型语言普遍拥有的机制,因为像C++,JAVA这样的语言都有声明. 也有函数阵列这样的概念。

###### 开发中的语言模型与对问题的设计形成的方案

**在抽象一节中，我们谈到问题与应用其实是两个稍有差别的字眼，在设计层，应用代表着需求，问题代表着方案域，需求代表着问题域，注意，这是两套概念在不同环境下的说法而已**

我们见到的大部分语言都是通用语言(C++是,JAVA是,PYTHON是,C是),我们将语言要面向开发的逻辑称为“问题本身”,“逻辑领域”,对于编程,我们在本书第一部分的开头处就有一个形式上的定义,在那里,我们指出编程就是解决人,计算机,语言,应用四者之间的矛盾的事情,那么现在我们主要集中精神来谈语言和应用.
**从人的角度来看,编程就是解决需求到语言再到程序的矛盾**, 这中间存在的模式解决的方法,就是用一种已有的方法去解决类似问题的方法,就是代码模式,问题模式.整个计算机世界,就重复着这些模式,这是人类解决问题的本能,模式分为三种,问题模式(比如数据结构),设计模式(应该算是结合了问题和代码模式的综合模式了),代码模式(比如OO,高级语言机制),WEB领域是最能体现这三者关系(称为软工)的领域,因为这里面存在关于这三者的诸多矛盾和他们的解决之法. 语法是一种形式(所以称语言是形式语言),,**语义是一种意义,,,要深刻明白语言与语义的区别,和意思,语义就是语法表达到某个领域所呈现出来的特定意义**,比如xml是一种语法,但是它可以表达html,可以表达stylesheet,可以表达医学条目,还可以表达社会规则,只要我们定义一种DTD,语法有限,而语义导致的语义无限,应用最深克地与语义有关. 如果你有过写编译器或语言的经历,你就会知道语义在这个过程中所发挥的作用了,,,,不同的语言用于不同的领域,,所采用的语义也就不同,,数据库有它的SQL语言,,建模有UML语言,接口有IDL语言,,,等等,,,如果存在一种语义(并由此发展出一种语言),可以用来表示所有领域的语义,,那么由这种语义发展而来的一种语言就是元语言,,而XML就可以做到元数据,,YACC(编译器语义的编译器)在一定程序上实现了元语言,,而多范型可以称得上元设计了,, 作用何在呢? 每一个领域都有它自己的字母表(领域字典,,具体应如何理解呢,,比如在本书最后一部分提出的“虚拟世界逻辑”,在进行设计时我提到了很多诸如Actor,,,,Mission之类的用词,如果虚拟世界逻辑问题是一个领域,那么这些就是领域用词,如果设计模式是一个领域,那么出现在其中的各个模式和模式内用词都是DP的领域用词,但是这些要形成语法中的关键字),,,每个领域应当专门用一种语言来开发..有它不同于其它领域的语义(不跟其它语言一样),,语义是语言之上的一层逻辑,XXX学指出,,用一门语言比如C,C++或者仅仅用OO来描述全部领域都是不完整的 处在语言和程序之间的,就是语言用于表达需求和应用的语言机制和库逻辑了. 在前面我们不断提到,很多语言机制,当你做到用抽象的眼光去看待它时联系到它的语义,它才真正算是被你理解了,即如果你能从现实的应用开发这个高度和需求角度,突然想到你可能会需要用到C++的模板(假设你以前未碰过它或只是听说过),那么你才会真正开始明白关于模板的一些东西而不是从学习C++的语法书开始(要从人的角度到语言的角度再到人的角度,这个道理很简单,因为语用才是一开始人所关注和需要的,而不是语言本身).比如你的应用逻辑中存在一个循环你需要一个循环,而C语言的语法刚好提供了循环语句,那么你会主动去翻C的这种流程控制进行学习它,但这是例外的情况,很多情况下,绝大部分的应用逻辑并不直接对应到一套语法机制,可供你直接采用,完成这个应用到语言的映射.因为语法机制实在有限,更多的逻辑被体现到了这种语言的库中,或其它第三方库中(语法产生库逻辑,语法产生各种语义逻辑来映射应用,语法与库,语法与语义的关系请参照其它章节). 一门优秀的语言,应该像Python一样,用简洁的语言语法形式和库逻辑来灵活地表达应用,而不是靠复杂的形式取巧,对于对于字符串,Python就比C++要做得好得多,我们只需要简单地写一个lc=c

[c][/c]

[/c],3再也不用写诸如Listc&gt;clc=cListc&gt;()这样折磨人眼的东西了(python源码剖析序言). 即应用才是最终的目的现实问题,我们永远要先行解呈清和解决它,**最难的编程问题是认识你要解决的问题的问题,在编程解决一个问题的整个过程中**.语法问题的解决处在编程的未端(这就是所谓的编码和实现问题),应用开发更多地跟语义和设计直接相关,而非语法.无论你看了哪本语言方面的语法书,负责的都会告诉你只学会了基础,的确,比起对应用的理解来说,以及如何用语法表现应用,学语言语法永远都是基础[5. 高级的话题可以更高级,语言细节如此,应用也是如此,所以教材只能教你基本的东西,任何事物永远有它们关于应用的更多细节..这就是那些被称为创新的东西, 如果很多事情不是一开始有一个很广思的心胸和头脑,那么编程,只会是一种用现有的大家的东西,去实现已有的东西,非常无趣,所以,只有在意识中建立设计永远是编程的最高层这种概念,人才会主动去朝创新步进].明白语法只是第一步,你得明白语义,明白语义抽象到现实应用的那些部分.但是有人会说了,应用问题在一定意义上 — 比如提供了复用库,就转化为语言问题了,此时应用问题本身还是要搞清吗?要注意,语言会跟应用发生联系,但应用绝对不会跟语言发生联系,所以应用问题是独立语言和语言问题的要单独搞清的,这里我们谈到了语言与应用的关系[6. 一门语言的语法可以有限,但有限的语法可以呈现无限的具体语义,XML逻辑就是那样的东西],那么我们该如何理解C++的一些常见语法机制呢并联系到应用呢?学语言到底学它哪些用于解决问题的方面呢?
在C++的诸多语法机制中.类和模板都是代码结构,是面向人(解决复用和软工问题,处在人和语言之间)而不是面向机器(像数据结构处在计算机和现实问题之间,解决的是现实问题而不是人的问题),类提供了一个数据化“代码”的统一手段,使编程工作复用维持在这个高度上,但是正如上面所说,它没有解决实现问题.这也就是实现与抽象的区别所在.数据结构解决实现问题,代码结构解决抽象(到语言)问题.

###### 抽象语言

把会编管理机器集成进成为OS,把控制机器做进计算机即抽象出了OS的最初原型,这是一种设计的复合性,把编程集成进系统.把设计集成进语言.这些都是设计的复合产生的抽象.

>这些都是设计的复合产生的抽象.计算机编程界的解决方案会越来越复杂,这加大了抽象对于编程者的不透明度和学习曲线,但只要理解了基础,并同时相信设计的复合性原理,那么从一个编程者的角度来看,一切倒不会显得那么难了.这就是学习应提倡深入浅出的道理.

因为功能是逻辑叠成的产物,越到底层,它对高层的逻辑依赖应尽量少,因为高层往往是应用逻辑,而底层往往是功能逻辑和业务逻辑(高层和低层通过一个隔离层意义上的逻辑来达到功能上的完成但又不致于增加这二个层次上的复杂性,使得在这二个层上的工作可以分别完成),因此底层核心架构应尽量简小精短(比如linux的core,但其中的应用可以无边无际),但是简小的同时却要提供最大程序上,或全部程序上的可扩展性,这样在完成了整个core后,后面的功能慢慢趋向应用时,就可以不致于改变到core,也即这个core可适应一切小,中,型的平台,不必做重复工作．或者即使需要被改变时,涉及到这个core的修改量也尽量小． 对底层的逻辑应尽量提供迂回用的接口,迂回即抽象,增加了迂回即增加了另种一种维度上的抽象可能性,而维度永远无穷无尽,因此抽象以任何一种姿态被创建都可以是一种新的抽象,我们用代码的形式表达我们所需要的功能,即用计算机能处理代码的本质维度摸拟人的思想功用的维度,这就是"原语设计"的概念所在 逻辑的抽象粒度永远有它关于具体的复杂性,我们不能定义一个具体的逻辑块,指明它为core或者还是应属于core,但是正如这句话说过的,问题有它自身的复杂性,因此我们应具体问题具体分析 这是哲学所指明的,哲学不是人的东西(虽然它是人发现的),? 底层完成了(底层往往是一些首先要解决的逻辑或者在设计意义上具有优先产生其它事物的概念体),其上的应用可以无边无际,但应用应尽量追求形式简单,一个合理的架构和其上发展的应用对于人来说应越来越简单,,,这才是合理的,我们不能掌握的复杂度应尽量隔离.因此我选用没有历史复杂性的open jdk,gnu c,拥护开源的linux

###### 设计与编码

请分清编程与编码二个字眼间的不同，编程包括编码。 设计跟编码之间无法精确定界,因为设计可以仅仅是提出一个用于实际编码所用的架构,也可以是考虑了所有编码细节的详尽设计,设计的最终目标可以是一张UML图,也可以仅仅是一张草图或一堆小卡片(Wildcard说法即来源于此,当然,并不一定要求设计要成档,但是将它具现化表达出来还是很好的行为), 设计本不存在?当你快速写代码时你根本不会觉得设计的存在,,这是因为编码就是一种习惯,而设计就是一种关于要写出什么样的逻辑的设想,用什么编码方法来体现,,,设计就是对编码进行控制和计划,,这里就是编码跟设计的关系,,难的不是编码,因为所有人都可以学会语法,学会写作习惯,,,但是设计样的文章却千差万别.;. 对于用OO表现的应用和设计来说,归跟结底,我们设计最终是想产生一堆有机的类文件(UML图也是,卡片也是),也即我们在进行设计时,我们的目标(Dest)是产生“编程领域对于现实事物或问题抽象的OO解(OO解只是解空间的其中一种而已,单纯使用OO的三重机制这只是初级和简单的范型,但已经是非常强大的范型,它产生的类文件已经可以实现出一个很大的架构,然而,结合了模板和策略的范型就更加是功能强大的范型了,可以更为灵活地产生出一个架构)”,这往往就是一系列的Class文件,而设计的源(Src)则是“经过了编程抽象的现实事物或问题”,设计模式就是用来描述这个过程的,然而它又跟算法不同,算法体现的是大领域内对于某个事物的解决方法(这就是为什么算法也可以用计算机来表达的原因所在)

这里首先有一个设计与编程的区别所在(人们往往把设计和实现对立而模糊了对设计的理解,其实,设计应跟编程对立被讨论,设计就是那些,语法与语义的关系,语义是语法写不出来的东西,而设计就是编程直接不写出来的东西,只是当设计反映到编程时,它也能被编程体现出来.这二者才是一对对立体,找准了这个才能正确地理解设计,就像对脚本语言的理解,如果你一开始知道它是系统编程语言的对立体,那么你就不会产生脚本语言是不是一定是解释语言这样的疑问,因为它一开始是非系统编程语言,其使用解释或编译是它第二个要解决的问题所在),但设计和实现无法分界,这首先是因为语言没能为它们提供一个有效区分的机制(Delphi 的单元文件pas中有接口和实现这样的关键字,C++默认将h文件和cpp文件分开,然而这都不是严格的抽象与实现分开的机制和行之有效的方法,这根本是因为这二者根本就是具体问题具体分析的事,无法在形式上进行区别,但提供h,cpp这样的机制也并非错误无效的方法---请参照选读中的“形式主义”),OC可用于设计中的抽象,也可以用于在先前设计抽象基础上进行的下一层抽象(实现).

>设计最终要被体会到源程序,如果把设计作为整个软工过程,那么源程序是这个工程最好的结果最终证明[7. 参见《源程序就是设计》一文,你可以Google得到它,或在本书选读部分找到它,注意那里只摘了一部分]. 暂且你不必理解什么是设计这样的东西(后面已有详尽的解说),你只需要理解,从设计到源程序,经过了如下二个过程. 一是脱离了语言的那些映射,即人们通常说到的设计一词的意义[8. 请参照我的《什么是设计》一文,这里的设计实际上是指大设计,指领域抽象,语言选择,这些东西,包括数据结构].它先解决那些与人有关,先于编程要解决的问题. 二是结合了语言的实现映射.即人们通常说到的实现。

那么是不是可以将抽象分层呢,一部分是DSL类,一部分是字串这样的计算机实现类,将前部分看成设计,后一部分看成实现,,但实际上这样也是不行的.因为无法精确给每一种这样的抽象分层,而且即使分层,也是有很大局限性的.

比如在库的设计和利用库进行实现这二个过程中,都可以写函数(以过程范式编码),显然地,库的设计是高度面向复用的,而实现是一种函数调用,然而为什么库的设计中的函数才是设计,而实现中包括了函数调用的函数体就不是设计呢?他们同样是有函数原型的接口的啊.这就说明了语言本身并不能严格化这个区别.能严格化的就是具体问题中的具体区别方法.
因为抽象最终要形成源程序,要在源程序中反应出来,而源程序是由自己或别人查看的,所以说抽象对设计是至关重要的,因为抽象是择其事物一方面或某维度进行抽象,所以设计不必大而全,那些“理想”靠近现实事物模型的抽象反而不是最好的抽象(比如严格用OO设计一个游戏的图形世界,把每一个树叶都封装为对象,还把导演,这样的概念抽象出来),因为这样的抽象往往太大了,或不必要带了太多错误的臆想.抽象只能是现实事物的一个或某些方面的变形.甚至带有逻辑模型抽象,而不全是实体抽象. Todo: 举出从第一部分,第二部分开头几节的全部抽象

###### 各种语言的设计层次

假设在语言系统(它包括三个部分,解释层 – 也即运行层,编译层,和设计层[9. 比如UML这样的东西,其实也是语言系统里面的,但一般现在的做法是将其与语言系统的前二者分开])中,我们假设这三部分是分开的.

C和C++这样的语言,其程序运行在OS上,更多的,是一种利用OS的功能性编程.即:

+ C,C++ : 它的解释器实际上是OS,所有的代码在OS级的执行路径上运行,无非是一些栈式数据和栈式代码.我们说这个层次是系统层. 它的编译器实际上是为了运行期而专设,从语法机制来看,无非是一些对栈式数据(类型)的抽象,以及一些对栈式代码的子过程抽象所形成的面向过程的东西,从库逻辑来看,无非是一些native程序.我们说这个层次是语言层. 它的设计层几乎没有,rose中对C++的支持部分可以说是一种,C++的泛型比C++的运行期OO更能在源码级体现设计.因为OO是要进入执行路径才能体现程序逻辑的,纯粹靠机器执行逻辑反映程序所要表达的应用.而泛型,在编译期(它相对OO来说,要靠近用户写源程序时那时要形成到源程序里的设计理念)就能体现一部分的用户设计.它给了用户控制设计,并将其反映到源程序的机会,《源程序就是设计》,而不是《运行期逻辑才是设计》.

编程是随着对人的抽象靠近程度而分层次的,这种层次我们可以在py虚拟机的组织中看到一个大概.

而Py语言系统,我们可以在其内看到一个明显抽象了的过程. 

+ Python : 它的解释器是更抽象的软件机器(你可以假设它的CPU可以直接执行C程序,而不是指令),它的这个层次是系统层.PY可以使用PYD格式的C库.

它的编译器实际上不太抽象,从语法机制来看,也是OO,而面向运行期的OO,是很难在源码中直接体现设计的.这是它的语言层.至于库逻辑,可以用封装了C库的转换了接口的逻辑,也可以用原生的py程序.

它的设计层也几乎没有.

那么,是不是可以提出一种全新的语言系统呢,比如直接在PY语言系统上改造,直接增加对设计期的支持?和增加编译器的抽象?

我觉得可以为py增加泛型.这样就能更大程度地体现《源程序即设计》 还可以为py增加一个front design的uml

Python的设计层主要有: OO本身 class里面的三重机制 descorator等这样的东西.

------------- 设计的方法

###### 分开与分块

分开设计是使人脑接受复杂事物的基本策略，分层设计是为了解体抽象使之不聚集，模块化是为了这些设计在各个程序间并行自治发展后却并不影响它们整体的组合

模块化与建立架构是一对相反也是一对统一的过程。模块化是为了给抽象组建立架构，架构化是组织抽象组为一个更高级的模块的过程，但是模块化并不一定是为了建立某种架构，模块化是为了不聚集，而架构是保证在一定的聚合度下为以后的分散作准备

###### 使用库与中间件简化设计

我们在前面说到编程是由算法,抽象,设计组成的,一套可供复用的源码或库本身就是一个包含了抽象到设计的过程,我们复用别人的库或源码时,也要在自己的源码层次包含一次抽象和设计,不过是对前者的更高层次的封装过程.只不过不需要对前者解决过的问题或抽象过了的抽象进行解决或抽象.
高层轮子往往难于精确找到(因为程序的最低层可不可间容的最小单位是函数和数据,这就是编程的复杂性的必然原因 - 此时作为另一种策略可用COM),而且需要学习,而且,因为他们经过了别人的抽象,往往显得“太像”或“不像”,所以,不如以他们为复用基础发明引擎,大多数人选择从C实现,.因为未抽象的有时甚至是未解决过的,未在计算机上实现的,需要解决一些其它问题,而未知的抽象,待实现的那些东西,是不能用于编程的.
软件只是可弃型的接口系统构成的一类程序系统(COM利用这种方式企图简化软件开发为接口组合过程,使之变成一种“更高级的独立语言的语言”).

###### 使用接近语义级的高级语言技法

比如接口,是一类抽象的尾端,复用性很强的普通中间件逻辑.只是因为它面向立刻被扩展,而不再是设计中的抽象.所以称为设计的尾端.

为了复用的抽象,就是接口.(源码和中间件,中间逻辑都可复用,但只有显式化的，专门设计为能很好复用的那一类中间逻辑的尾端段,才能称为接口)

###### 方法论

软件是复杂的.开发过程更是不容易控制的.

###### 产品设计
每一个问题域都有产品和产品级设计,比如图形界有编辑器,游戏界有引擎,编辑器,player等等产品级的程序往往是一套程序，这些程序组成了一条产品线，任何完善的程序产品，都有着完善的产品线支持。由几个程序组成。

###### 工具

在设计软件时,我们主要用UML工具,但是这东西是静态语言用的，始终要记得：**工具只是辅助手段，并不能改变设计的方式和本质。**

总结

-------------

从更大的范围讲,,任何一种设计都是自蚕自缠,,当然,适合当前应用的设计总是存在的
设计的合理性只能是相对的,我们只能做一种“目前最科学”的有限设计,而且这种设计方案也受到问题本身的影响,并不是所有所有目前合理的设计都要拿来用在同一个设计上

###### 业界的过设计与错设计

人们曾经认为，动态的web必定需要Flash这样的新解决方案，而今HTML5+JavaScript不但可以取代Flash，还可以做3D应用。
人们曾经认为，WebService需要一套新的行业标准，于是指定了SOAP等一系列协议，并历时数年时间开发了大量WebService平台和相关工具，而如今大家更喜欢基于基本的HTTP协议的REST方式和JavaScript本身的JSON数据协议，而且要简单高效得多。
我们需要的是一套连惯的方案，而不是一系列共存但无意义的方案，，所以mpge的定位是不是错的？
传统cpp多典范却没有一个核心，yake这样的game engine多典范，它们只是简单地罗列导入抽象，，并没有形成一个应用和设计一统的最小核心，而这才是设计的最终目的，所以要从根本的开发方式，甚至语言系统上去突破，为此我选择qt和quake engine

编程的最高境界是存在的，不是懂得抽象，而是懂得如何去抽象，在保持一个最小核心的同时，基于它的扩展可以与它形成机制与策略的关系，，即架构上的生态，，这种架构不但是开发架而且是应用架构，，，这样就可以避免多种机制带来的抽象过度问题。。

轻量抽象，保核向用。------------------- 轻量但不要过度抽象，保持一个面向应用的最小工业和教育核心。

对于编程语言来说。一些类型和三种过程式逻辑属于编程仅需的东西(有人证明这三种过程可说明一切程序逻辑)。有这些就足以描述编程所有已知事物.还比如gui就几种widgets，web窗体仅提供那么多的控件也是基于够用的原则。与winform对应

抽象必须适可而止 qt把不文书抽象的也抽象了应只管好自己的事 COM，IDL，JSON，SOAP，WEBSERVICES,REST等等都是业界过设计然后又重新倒回去的例子

>web让人们发现了很多过设计和错设计，比如使用c井而不是c井,json而不是xml webserives,C++的oo而不是template范型和元编程等等
计算机界的过设计与错设计

nosql也是一种过设计的产物 json,plain web也是

1,corba有必要做成语言吗? 2,uml有必要深入到对方法的设计吗? 3,模板有必要生成为目标码吗?cfront方式不好吗?

###### 银弹问题

有没有一种编程理念能让我们彻底不考虑这些的东西,而使编出的语句和程序能够映射到机器逻辑呢,,这就是说,我们想隐藏机器逻辑,和语言对于机器的逻辑,,只有这二个东西被屏蔽了,我们才能站在非机器的立场去设计现实问题, 语言机制作为库实现,,

语言尽可能小,直接面向真实平台不要虚拟机,因为加了虚拟机执行方式会很慢,,而且,语言应作为OS的内核一部分.就像WINDOWS把GUI接口加入core一样,这样的语言执行效益很快.这样的语言也就称为系统开发语言..与之对应的是应用开发语言,或称脚本语言.

在底层,汇编是一种几乎对应机器语言的东西,因为汇编语言无语法.只是名称指称,助记符..C作为中间语言,汇编只需要提供接口给C,C还应在编译期提供一个编译期多态

为什么脚本语言多称为语言粘合剂呢..因为脚本语言往往提供对多种系统编程语言.数据类型的内存模型的封装.提供了对这些语言的多种接口,,,但更主要的,脚本语言被称为脚本语言,,,更在于它面向用户的其它特域相关和特定工作相关的语言机制(比如Lua的多协程常被用来游戏,,而这显然不是通用语言应在语法级应提供的)也许脚本语言只需要提供与其它语言的粘合接口就可以了

在上层,我们应该提供一种"无语法"语言的DSL脚本(比如SQL,好像脚本语言跟解释型语言几乎同意),,这种语言最好还是无类型的,,这样做的目的是方便程序员,但不好用来开发平台逻辑(因为平台语言,要求严格的类型机制) 我们看到的大多数语言都是图灵完备的,而我觉得C++应改编成一个解释执行、无语法的语言,因为应用语言往往需要做成即时修改的脚本语言

>你需不需要一个库 IT开发中,,只有属于底层开发的,,,一般才称为开发,,发明轮子,,,而复用成风的今天,JAVA这样的语言体现的是一种高级逻辑配置式的开发(高层的编程如web编程,都是配置式的),当然也算开发,,所谓库,是一种面向通用和复用的中间逻辑,,接口逻辑,而非终极的应用逻辑本身,,,库面向应用复用提供接口,而应用逻辑面向应用本身．语言的功能和可复用性,,一个很重要的方面是除了语言自带库之外,还有没有第三方为它开发大量的开源库

跟真正人写作语言比,汇编不是真正的语言,它只是电器化的指令,只是可以烧成文本格式 高级语言也不是,它只是编译器提供的的形式,烧成接近人类的文本 这二种语言在表达逻辑方面,描述的都是PC的功能. 真正的语言,在写作上是文章的格式,表达的是人类生活中出现的那些广大的逻辑.
我们知道,对于人来说,语言无非处理二个东西:简单的写法和更好的逻辑的表达,用泛语法处理写法,用泛型处理逻辑,那么如果能在编译器层次同时实现这二个东西,那么冯氏语言实际上就是某种自然语言了,这就相当于,举个例子,比如某种没有语法的逻辑编程语言(Aogol)了,我们抛弃了语言跟机器有关的那些东西,而且抛弃了语言跟语法有关的东西,更甚至抛弃了OO这种强制加在我们观念里的东西(它连接了同时语言,应用,人),以我们举的例子,无语法的逻辑编程语言来说,我们也要抛弃基于逻辑这种死的方式,我们需要一种跟自然写文章一样无限制的编程方式.这种语言最接近描述性的语言或UML图,但是我们UML图只是编程的第一步,因为它最终转成类,还是进入传统的编程,我们要做的,就是把做UML图当成编程的全部.

泛语法和泛逻辑之间的关系应如何处理呢?具体到编译器,应如何构造呢? 我们知道,历史发展到今天,编程语言一直是由执行系统撑起来的,然后才是语言.
比如在裸机层,在OS层都是这样的,此时的执行系统是严格的面向未来编程需求的执行系统, 后来,发展出了jvm,pyvm,在执行系统上进行了强化和优化,加进了更强大的异常,GC等,不过其职能本质并没有变,依然是面向某种语言的更好执行系统 我们要做的,就是把这个执行系统,做成独立的知识系统,然后上面的编程,才不需要处理生成逻辑这样的事情.即,我们把一部分传统编程方式下的标准库的东西下放到执行系统本身,此时的执行系统就成了带有知识性的智能系统了,,,具体的方法,你可以联系:把py全部标准库做进py vm,py标准库层次上的编程不叫编程,而是基于这个知识系统,以它们为机器逻辑,的新式编程才是我们最终要达到的编程方式. 那么,这样的语言在逻辑表达上会不会有欠缺呢? 不会的,标准库的逻辑表达严重带有语言跟机器的影子,我们会在自然语言层次去除它.这样,系统编程实际上还可以用.

>一种思考idl+template实现DSL和MDA

template使设计维持在一个层上,隔区了语言的抽象语法层,idl+template的解决方案,不是idl是template的一部分,而是关于idl的template,template在idl之上,作规范设计层. 把idltemplate弄成预处理,这对py也有意义(它不提倡过长的编译过程).但实际上,idl化了的template使template有了一个idlcompiler,是具体语言的前驱(一个带有真正语法特性的预处理),而不是整合进入了具体语言,因此它对py也有意义.因为idl生成具体语言对应物的顺序必定是一前一后的. 去掉idl中的线程,具体类型,等细节逻辑? 这个预处理idl中,规范了三个东西.(对很多东西,都作了元编程)对具体语言的映射中,1,对具体类型的映射是元而泛的.(实现)2,对设计手段是基于template泛的.(设计手段),对于应用方案和厂商规范的直接表达(不以方法集为手段,而是以template中的concept为手段). 于是idl不妨发展成cdl,即concept declare language!!! 那么如何用template定义具体语言呢(作MDA编程)?minilang直接由template生成?直接生成c++ compiler?因为idltemplate的一个源程序中,写出了类型,写出了策略,又写出了应用方案,这是一个语言最主要的部分,(余下的工作就是定义类型之间的语义,语句,及表达式) 因此DSL不是梦想了..哈哈哈

>well transitable platform and language formed programming

业界的反工程，盲目集成，推倒重来的例子也不少，比如json,text db,,lightweight web

we need a more abract wine like thing ,,,or need a jvm,we need nowadays-cpp or cplusooplib langsystem？ 

>>wtos

welltransport(过渡的)edu os,一个同时面向开发者和用户，可良好过渡的os,for developer and user 

well transitable os的宣言：跟着业界走，不如跟着自己的心走，那样跨度太大了，比如，c还没怎么样呢，就到cpp了，然后，平台与语言集成，就到java了

开源的jvm等只知道集成不知道创新，其实不如vb加vbruntime的思想


>>No OO Cpp设想

总想去掉cpp的oo.转cppscript的oo.禅学美宗？

in my no oo cpp lang system .there is no cpp .just c plus oop lib micmiced cpp .and cppscript micmiced py .no vm scripting lang lib可以作为我的well transitable lang,wtos的一部分

can lcc compile the whole cppscript(cpp的一切做到库，重库而非重语言，或者说，为求稳定一个语言标准目的，而将一切扩展做到库级)
c with oop and then with dymic scripting element is important and mecessary,both better implememted in lib level

方式不同在于将语言内置的语法分离为外置的库。

wtc所有的库与扩展都在库级并不触动语言，如，ndk,apr vm,oop,dyp,domain libs 

note:作者后来觉得现今的CPP其OO和TEMPLATE本质就是库级的。参见《C++的UDT语法语义系统》开头的部分。

>>native programming and high domain no vm scripting programming on wtos:1.use boost.python to make cpython as cpp.dlr whichis simliar to c#.clr 2.use only boost.python extensions 3.利用cpyapi(py runtime api in c)进行extending编程，就是no vm scripting(不写py代码，而是直接用C++加BOOST.PYTHON的方式写面向cpp.dlr的代码)

在我的wtos体系中，ndk（默认是windows）与apr并列，并不直接用ndk,而是用强化了的apr,它相当于jvm这样的non native dk

os:windows
lang:c,glib,glibc,cpp,stlport,boost,qt,mono,c#,clr(user applicable lib),boo(as toolkitlang)

native programming中，c,cpp都是必要的，cloud programming 和ual中，c#和tcl#都是必要的

在理想的情况下，这些库是这样层次组织和被运用的

glib based on glibc

boost based on glib
qt based on boost

clr.form based on qt#

user 适用 抽象库,用户适用的，这样的lang应该是横跨实现，开发，领域的类objc一样的三合一语言系统
dotnet,jvm这样的语言和平台应在语言级提供对cpp native types的binding逻辑，而不是仅在库级binding,看objective三合一做得多好，通吃sys实现,desk开发,appdomain脚本

*/