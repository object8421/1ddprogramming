


os
-------------

###### 软件平台中的OS

OS最初的作用表现在哪里呢？打个比方，我们知道PC都有一个BIOS，它寄宿在主板的flashrom中，发挥管理配置整个机器全局参数或控制的作用，那么ＯＳ就是另外一种BIOS,只不过它寄宿在硬盘上，相对bios来说，它是PC的ADVANCED BIOS，是DISK ＢＩＯＳ，最初的ＯＳ-dos，就是一个不折不扣的advanced pc bios system on disk。它作用有：硬盘／文件管理。运行程序的作用。

###### OS的分层分级设计

在OS的设计中，也经历了这样的分层分级的设计。 先是抽象硬件功能为软件上的vm，再是虚拟软件vm为大量的软件vm,其过程：是串行内存单道程序,再是串行内存多道程序,再是假并行分时系统。

计算机的功能本质在于提供“任务机制”以支持“计算”, 从软件上扩展原始计算机的第一步是强化它最根本的执行程序的环境的任务 (当然,外部子组件的接入[13. 在这个接入点,又会产生诸多逻辑,比如,文件系统与网络会产生网络文件系统.]及IO是它解决的第二个大问题大方向,即要解决二大问题,第一步,“PC是一个内部可运行多任务分时的计算系统”,第二步“这是一个外部可拥有文件系统,可连接入网络”的PC系统.),首先,内存多道程序系统[14. 抢占多任务:即多个任务以一定优先级,有风度地“抢占”CPU时间.],CPU分时系统,支持“隔离的任务,多任务间协作[15. 所以,任务这个概念要优先进程被讨论,因为它跟计算机挂钩,而不是一开始就跟内核有关,当谈到进程,就涉及了调度,进入了os core的范畴,而且,作为内核的任务,即进程,其实可以同时代表任务的时间方面,和空间方面,计算机要完成二个目标,任务和(对CPU的)IO,而不是进程和中断,因为任务不光包括进程,还包括线程,等任务系统,任务指“任务系统”,是一类问题,而不仅仅进程一个手段.]”,所以在只有一份CPU和内存的情况下,它利用软件技术(即制造一个os core[16. 注意这二个概念是不一样的,前者指与桌面环境等对应的os内核部分,后者,指内核中的任务部分] – 利用其中的os kernel)将裸机抽象成“多任务分时运算系统”.其中,内存主导运算的“存储”方面即空间方面,故多任务运算系统将其抽象成“平坦的进程空间[17. 平坦内存,是非层次的,比如实模式下的段:偏移]”这样的概念.CPU主导运算的“执行”方面即时间方面,所以分时运算系统将其抽象成“线程或进程”(所以,当说到进程,其实它就涉及了调度,同时涉及到任务的空间和时间方面),任务调度主要是协调任务对计算机系统内资源(如内存、i/o设备、cpu)的争夺使用.进程调度又称为cpu调度,其根本任务是按照某种原则为处于就绪状态的进程分配cpu.由于嵌入式系统和标准系统中内存和i/o设备一般都和cpu同时归属于某进程,所以任务调度和进程调度概念相近,很多场合不加区分,下文中提到的任务其实就是进程的概念 操作系统的多任何管理有协作式和抢占式,前者当一个应用程序放弃其对CPU的控制权时,才能进行任何切换,缺点在于,如果这个程序因错误导致不能成功交换对CPU的控制时,会影响其它程序对CPU的正常使用.甚至使整个OS出现问题.而抢占式,把OS而不是各种程序作为主体,来控制对CPU的使用策略,保证各个程序对CPU的协调使用.从而避免不良问题的出现.

这样,一台硬件的计算机,就变成了几台软件上的计算机(即每台计算机一个CPU和一个隔离了的可编程空间,然而,要知道,它们不是结合的,解决分时的过程和解决隔离的过程是在不同层次上进行的,分时是OS core级的,而隔离是进程级的).支持多个程序的“假同时“运行,进程就是这样一个“软件上的计算机”至于对于PC要解决的第二个问题,利用中断技术,可以支持多个外设接入CPU和主存.支持PC的整体意义. 再者,内核并不仅在于简单的抽象硬件,它还完成对于硬件功能的高级定制功能(这就是建立在抽象硬件层上的初级系统抽象层[18. 内存管理(cache,主存,页面文件),,CPU管理(进程管理与进程调度)文件系统(缓冲,等)]),比如如何把CPU处理能力,内存能力,转化为软件可以使用的进程资源(也即我们前面反复谈到的保护模式那些东西),把网卡资源转化为Socket(跟进程一样是种OS资源),,这样,所有的其它更高级的软件逻辑就可以在这上面开始被搭建起来了[19. 这是一个什么样的过程呢?首先最底层就是LINUX Core,比如,SDL逻辑和XML逻辑封装进linux内核,作为CUI中为后来所用的GUI接口,然后在这基础上发展出一些封装SDL的高层库(使得以后的开发不要动不动就访问硬件,而且这样也是不安全的),,用这个库发展出一个桌面环境,比如argr,比如游戏什么的,就直接使用SDL就可以,其它的应用逻辑(除了玩游戏等桌面应用),比如网络应用,因为内核中有SDL和XML,至少它们的界面已经解决了,其它的问题就是其它的问题了].

这就是OS产生的根本思想.和它完成的根本任务.整个OS就是为了解决这个问题而导致的大量小问题的集合.

即,首先,操作系统是基于“将CPU分裂成多个CPU”,将“CPU+内存”分为多台PC的这样一个本质(它是软件上作为“机器”的软件).剩下来的,就是如何用抽象的方法(分层,分级)去实现.

###### to be a abstracting hardware machine

在OS实现中,第一层便是硬件抽象层.

###### to be a task machine
在OS实现中,第二层就是对CPU的保护模式的抽象. 任务是机器级的概念,而进程是OS级的概念,比如,一个32位CPU支持的任务空间是4G,但在它的一个OS实现中,其进程空间不一定是4G.

###### OS层
在OS实现中,第三层就是进程机制.


OS Kernel[10. 内核跟OS本身不是一回事,比如,Linux内核跟Linux OS不是同一概念]
-------------

os原理我们在前面说过了,它代表着软件体系这个大意义.
操作系统是一个大的概念,它小到只需要包含一个内核,大到可以包括内核层,开发支持层,AUI[11. AUI是一个层面,比如shell,developer support编译器,rpm,等等],调用层,硬件抽象层,应用接口层这样的操作系统架构[12. 参见Google手机平台,这本质是因为软件是抽象,所谓抽象就是在不同的抽象层次完成不同的工作,操作系统作为软件也不例外].

而接下来,我们谈到的oskernel即是这个体系中真正使计算机成为soft machine的核心 - the kernel.

the kernel

其实，OS内核是个太杂的复杂体，事情分开说就很容易了(不应将所有的东西一股脑做进一个叫内核的东西里面，，要把内核仅仅看作是一个外面模块，这并不表明它是一个逻辑上的所有东西，它内部的逻辑是分层级的可以分清的)，内核首先是虚拟CPU，然后接入PC子系统到OS，这二者都进而形成软件

**os kernel使计算机成为soft machine(为形成进程铺平道理,而进程是soft vm),**它功能有二， 1.在核心部分提供了相关服务，很难说内核的这种作用是被动的还是主动的，可以说，它作为一个可执行体(由C例程组成的)，主动地调度管理进程(有剥夺和非剥夺式，这是指对于CPU时间的调度)，管理进程内存(内存管理它的全称应是“进程内存管理”)，协调进程IO(也是一种调度，不过是调度争夺虚存而不是CPU时间)等。也可以说，它被动地提供服务，比如它提供了进程间通信，于是各种基于进程通信的os kernel组件(比如文件系统)便可以使用它们。还比如，它响应来自进程的中断需要(内核例程就是利用中断异常实现的功能界面 ) 2,对于开发者来说，它提供了内核例程接口，于是，类似于posix的例程，可将它们进一步封装为用户级可用的高级接口(c run time的一部分)。

下面先来说1,软件上的机器,它完成二大工作,1,任务,它的手段是进程,它的机器主体是CPU和内存,2,IO,它的手段是中断,它的机器基础是外设,中的接口卡(中断是CPU的或硬件的).它的机器意义是“接入其它硬件到CPU和内存”

任务与进程的关系,就像IO跟中断的关系,它们不是相等的概念.任务与IO是计算机的概念,而进程与中断,是内核的概念.CPU,内存是硬件层的概念,接口卡也是硬件层的概念.我们知道历史上初级的OS,比如DOS,它的意义只是“磁盘操作系统”,这其实是IO层的工作(硬盘是周边设备,它成就的文件系统并不属于PC的主体功能,CPU加内存,即主存,形成的任务机制才是主体),所以它不是一个现代意义上的操作系统,UNIX这样的操作系统,一开始就建立了任务与进程,所以它才是现代意义上的操作系统的开始源发之地.

内核的二个意义是相互联系分层次的,比如,在软件上的机器意义上,任务机制,提供了“用户地址空间”,这其实就是“用户编程地址空间”,在用户程序支持体系中,它提供了“用户程序接口”,这就是“用户编程接口”system call,你看,空间跟接口都有了.

而且,在内核这二个意义层面的各个小层面上,也发生间纷繁复杂的关系,比如IO外设体系中的网络跟任务中的线程结合,会产生“异步I/O网络”这样的东西,还比如,网络系统跟文件系统,会产生“网络文件系统”

下面再来看,1,任务,解决任务问题,一般是从CPU分时,分道着手,和从主存的虚拟化(虚拟内存)开始,这就产生了同步,这里的同步跟IO中中断同步是不同的,然而也是相互联系的.这里的同步,是对“CPU时间”的争夺和对“虚拟内存”的争夺形成的,所以设计出“对CPU的管理,即调度机制(解决CPU同步问题)”和“对使用虚拟内存的管理,即Memeroy management(解决共享主存同步问题)”来解决.而中断又会跟它们二者产生联系,发展出“异步IO”.在处理发生在任务层面的同步问题上,有时需要屏蔽中断处理.

>用会编眼光看内核形态 : 内核只是一些运行时 用栈式硬件机的眼光来看,OS就是一堆跟普通C程序一样的函数调用例程和堆栈逻辑,不过，自开机以来，它就常驻于内存（OS中的os core），并首先被加载进内存的最前空间。作为运行其它程序的先头军。

内核不可能是一个进程,内核只是一些页,存在于主存的最开始处..然后通过地址映射(注意,仅仅是地址的映射)反应给各个用户进程.于是,每个用户进程,就是一台台“拥有CPU和内存,且拥有共享的内核OS的软件计算机,你看,同时在硬件和软件上都完成了这样的分裂” 它是某种服务性质的东西.为用户模式的进程提供生成和保障的服务.

不要把内核想象成比用户进程优先的东西,其实它们都是(用机器的眼光来看)程序,跟用户程序一样,平铺在任务空间里,只是CPU迅速切换,一会儿执行内核代码,一会儿执行用户代码而已.但是显然地,这二者在地位上还是在区别的,内核在自身的空间内,就有内核调度,对于内核中和用户空间里的任务单位(比如进程或线程),调度是分层的,内核线程直接接受内核调度,而用户空间里的进线程“映射”为内核中的进线程,换言之,来自进程空间的东西,是受内核代理的(才能被计算机支持),这就隔了一个层面.还比如系统调用,就跟VM中的中断处理例程体系一样,是“(软件)系统功能”的意思.它要被内核转为软中断,才能影响硬件.故跟内核直接操纵硬件是二个不同的层面的事情. kernel在物理形态到底是一个什么东西呢?它只是一些例程的组合?kernel mode stack?不是,这里有一个booting过程,我们知道,计算机加电时,如果BIOS发现硬盘开始处有OS时,它就把执行权给操作系统内核,比如linux core,那么机器就会进入这个所谓的保护模式下,保护模式一方面是为了更好地提供程序的执行,使它们不直接工作在硬件上,安全地运行在保护模式下,另一方面,它可以让系统内核有可能提供多用户多程序的执行方式(而我们在前面刚谈到,裸机的功能不够强大,OS正是从软件上去扩展它,比如提供更高级的更多更大的程序执行功能,而它需要CPU的直接支持,即我们接下来要谈的这种保护模式) 硬盘boot文件 我们知道，硬盘有不同的分区，不同的分区有不同的boot文件，比如grub支持fat,ntfs,linux fs等等，每一套”boot方案”一般都有二个文件，一个大小以它所占扇区数数的文件(bootstrap code)，以及一个ldr文件，前者往往被写进分区的开头扇区(也可以放置在硬盘上)，而后者被放置在硬盘上。 硬盘可以有一个mbr，各分区也可以有一个pbr，一般地，mbr指明整个磁盘的格式，比如fat32的mbr可以是dos引导程序(扇区小文件)，它上面可以放io.sys引导文件。 Fat32的mbr可以是nt引导程序(一个只占1-5扇区的小文件)，它可以引导放在其上面的ntldr Fat32的mbr也可是grub引导程序，它可以引导放在其上的grldr(根据menu.lst进行菜单的设置)，然后,grldr可以引导其它”boot 方案”(比如ntldr,dos) 而pbr可以在整个磁盘被引导的情况下，覆盖引导各个对应分区。 不同的boot方案可以”chain loader”，比如上面的grub可以引导多种方案，甚至可以自己”chain loader 自己”。这样，各种ldr程序可以相互引导，形成一个chain.一个分区上可以放多种OS。一种分区格式支持各种引导程序。等等

操作系统不过是一些最终表现为二进制的代码跟数据[20. CPU工作在内核态或用户态的区别在于，是不是进入了os的中断，或设备驱动处理(os中有一层服务例程界面，越过此界面的调用，即是CPU处于内核态时，否则，其处于用户态)],在这个意义(CPU眼光)上看,它跟任何任务空间里的进程代码,无论是内核进程,还是用户进程,都是一样的(我这样说,实际上带有一点欺骗性,因为操作系统本身也用它自己实现的“进程”实现自己的某些部分),唯一的区别,就是内核常驻0环,而操作系统中的除内核以外的部分,经常外在其它的环,当然也有可能是0环(比如用户进程中的某些代码映射成为了中断),这样的代码称为用户代码.所以,内核和操作系统其它部分的分野,一个粗糙的区分线就是“常不常驻在某环”,而内核,也就指“常驻0环的那部分操作系统”(在人们的经验中,它是主要部分,所以称为内核)

在这里我们严格区分系统实现者和写用户进程代码的人,前者写了内核代码,后者写了用户代码.按照业界行话,“内核代码工作在内核空间,用户代码工作在用户空间” (注意在这里也应注意区分系统空间,系统地址空间的意义,系统地址空间是OS规定的4G中的某部分,系统空间统指,内核工作所在代码起作用的某种当时环境.显然,这是指当时的CPU环层次, 实际上,0环,3环,这样的概念只是CPU的机制,操作系统利用这种硬件支持实现的软件上的“用户空间”,系统空间,是策略.),这也就是说,系统跟用户相对,CPU的环和操作系统中的空间分开策略,是为了保护内核本身,使系统和用户严格相对,因此各种人们书写的代码,自然是受严格区别的,所以,内核和操作系统其它部分的分野,其实有个严格的标志,不光是模糊的“常不常驻在某环”,还可以是“内核作为代码和数据实体,它们存在于4G中的某个严格位置”,在地址空间上它被映射为4G平坦进程的一部分.所以,内核此时是“平坦进程空间中的某个OS规定的区块中的代码和数据实全体”注意这个意义上的进程,是泛义的“操作系统的进程构成的任务空间机制”.不是具体某个进程.即用户进程或内核进程.

然而,关于内核上的以上二个概念,都是表面,因为只有当涉及到内核的逻辑意义时,比如它跟进程有关,这样的东西联系起来,并讨论它与OS中非内核的部分的分野时,那么我们才能明白更多,我们只选取进程谈一下.那么什么是进程呢,内核为什么必须先实现一个进程机制?进程,其实是软件上的“任务机制”,它不光是为了隔离用户代码与系统代码,创建出一个个的“进程”,而且是作为“软件计算机”层面的意义存在的.所以,内核地址空间可以存在内核进程任务,用户空间可以存在用户进程任务,即,进程不全面等于任务.要严格区分这二个概念.

但是绝对没有“内核空间进程”之类的概念,因为内核空间其实指的是一种“逻辑意义”.并没有这个实体存在)

从工程的眼光来看,OS中的内核是作为“软件计算机”的,操作系统在这个层次,基本上可以分为二层,即“一方以另一方为基础”,前者就称为内核,后者就称为“除内核以外的操作系统”,(操作系统之外的,就不再是系统实现了,而是系统应用与系统开发),所以,这其实揭示了软件的一个基本原理,软件都是用一层层的抽象来的,在OS在,也存在这样的抽象层次.从大的方面讲,有内核和非内核以外的部分的分区. 换言之,它是操作系统的实现的组成部分,且是主要部分,系统实现的其它部分,是建立在这个基础上的,(因为内核实现了进程,那么具体的内核进程作为系统实现,其实正是采用了内核已经完成了的工作的结果)

内核空间是个整体,因为它代表一个表功能意义上的“软件机器”,“软件系统”,所以它要常驻内存,要说它分单位,那么这个单位,就是C的例程了.此时无task,进程.因为内核本身是用C写成的,所以它不是线程安全的,因为C语言不是线程安全的,所以在内核级也提供了内核同步.在内核空间之外运行的程序,是一个个有机的任务体.内核作为软件上的机器,它的作用当然在支撑应用,发挥PC在软件上的作用.

这些应用,就表现为用户空间的一个一个进程.

soft programming based on os
-------------

###### 用户空间与进程

用户程序都运行在用户空间中，而用户空间才是由一个一个的进程组成的,支撑里面的程序逻辑的基础,比如任务数据结构,都来自内核.
因为操作系统提供了向上的接口,所以,新的硬件接入系统时,就可以在写作驱动时做到适时而止,只要提供给操作系统所需要的接口和逻辑即可. 一般地,从开发来看,驱动程序是一个层面,它属于内核的低层部分 - 抽象硬件层,内核的高层部分即系统抽象(各种驱动程序共同利用的一套接口),尊守一种开发约定,driver往往指一种中间层,比如odbc中各种driver与其底层的各种source如何沟通,有一个共同的介面,设备驱动程序跟各种设备沟通,都有一个共同的一套约定,各种驱动程序和驱动层面,是多对一的关系.由于各种文件系统,驱动程序往往很多,所以内核提供了模块机制支持这些部分的可拔插.
因为OS上的开发都是跟高级语言有关的(我们假设会编和机器不再是我们用来讨论的“编程的主体和手段”)“高级语言开发”,而OS实现,又是往往借助某种系统实现高级语言,所以,我们将在接下来《高级语言》这一章来讲解.

###### api与开发
api是一些内核级实现的中断，是用户级的调用,,从会编的眼光来看，所谓OS，就是将硬盘启动，导入CPU到一种模式，然后提供大量控制硬件或开发上可用的软中断的一个体系（整个体系表现为一个C源码系统及其向外透出的api sys）
在大局上,从用户(程序者)的眼光来看,内核作为二个意义存在,1,软件上的机器,2,用户程序支持体系,对于第一层意义,这就是前面那张“uniform developer’s space”图所呈现给读者的.对于任何工作在具有OS的PC上的人群来说,OS提供一个“软件上的机器”都是统一的,对于第二层意义“用户程序支持体系”,用户程序员对它的感觉要比其它人要深.

对于用户程序员,内核的实现不是鼓励被他们看到的,那些是内核实现者的事,内核假设它对于用户程序员是黑盒,内核假设它只形成了一个“用户程序支持体系”(接下来我们会看到,它包含“用户地址空间”和“系统调用”)就功成身退了,在用户程序员眼中,而接下来的建立在系统内核上的开发,才是他们系统开发者的事,它们只需面对一个统一的“用户程序支持体系”(而实际上内核实现者们没有任何现成接口可用,它们用纯C进行实现). 这就是说,对于内核体系与用户体系的关系,虽然内核是最重要的,因为它是软件基础,然而,对于用户程序员来说,它服务于建立起一个“用户程序体系”(毕竟,人们发明OS是为了拿来用的,这个用,就是拿来形成app).所以,用户地址空间反而才是他们最亲切感知到的,才是他们所关注的.


###### 对于开发者的意义

在发展出OS之后,机器控制不应是程序员的事,因为我们是“高级语言和软件程序员”,我们针对软件平台编程 上面说了，操作系统是作为系统的软件,它发挥管理机器硬件和提供一个软件平台的使命,是首先要抽象出来的, 提出一个软件层面和OS，也使基于软件上的开发(显然,我们尚未谈到软件上的编程)变得有可能。因为操作系统也可以开始着手建造软件级的任务空间和运行路径来支持这种开发. 操作系统提供那些对于应用和开发来说最最基础的功能和逻辑,因为它直接关联机器和CPU机制而直接面向初级软件需求(比如形成过程以运行程序使操作系统具有执行程序的功能),在操作系统内核中,内存管理,进程,文件,网络,用户界面,是最先应被抽象出来和最先被解决的问题.我们知道软件即抽象,所有的计算机系统能呈现和解决的逻辑,第一步是解决系统支持的问题(这导致了对系统编程的意思所在.),第二步才是应用逻辑的表达和解法(应用编程和领域编程). 无论如何,计算机能做的事在经过OS之后就有了新的扩展,从开发者[4. 当然,此时的建立在OS上的开发,是以高级语言为手段的.]的角度来看,不再直面CPU的取指令,译指令,执行指令,从内存中取数,CPU用逻辑器和运算器运算,,中断处理例程,IO设备等功能,而是系统调用如Posix[5. 软件上的BIOS就是system call,os kernerl的本质在于对系统各个子模块及基于它们之上的应用提供system calls,它处理来自内核外那些程序的请求].即有了OS的计算机后来所有的软件逻辑是OS调用这些如上硬件资源和机制的策略.这些策略再被高级语言所调用产生在高级层次对系统的编程动作.在下面的章节中会谈到. 我们首先来谈保护模式及保护模式下的汇编编程的大致情况[6. 我们这里将不谈实模式下的DOS之类的操作系统].再来谈软件级的任务空间,即进程和执行路径的概念. 对于开发来说,因为出现了一个OS,开发的全义变成了“OS上的开发”,OS不但是应用平台,而且还提供了一个开发平台,连驱动程序的开发,OS都为其提供了接口,都是OS之上的开发.因为OS,是作为功能的软件机器意义存在的.

OS上的开发

Os为开发者提供接口，即使是硬件开发，也要通过软件。
可以想象，OS上的开发，一定是将机器类型弄为软件类型，集成到一种称为高级语言的东西。这就导出了高级语言系统。


OS级的执行路径
=============

前面说了，CPU中的指令和对基本类型的支持,是这种PC形成汇编指令和数据,可供running的代码和数据. 代码就是数据,数据就是代码,在执行路径的眼光中，这二者是统一的，所以运行中的实体,最终就表现为存在于一段段堆栈中的代码,或称数据,那些标记为不能执行的,很多一部分就是数据,另外,在堆区,也绝大部分是数据。只是这些类型和代码可在其它层面，比如软件和编程层，被不断被扩展而已.

如果说栈式机的task running是执行时,那么存在于栈内的活动指令和数据,就是运行时，那么栈式机的运行本质就是：执行时中套运行时，

这些都是硬件上的PC本质,那么当引入了管理机器的OS后，OS是作为功能的软件机器意义存在的。即“软件上的计算机”。它表现在执行路径中会是什么呢？





执行路径
-------------

组件技术应与执行路径放在一起谈，因为它们都是编译器和编译后端相关的东西

Windows执行其native的exe,就是用C的语义构造的一个C call stack来支持可执行体的执行的(注意这里不涉及到进程,任务等,而是某个活动进程内部的执行情况).

>过程应该是出现在函数之前作为子例程的意义存在的,过程对于C就是天生的,因为C的程序就是自上而下由过程组成的,所以过程是子程序,子程序是作为过程这种代码抽象本质的.因为执行路径里的栈祯的子过程只需要有本地变量就够了,不需要有与其它子过程通信的形式参数,或将子过程表示为一种类型返回的返回值,函数是强化了的,参数化了的过程,子过程只能子化代码,而函数提供了一种手段,可以在子过程间传递数据[1. 注意,形参与实参的英文单词上有参别,一个是para,一个是arg,函数即参数化的过程],这就将子数据和子代码同时子过程化做进了执行路径.

Os中的mm，内存管理，就是使内存成为程序的运行时空间的一整套规划方案，在这里出现堆栈空间，以支持堆栈程序。

程序的运行分为执行和运行. 机器执行程序,OS执行程序.运行时运行程序,分清这几个字眼可以分清很多东西. 在C语言那样的语言中,函数的出现就是一种参数化的过程,而过程.它是程序被机器执行时所产生的一段段栈帧.而OS运行C程序,要为它分配内存.而且语言系统会提供很多编译器内置类型(数据类型或抽象数据类型 ----数据结构等).机器的指令中也直接支持产生很多类型为语言系统所用..内存管理,GC,异常,进程调度这些由OS导出来的类型和支持程序运行的功能称为运行机制(它们最终要反映到用这门语言进行编程中),别于机器的执行机制. 指令(编译器封装指令成顺序语法结构)和类型(过程语法机制和编译器类型是一种语言的编译器首先要解决的二大问题),是学习一门语言首先要碰到的.只不过不同的虚拟机会提供不同层次的指令(比较intel指令和py vm中的指令),而不同的语言会在编译器内置不同层次的类型(比较C和PY的内置类型).这二种不同都会导致这二种编程活动呈现绝然不同的现象.

要分开二个概念,即OS对程序的"执行"路径和程序在OS中运行时所需的"运行"时.OS"执行"程序,程序靠"运行时"运行, 执行路径是机器挂钩的概念, 非语言挂钩的概念(某语言的运行时才是),让我们规范这个说法.程序执行路径是程序执行路径,运行时是运行时,这二者不是一个概念[2. 执行路径是OS如何以一种可执行文件的载体来运行可运行逻辑,比如堆栈机之于PE文件.运行时是一门语言的某个程序运行时所需的built-in库,比如crt,或者这种程序如何向OS申请内存得以运行的内存分配模型.](本章只谈执行,下一章我们才会谈到运行时).

在进行一段函数调用时,必定是存在调用方和被调用方,一定存在参数间的互传,怎么传参,调用结束后指令权如何在调用方与被调用方之间协调,平台是如何执行这些运行时逻辑(当前活动帧,调用者帧,更早的那些帧)的呢? 对！x86用到了堆栈,对于C语言函数,参数右向左入栈(显示成汇编逻辑时是push),第一个参数反而在堆栈(此时是堆栈对应这个函数附近活动区域的一个帧,因此称为堆栈帧,即堆栈区的某个真正的活动堆栈)的最上面(偏向低地址方向生长)这样,相对其它参数来说,它就显得先进后出嘛,后进所以先出嘛,当然,它到底出不出,此时出不出,这跟当前sp没有一定联系,,因为sp当前位置不只是由压参影响的(甚至没有必然系,因为sp这东西可以人为用汇编码指定),还受其它自动变量的影响呢 再比如递归,由于它每次调用实际上都产生一个新的函数,对于栈式CPU的计算机来说,由于它主要利用内存而不是寄存器来存储这些新函数的临时变量和压参操作,,因此这个递归过程不应有过多的调用深度,否则压参入栈方面的开销会过大(这是指空间方面的优势,栈这个段区可用来存储很多参数但是速度不快,而reg式计算机速度快但是没有过多的reg供递归存参用.因此空间方面是个劣势.). 过程式语言和函数式语言(大量用到函数和泛函数机制的语言)跟堆栈这种逻辑密切相关,堆栈逻辑一部分体现在机器执行模型上,也有语义模型上的,比如c call stack, 如果你知道函数对于结构化程序设计的重要性的话,那么你也会明白堆栈对于函逻辑的重要性,所以理解结构化程序设计范式的重要手段是理解堆栈这种 ADT .而这出现在数据结构学中. 当然,intel平台中,,CPU和内存是共同发挥作用来实现寻址的,而且也共同(主要指CPU中的REG,一方面,SP这类REG发挥指针的作用指向内存,一方面,一些REG本身可用来直接存数据)作用构成运行时(时空=CPU时间加内存场所),,那么intel平台是stack机还是reg机呢,当然是综合机 C语言的这种规则跟pascal的规则完全不同,,这导致的C语言函数可以有变参数数量的好处 语言有它跟OS直接相关的地方,虽然形式语言的理论不跟任何OS相关,但是具体一个语言实现(编译系统,某种语言的程序的运行时[3. 注意,运行时跟OS执行程序所用的执行路径的概念不是同一个东西. 我们将一种机器是属于reg方式来执行逻辑还是用内存stack方式来执行针对它的平台逻辑,,以及相关的一系列知识称为执行时,将支持语言运行时所需的内存获取逻辑,以及其它高级支持逻辑称为运行时])都得运行并服务于一个OS.一门语言所编的程序能在某OS上运行并申请到内存等时空资源,这就是运行时跟OS相互作用的结果. 什么是运行时呢?一门完善的语言的提出,,包括提出一个针对该机器环境关于此语言版本的的代码运行时环境.(因为语言写就的程序实现需要被运行,需要内存模型,那么就需要发展出一个runtime needed的东西了)称为native runtime,因为是对机器本身,而非类jvm软件机器,的本地机器运行时逻辑的C语言封装. 从汇编中我们知道,REG和内存都是语句运行时(不妨改成运行空更好)的存储空间集散地,但是不同的机器,有的不具备REG,有的侧重利用这二者的机会又不尽相同,从这里就有了堆栈机跟寄存器机的区别

用户态与语言级的调试与systemerror
-------------

这里讨论由CPU沿袭到高级语言的那些机制.
编程就是对已有的事物进行抽象或描述。异常。就是对已知事物的另一面不可能也不打算作编程考虑的那些情况做防范式措施,,实际上，它也是CPU的“正常”的一面.

异常[4. 来自于软件指令的异常,对于CPU来说,跟来自于硬件请求的中断来说,都属于某种使它正在进行的工作“中断”的机制,硬件级的中断处理程序来自内置于BIOS的功能,而高级语言软件的异常,更确切来说是,可编程异常,因为(保护模式之后就提供了这种机制)可由程序员定制处理这些异常的例程.在高级语言中,人们一般把异常作为处理程序运行期错误的专用说法.]是什么呢?异常不是错误,,是比错误轻一级的概念,当异常(即使被捕获到了)不能(在程序中预定义的处理块)被正确处理,就可以抛出一个错误(当然,错误和异常在程序中可表现为很多种,编译型语言如C++就有静态编译期语法和动态运行期逻辑错误之分)而调试,包括对这二部分进行调试,静态期的调试要容易得多,而运行动态期的类型在写代码时(编译前和编译中)显得易读,但是调试时十分困难(因为要从运行中调试)..这就是动,静的区别所在 (这个过程通常是,我们按照正确的程序流程来处理错误,发生错误,在程序预测到它,并不尝试恢复,,比如跳栈,如果能处理则处理之,不能则崩溃) 在传统编程中(一种语言未引进异常机制前),我们总是用IF,,THEN这样的判断跳转语句来提供处理异常发生时的处理逻辑,,,当一门语言内置异常机制时,此时,我们就可以用新的处理逻辑,此时,通常程序语言会作跳栈和保护现场的动作.因为大凡大型软件,需要一种很强大的异常机制,它必须全天侯运行,不能出错就恢复不了,这种动用了程序语言原理(一切程序即函数调用,如果你反汇编过就知道了)来处理异常的方法就是真正的异常[5. 异常与跳转关系如此亲密,RUBY甚至鼓励用异常实现流转]．．
操作系统提供了对程序调试的直接支持.这成为一部分系统编程逻辑. 汇编加裸机器编程的时代,是指令编程,那个时候的调试是面向指令的,称为“指令调试”,此时的调试总是面对一大堆hex码,当平台封装了指令级执行的一切,编程语言也由指令变为语法语言之后,调试也就变成了“语言调试,语法调试”,此时的调试直接面向分析平台导致的错误,或语法语义导致的程序错误,这就是说,**调试绝不仅仅关乎语言逻辑,而且还关乎平台逻辑[6. 也即,编程中的异常处理,实际上,是系统编程,就跟解决GUI问题一样,是解决程序的现实模型的方法,而并不是编程语言本身就有的东西.还比如,程序如何使用动态内存,也是系统编程,即,它是解决程序的现实模型(向OS讨要资源,就跟进程,线程一样),并不过,拥有GC的系统会解决你关于释放的那部分而已.],所以,利用一门语言进行最彻底意义的编程,编程期间发生的调试就要深入到平台逻辑**.而如果编程总是不要求你进入到调试,进入到平台,而将编程的活动全部限制在语言级,和语法上的调试,这说明,这门语言是相当完善的.至少它完全脱离了平台细节.不涉及到对平台的调试.而且,测试作为事先调试,使事后调试的工作下降了很多. 面向过程语法和语句,来源于会编中的指令跳转规范. (调试经常与绘编结合[7. 会编开发早已退出主流历史五台,现主要用在超越文档上],即使在高级语言开发下也是如此,当程序员为了获得比文档更多的信息时,它们经常被用于windows超越文档,这与linux下的程序员形成显明对比,因为linux是开源的,调试直接在源程序上下功夫就行了)

>如果说Windows是用C编成的,那么至少,某种道理上,从c语言实现层面可以解释Windows的一些原理,比如Windows的GUI消息,就是用C先实现了一个消息系统.

除了调试,有些虚拟机,特别是py语言和其vm,甚至谈化了我们一惯使用的那些数据结构和算法(比如数组,链表,树,图)这些随着编程一步一步发展而来的历史抽象,它提倡仅用它语言级的一切去解决全部编程问题,于是对上述数据结构与算法它提倡用它的三种内置类型去模拟,这就是语言的内敛性,它企图建立它自己的关于编程理念的新标准,并把它作为这样的标准的全部,它充分隐谈去了编程者需要学习系统知识的必要,假设用语言中的有限东西和复用的手段就能表达所有东西,使学习者的学习曲线假设为仅仅一条学习语言的历程.“学编程,只需要学Python”,这不只是一句广告语的广告语.

我们到哪了？
----------------

OS为软件编程提供了无限丰富的平台。

>>在OS下，，在PC中实际上运行的程序有三种，硬件例程，内核规程，，与用户进程，，注意这只是按性质来分的，并不是按优先级（或中断）来分的。抽象中断系统为它们的调度分层次。

由于保护模式的CPU已经支持受保护了的任务空间和跳转机制了，所以这并不同于普通的会编环境中的硬件执行环境，如果在其上展开会编，将会是一种高级的会编。

软件系统的出现(上)-任务,IO
=============

软件系统和高级语言的出现，与硬件系统对于会编编程的作用，是一个道理，只不过后者在更高一级的层次上。抽象的东西往往变得更为复杂。

我们还没有谈到编程语言。