保护模式与软件系统的出现
=============

计算机的智能由图灵支持的硬件平台和编程映射理论支持的软件平台共同构成。这里要谈到，是软件平台。

实际上机器往往并不需要一个软件系统也可以运作,比如电传打字机和电子打孔机数字求值器,在裸机层次也可以实现其功能.上面的章节基于学习汇编和冯氏裸机的目的对此已有详细的描述. 但配备了强大CPU和内存的PC绝不是一般的电器,冯氏模式一开始就指出,它是能够存储程序，切换程序和可编程的,对PC的使用往往源于它抽象出来的强大的软件功能,而不是仅仅是用CPU来加热鸡蛋(如果实际上CPU真的能煮熟一个鸡蛋而且业界流行这样使用CPU的话).





为什么要出现软件系统
-------------

OS为PC增加了一个层面，是人们工程化（平台软件化）的第一步，他们想把越来越多的硬件，及对计算机的管理(自动化任务，及以便更好利用计算机的更好方案)，，甚至计算机功能的强化(除了文字数字处理，它还能做些什么),,编程本身，集成到计算机内部。并形成一个平台作为基础的结果。

所以，软件平台不如叫做“使平台软件化”，以突出过程（平台化）而不是结果（一个叫OS的软件）。

有起码三个方面的原因促成软件系统的出现：

一，人力管理机器太麻烦。更多的硬件需要被接入计算机。它们的功能需要统一到一个共同的新层面而不仅是bios。

二，我们知道计算机最初能干什么是它的cpu直接支持的类型决定的。由于数值和文字是受cpu直接决定的。故历史上它一直是个数值处理器和文字处理器。那么为了能让计算机支持越来越多的事物。是不是都要将他们直接编码集成到cpu呢。显然是不行的。这个任务可以放在软件层（比如。软件系统。或编程层的类型机制）来完成。

三，也是那个最重要的原因。编程需要更高的效率。

>很多很多年前，那时，会编下的操作员和程序员,要完成先控制机器的任务(机器上有重启,暂停等按钮,在机器内也有相应的控制指令,这就是最初的OS,它完成“控制机器”的任务,不过这个机器是硬件而已，可以称它为“裸机OS”),然后才完成它作为用户自己的任务，，于是急需出现一种能代替人管理机器的层面（即将管理机器的任务显式地整合进另外一个人不用去管它的计算机内的新层面去，但要注意的是这绝不是去除它），这个层面就是软件层面，它能被用于将人从繁重的管理机器的任务中脱离出来。这个层面，逐渐演变为“软件OS”的原型。(OS是最典型的软件)

>最初的大主机(此时它们是裸机)的处理能力太过于空闲,一个当前使用机器的用户对于这台机器的处理能力是独占的,于是发展出内存多道，分时系统这样的东西,而分时系统,就是最初的OS的原型(此时，它并不叫“操作系统”。而只可能是一种操作系统的雏形。).它从用户需要的观点,加上一层分时逻辑,由于计算机的硬件速度足够快，这层强化机器的功能可以直接常驻裸机之上，

而这一切都需要从软件上去突破,这就开始有了软件机器的意义。 操作系统就是这样的软件机器的第一层。

>>前面说到，任何人类活动都是工程，都是一步一步来的,这“一步一步”，其实就是设计中的分层，分级思想(我们想要什么，就在软件上提供什么，而且，在软子上加上一层策略逻辑，，使算法按架构组织，使得在实现功能的同时，使之在工程上灵活有度，能更好为人使用)，对于整个计算机系统，首先是将机器分为硬件工程和软件工程（软件系统中的基础建设工程）二大块(前面一小节完成了对硬件架构的解说，这里主要讲述的就是对软件系统的分层分级思想)。 

对于整个软件系统，对它采取的分层分级的过程是这样的：软件系统最基础的东西是OS。然后是基于OS上的系统软件，和应用软件。

当这一切都完成了之后：计算机将增加一个新的层面，这样计算机系统实际上是硬件系统支持下的软件系统了，操作系统使之变成“纯粹由灵活的软件映射，而不是固定的BIOS代表的硬件规程代表的软件PC”，就这个意义来说，它隐藏了硬件（硬件功能，硬件编程，所有的东西），所有的功能来自软件，不再直接面对硬件。于是，人们管理机器也方便多了，扩展机器功能（编程）也方便多了，计算机功能新的提供者,而且是开发平台,而且将编程直接集成进了这个软件系统。可以为PC额外增加的功能,,网络。多媒体。并将这些硬件虚拟为软件上可用的东西。

对于最终用户来说,它沟通了裸机与使用机器的用户,操作系统提供了界面使得各种高级应用成为可能。

对于程序员用户来说,使编程工作脱离直接面向机器编程,,因为操作系统可为各种应用软件提供一个执行路径,程序员可以面对操作系统编程.由它直接抽象出并发，动态向计算机讨要内存，而且,网络,图形等系统功能,运行于操作系统下面的各种应用软件可以使用它们进一步抽象出各种更为高级的应用逻辑(比如Web,多媒体),这是一个巨大的成就（编程终于工作在人的层面了，OS是底层的代理）。。

对于他们开发的用户程序来说，操作系统， 

[1. 比如对于驱动的开发,操作系统提供了面向接入硬件的，基于原来中断的驱动，提供了一个一致的面向OS上层的接口.但它是经过OS的高度复杂化的机制]. 

对计算机的这些能力不是下降了,而是上升了,因为人类要直接面对将是一个更强大的软件系统[3. 这就是抽象的能力,它一方面隔断了人类并不擅长的硬件细节,另一方面提供给人们一个更为强大的软件环境].不论对于最终用户或开发用户来说都是如此(当然对于硬件工程师来说不是这样).


所以，操作系统的出现绝对并非偶然，一句话,操作系统的出现是源于各层次人们普遍的需求.，是必然的结果。


稍后会提到创建一个新层面，整合等等其实正是软件设计中的常见抽象方式


不管如何，我们总算明白，软件系统的出现是有着它的特定历史需要和历史背景的,只有等到当CPU复杂到能够被用来形成受保护模式保护的任务和响应中断[2. 为一个机器设计中断是制造一个机器的重要过程之一, 通过中断机制,硬件被接入计算机,中断即硬件通知CPU其准备进行服务,硬件服务例程被接入系统,中断,几乎代表一种硬件功能在计算机上的存在形式(比如CPU的),软中断,代表软件上系统功能体系,请参阅前面的章节.]时,软件级的逻辑就可以在上面慢慢构建起来了，这是条件因素。

为什么要出现一个保护模式呢?这是一种为了迎合OS的出现,而专门制造的一种CPU,它同时具备实模式和保护模式,并在需要的时候由实模式切入保护模式,以支撑受CPU强大保护了的软件系统。

保护模式的任务保护机制
-------------

保护模式其实是一个概念体系,,包含有分段分页,中断与异常,调用门,其它门(这是对执行任务的保护),及对IO的保护,,其中,数,分段与分页机制最为基础. 正是它们的综合,支撑着现代操作系统的整个硬件框架和机制供应(保护模式下的CPU是OS导向的，，甚至有的新式计算机硬件平台有直接面向支持OS特定概念的机制，比如ACPI的软中断等)。

而这一切，是为了产生一个“受保护的任务空间(内部)”和“受保护的CPU与外设之间的交流环境(外部)”,而所谓保护,其实以软件抽象的眼光（操作系统内核实现）来看，是对页段,指令,中断这些保护模式的设施提供迂回机制,那么，这些迂回都有哪些呢？

###### 分段与分页

分段与分页机制只是构成整个保护机制中的第一层. 视情况而定，在一般情况下，并不需要同时用到分段和分页，但是分段总是必须的,分页是可选的,在没有分段的情况下,从x:x形式的逻辑地址到线性地址其实就是从逻辑地址到物理地址,只是分段机制,就可以完成,隔离任务内存空间的作用.然而,加了分页机制（页表目录/页表/页,这其实是一个三层式的概念）,就可以更加有效地利用内存,此时,从逻辑地址,不是直接到了物理地址,分段模式下的线性地址在这个意义上只是一个中间地址.

>分段分页中的任何一者都可独立完成“划分地址，抽象成空间”这个任务,然而,对于纯粹的分段机制,如果整个段被“一下子”载入或载出,这些对主存的使用效益是极为不利的.所以,一般采取二者结合的方式进行.或主要采用分页的方式进行.如果只采用分段,那么线性空间几乎等于物理地址空间.Linux主要采用了分页的方式.

上述32位CPU的转换机制是分段跟分页的综合作用.分段机制不管这个4G空间的实际调进调出,因为它不负责实际分配内存,它只负责逻辑地址到线性地址的转换过[7. 在保护模式下,CPU中的段寄存器不用来实际存储物理地址的线性表示(而在实模式下是这样),它用来实现硬件级计算最终物理地址的一个中间存储..]程..实际分配内存的工作由分页机制来完成,它负责线性地址最终到实际的物理地址的转换,它把这分段后形成的4G虚拟的空间用来调度真实的内存页,内存页就是真实的物理地址的载体,分页机制只需保证生成的页面大小总和局限在这4G空间中即可..页面是随用随载,调进调出的,以较小的单位而不是段来实际使用内存,,这就加大了内存的使用率(虽然分页并非百分百做得到如此).
要深切理解CPU是如何完成分段分页形成任务可用空间的过程是一个精微的学说,因为除了基于分段分页的寻址完成的任务空间，还要涉及到更高级的任务空间保护措施，这就发展出其它设施，比如段选择符,门,LDT,GDT,pae (CPU中有一个pae位可以保证所有CPU都只在概念上只看到这一大小)这些概念之间是如何相互间发生关系并维护这样一个4G空间.以及这个机制产生的结果和意义所在,需要翻阅相关的书籍.下面试阐述一二:
###### 门
门是CPU中的一种迂回机制[8. 以后我们谈到迂回这个字眼时,实际上指,迂回就是抽象的另外一种说法],有调用门,任务门,中断门,异常门,这四种门的用途不一样,但都是为了实现CPU对内存访问进行保护的一种迂回机制(比如数据访问权限啊,任务安全切换啊,中断正常返回啊),在保护模式下,跳转应在各任务间正常切换,否则会引起著名的操作系统保护错误,处理例程调用完之后通过一定手段返回正常任务),那么CPU就发展出一些诸如调用门,任务门之类的东西..用来规范这些跳转。

调用门实现了数据访问的权限机制,跟四种普通段,段描述符有关,任务门跟tss,tss段选择符有关,中断门与异常门跟中断或异常处理例程有关..首先来谈调用门. 对于一种跨段的段间调用call或跳转jump,统称调用和跳转和转移,有直接转移和间接转移,,但是直接访问方式不能实现段间调用的同时转变程序的特权级,调用门的设置就是为了实现一个间接调用加同时改变程序特权的跳转方式..任务切换有直接切换和间接切换,任务门跟一个tss段有关,跟调用门谈到的对于普通段迂回机制一样,任务门也是实现间接任务切换的手段.而对于中断门与故障门来说,门描述符内存储的是中断与异常处理例程的地址..

CPU首先检查这个选择符的ti字段,以决定是选择到ldt还是gdt中选择描述符,然后检查相应的索引以在ldt或gdt(这些都是内存中的数据结构表,表驱动方式)找到最终的描述符..这些符结构都在4g内存的高端部分,注意是在内存中..找到描述符之后,再以判断选择一样的方式在描述符中判断各个字段,主要是生成段基和段长,段的三个权cpl,dpl,rpl.. 比如在如下的一个指令中 mov ds,ax, ax存储的并不是指向ds的指针,,也就是说它并不实际存储ds的地址.而是一个选择符(注意,第一它不是段描述符,第二它段选择符是一个32位的数据结构,它的各个字段表明了不同的意义,组成整个段选择符的意义),,,段寄存器大小有限,CPU中的寄存器只用来存储指针值,或者描述用的数据结构,比如在这里是一个段选择符..

CPU就是靠以上方式来实现对于段机制的保护[9. 保护模式中的保护二字]的,每一条指令都有内存读写逻辑,每一个内存读写逻辑都有这样的寻址,最终要涉及到进入段中.涉及到保护模式的一系列机制..
###### 保护模式的IO保护机制
###### IO与位图
门,都是描述符,比如中断门和陷阱门,受IDT的管理.比如上面谈到的调用门,用于完成call的正常跳转.其它门,都有着它特定的目的,实模式下的中断处理向量跟保护模式下的IDT向量机制是不一样的,保护模式有它自己的一套中断寻址与处理方案
###### 小总结
受保护的线性空间和受保护的中断调用机制，都是cpu级的，它支持着以后出现软件件的,比如OS级的某种更高的抽象中断机制。 而线性空间，支持着大局。它是基础。
另外，我们注意到：CPU的保护机制中，**门不光是为了保护IO而设置的，而且是为了能正确调用代码（跳转）而设置的**，故，门不光是为了任务，也是为了IO。这二种机制有时是相通的。
所有这些，都为以后在更高层次出现更高抽象的策略提供了机制基础。

>策略,是指,底层已经实现好,高层只需要配置 – 定义如何被使用的策略的一种工作.比如,为一个例程指定参数

虚存技术只是临时解决之道,它涉及到用附加组件(外存)来模拟内存,只是现代OS用于解决内存过少的临时解决之道.所以不能体现PC的软件系统的本质.

前面说了，32位的CPU利用它的转换机制可以保证4G空间一直存在内存中(这就是说,实际上并没有一个实际的4G空间在内存中,只是CPU可以映射到，并看到一个4G大的线性段,能以它为基础形成任务直接供程序使用这才是CPU关注的)..这样的话,对于编程来说,只要是在保护模式下,我们都可以拥有一个4G的编程可用空间,不必调进调出的(它本来就一直在内存中为CPU所看见).

那么，这种4G的空间是怎么形成的呢？程序的执行，仅仅需要一个空间就可以了事了吗？还需要什么更强大的功能吗，比如保护机制？


任务系统：

进程中的虚存管理与任务调度
=============

前面我们讲到，保护模式支持着PC产生“受保护了的任务环境”和“受保护了的IO环境”。

其实这些，都是以CPU的硬件基础为机制（分段,分页,调用门,任务门,中断门,异常门这些的CPU机制）在内核层实现的策略，**即内核中的抽象中断系统(更多软件上的中断机制)，与抽象任务系统(任务保护下的任务强化。)**。这些策略又成为用户层的机制，供用户层的进程实现一系列更为抽象的策略用，最终形成应用程序能使用的机制(api)。

要把CPU的机制，，和OS内核对这种机制的运用，，以及形成什么样的策略供用户级使用，，这三者分开

比如：保护模式下的分段分页机制解决了地址映射与转换方面的事情，完成了“转换地址,从逻辑到线性,从线性到物理”,“形成线性任务空间”这样的诸如此类的任务，这就是说,它完成的是建造一个个“隔离了的任务空间”的任务,然而(这主要指CPU的功能和策略)， 并没有上升到完成负责建造具体任务的事的层次.因为此时我们还没有谈到任务，还有没有谈到内核，还没有谈到任何关于它在软件上的意义(任务是OS的概念，而OS代表软件平台).比如，什么是任务空间，以及任务怎么样利用这些隔离了的空间。

也即，线性空间并非指任务空间，而是指CPU的一种机制，它使保护模式下的可用空间达到4g（CPU在保护模式的引导下，可以看到4g的内存，为形成一个soft pc成为可能）,------- 只不过是索引的4g .而具体的内存分配与管理与“形成进程空间”,其实是另外一回事.(这些必须要在脑海里明白)

具体应该怎么样去把握呢？其实，我们只要掌握一条主线，即，较之原来实模式下的那个PC系统，我们仅需要这样思考，透过OS和不透过OS来理解原来那个PC系统，与实模式下的会编体系（平台，语言，编程）对接，本书正是按这个顺序和理念来讲解整个OS原理的。这是一条无路不通的理解线索。。

用这个眼光来看任务：

1，pc在硬件上不过是由内存和CPU，中断机制组成的功能体系。，软件不过是对这层功能进行了封装，将原来那个“CPU管理内存的原始机制”，，将其弄为“软件机器”，(实际上是软件CPU，虚拟多个机器的第一步是虚拟多个CPU)，
2,,虚拟内存将，，实现为内存多道
3，那么，对于执行绪呢？

这已经是一种抽象任务了。

下面我们就来具体谈这个抽象任务机制，这可以从虚拟硬件执行环境中的内存和寄存器开始。








抽象任务系统
-------------

任务只指出了进程的时间方面，正如中断只指出了IO的时间方面，而虚拟管理指出了二者的空间方面。


任务是一套实现操作系统对CPU时间的使用（执行绪调度），内存分配（页面调度）的内核机制的统称。简言之，还比如，由于，进程是实现在os kernel中的一种机制，所以对于任务空间的运用完全是策略上的事情，

。但是它不是支持OS作为软件上的机器的意义的机制。进程是内核实现中提供给用户程序的机制，用户程序使用OS的进程机制才是策略，，将OS虚拟化为软件PC的，整个内核例程才是。。

任务是一种使代表soft machine意义的os kernel首先完成的visual machine的整套机制。其形态有普通进程和线程二种。
呆会我们将会看到它们是在OS中完成的，这一切，就是操作系统技术中的进程技术要解决的事情。并实现在OS kernel中。

###### 任务空间与虚拟存储

首先，对于任务,在硬件级是分段分页机制和门的跳转保护机制,在os core级,可以封装它们,最终表现出一个个“隔离了的线性任务空间”和受保护的代码执行环境和IO环境。。

进程和线程作为任务，模拟了内存和CPU时间这二者（没有CPU或没有内存都不足于构成一个软件的任务,线程要偏向于CPU时间一点），是人们分裂一台计算机的处理能力,为多台计算机的手段.,故称VM。进程“使一个程序独享内存[1. 在这个意义上,一个一个的进程并不代表一个一个的软件上的PC(或VM),它们只是代表VM的一部分。
真正的OS在软件上只有公共的一份4g供所有进程共享,4GB中的相当一部分映射着一个公共的os core, 存储管理首先要解决任务与任务之间在分享存储之间的需要，这就是虚拟存储，（注意，我们并没有谈存储管理）。]

这里有必要再次提到4g空间作为线性空间与任务空间的区别，前者主要是指CPU的机制，这里是指进程的机制(而进程已经有软件的意义了)，4G的虚存空间只是映射，这里有alu和mmu的作用（即页式内存管理），如果可以，还可以加上段式的作用，其实，进程空间是不存在的，更真正的称法是“进程空间”，它是个概念上的映射，故内核内间，用户空间，只是4G的“进程空间”（这里称为进程空间似乎不妥，任务空间，应称为工作空间，“可供映射空间”）
将进程空间分为系统空间与用户空间，它主要是强调：CPU从系统空间进入用户空间（此时，CPU正在一个受限的局域活动）时易，用户空间进入系统空间时（此时，CPU可执行作何特权指令）难，必须要通过OS提供的自陷或中断，方可进入os kernel，进入OS kernel所在代码（在那里，可以执行特权代码，os kernel本身就是优于用户进程代码的特权代码）
先映射系统所在页面（通过内存管理作用），这些页面和这个概念上的空间是不被置换的，用户空间会被进程切换刷新其（对于物理页面的）映射。

###### 虚拟寄存器环境

寄存器环境，就是线程，表现为进线程的上下文

进程使计算机成为vm,它有自己的寄存器环境(这绝不仅仅是一句空话，这句话是指，计算机成为一台VM，所有VM共享PC整个执行硬件，以它为基础形成保护模式，并形成任务)和内存（用线性空间成就的任务空间）
进程不光有一套自己的虚存空间，也有自己的一套reg环境,这里涉及到大量的保护模式下的段式转换等知识，需要讲解
前提是，我们是在一个4G里讨论问题。有一个正统的称法叫线性空间 这里介绍一下堆栈机，内核栈，用户栈，

>进程调度不仅是为了多任务而准备的，单任务内部也需要调度。这就是门所规范的任务代码跳转机制。

###### 特权机制

CPU直接为OS提供了很多专用指令，保护模式是这个指令的综合，其中有一条是给程序提供特权用的，即CPU中的环位。

因为内核和用户程序不在同样的空间，因此一段程序可能是对一方可见的(system scope)，而对另一方不可见的(app socpe)

程序能不能访问硬件,这要视开发该程序所有的语言和程序运行的环境而定,相比高级语言,会编是可以控制计算机做任何事情的语言,可是假如计算机booting,init进入os,比如windows或linux,那么该程序可能导致错误(而它可能在DOS这样的环境下或者没有DOS的环境下就不会)

比如,多任务环境下,这么多程序共用一套寄存器,硬件资源是它们的公用设施,这会不会造成寄存器混乱呢,不会,因为每个程序的进程都可以为它们保存副本(每个进程都是四GB,有自己的内核栈).而进程调度,即那些保证进程对硬件资源访问的逻辑,是由系统核心来保障的.


内核中的进程
--------------------------

进程是计算体，OS内核才是“VM体”，，实模式下的计算是以CPU加内存为中心的“计算”和IO（CPU内存的那个计算系统与IO体发生的关系，同样被整合进计算），，，计算(发生在CPU内部的指令选择及执行，，IO的等待，中断入当前指令序列，与完成)涉及到时间，内存涉及到空间，
OS模式下的进程作为抽象计算体，超码要抽象时空二个方面，这统一到一个叫进程的东西（它代表计算体），和文件（它代表IO体），进程调度实际上是:

1.计算调度（关于计算体的时间抽象，注意是整个计算体层面的，而不仅是统对CPU时间的调度）

2.虚存管理（关于计算体的空间抽象，注意是整个计算体层面的）

在这个基础上，再抽象出： 1，抽象中断系统（关于计算体与IO体关系），， 2,,抽象同步系统（关于计算体之间的关系）
整个内核就是一个任务机制(及支持任务机制的一些其它机制)，IO是它与具备任务（IO设备也要参与任务，它的方式不再是实模式下的那种方式），，手段是系统调用和中断的发送

进程作为抽象计算体，它如果被C实现，关于它的数据结构中必定首先是堆栈，寄存器，虚拟等东西，，，而至于文件，是IO体，是计算体要与之发生联系的东西

用户模式内核模式的是受硬件机制直接支持的(这是硬件上为OS专门设置的，因为OS内核经常需要执行特权指令，且为了跟用户进程区别开以保护有特权的指令)

任务机制是计算体，它是内核的主要部分，还有计算机体之间的协调，，计算体与IO体的交互，也是内核要实现的部分 操作系统是中断驱动的，系统调用是面向用户进程的，它对内核意义不大，内核并不直接使用系统调用。。


进程调度
-------------

串行的本质导致了需要同步，这产生了并发，正是设计为线程不安全的程序，，才需要线程同步和保护，，一个本来就被设计为安全的线程库，并不需要

OS依赖进程就完成了计算体的构建，那么线程的角色本质是什么 控制流的说法只是抽象上的讲法，在实现上，它不例外地只是一些数据结构加算法，在有进程的情况下，实现线程只是是增加了一些东西


程序往往被设计为在单线程环境中运行（而且往往在当时没有设立线程安全保护机制以便其它线程---比如用户线程访问），，所以不是线程安全的，，故需要在用户线程中小心访问（同样是利用线程安全技术），，要知道其中孰因孰果，线程是用来解决什么问题的

线程是进程的进一步抽象，是必要的，，比如远程进程对象，，必须是一种线程之类的东西，而不是进程（那样资源浪费就太大了） 线程为并发提供了可能，而不用涉及到进程（虽然它要完成的是进程间的并发）
从各方面看，线程仅仅是一种辅助进程


内核管理进程，进程管理线程，线程是时间单位的一个函数(由进程调度来协调产生或同步) 内核线程不可中断,内核所在页面也不可置换
用户线程与内核线程是二个不一样的东西,如果用户进程用了内核线程,那么它就是内核线程,反之,如果一个用户进程的实现,没有用到任何内核线程的支持,那么,它就是posix兼容的用户线程.


###### 虚存管理与调度

虚拟内存不仅指页面文件(不是每个系统都有MMU单元),它其实是一个很大的基础概念,是PC分解它自身只有一个CPU和主存而产生的“虚拟化CPU时间”,和“虚拟化主存空间”的二者之一,它作为底层服务于caching,mm,内存保护,等上层建筑.(是典型的C/S结构,所以,在OS的设计中,windows大量采用管理器之类的概念,而这,也导致了微内核的产生),理解虚拟内存的关键是理解“存储器抽象”和“mm”这二种概念实际上是一上一下的二大抽象体系.即解决硬件抽象层的问题,和关于任务中对于内存,的初级系统逻辑.

其次，软件平台要作为一个能运行多任务的soft vm，进程就需要被调度,故是实现多任务(此时不能说成多进程[2. 多进程,指的是“多任务并存”的存储管理法,而非“多进程并发”的多进程],多线程什么的)的基础.它首先完成任务调度(此时它并不一定跟多线程多进程同时运行有关[3. 注意,多进程从这三个字眼中我们并不能看出它是并发,只能看出它需要被“同步”,而如果是“多进程同时进行”,这样才有了并发的含义.更需要被“同步”],大凡内核,总要处理任务间的切换,对CPU,IO的使用,此时,就需要调度),再完成并发调度(基于调度的并发),线程原来也叫进程.调度是OS的灵魂,它是将“一个CPU”以“进程”为单位分成“多个CPU”的手段(是一种时间上的划分,由定时设备发出有规则划分的信号).
因为进程环境由虚存空间和寄存环境CPU（它们代表一台进程VM的时间和空间二方面）组成，因此OS要在内核实现中提供对它们的管理。

在OS级,CPU与内存如何发生联系被称为CPU的存储管理机制 – 这个存储,专指主存,页如何被实际分配,并形成一个进程空间.即,就是“进程地址空间的形成”, 这才是指OS的事。

就是“具体的内存分配与管理”,即页式内存分配逻辑(这主要指CPU对内存的策略),这二者都是存诸管理机的二个阶段.
进程管理和调度实际上是os kenerl的应用层，进程间通信，才是进程管理的server,进程管理使用它。进程通信是os kernel中的kernel,进程管理是os kernel中的application，因此微内核主张，只有进程通信才配进入os kenel，其它如进程管理，使用到进程通信的还有文件系统，设备驱动等，这些，应做到os kernel的下一层次，比如进程的非os kenerl的非kernel层次。

进程是OS Kernel的,它维护一个就绪表和一个关于进程的条件队列,在有了系统的原生并发的支持下,在应用程序层,编程可以通过共享存储器或消息传递机制实现某种并发, 对于共享存储,大约可以分为忙等待和基于调度的方式,又可与“互斥机制”和“条件同步”组合分类,,于是有四种并发机制.

>从这里开始,出现了关于进程的很多很多子问题. 比如进程的用户 进程的IO位图 进程上下文 任务状态.任务切换.优先级 内核同步 内存映射和mmap(),malloc() - malloc的背后是一个内存沲,是由C运行时提供的,都会扩展一个进程的线性空间,,这些属于存储管理的内容,而不是进程及进程调度的.

伙伴系统,是动态内存的手段,还有一个slab,,是关于对内核数据结构的内存分配的..

**OS对于解决多任务和解决多任务之间的同步是一前一后的。并发问题是随着计算机制造和计算机软件系统制造而产生的那类问题**(为了分时就必须协调同步),所以,它产生了一整个系统编程的流派


\线程与并发问题的由来

一直搞不清并发，多线程，同步，锁，blocking,unblocking这些术语的区分。。

 1，多进程形成的并发，不主要依靠线程，纯粹进程级的并发，，这样的并发存不存在2，是不是一定多线程就导致了并发。3，并发是不是一定需要同步。4，并发常见的有哪几种？5，异步io，多线程，协程是不是都要最终涉及到并发。这些东西是不是一类东西。至少它们都可以使界面反应得到良化。...10，异步IO，多线程，协程，这些技术，是不是统一于一个“函数时序化执行+资源并发访问处理”的本质？最后一个问题也许太抽象，其实就是：a,异步io一般实现在系统层，涉及到时间等待上的blocking,unblocking字眼。它好像是搭配了时间因素的函数控制流。b,多线程同步，需要手动处理不同步的情况。即时间上可能不能对一份资源实现串行序列化的情况。c.协程一般在语言层用，号称协作调度，不会带来需要同步的问题。函数语言中它主要用lambda,匿名函数等技术实现。所谓匿名函数也是处理函数间适应时间因素方面的控制的转移与重接所以在不明白整个边边角角的情况下，我想问的是：可不可以用“函数时序化执行+处理这里边对资源的访问矛盾”来解释异步IO，多线程处理，协程这些技术在函数处理方面的具体情形？

线程保护指令（一条或一组，程序上的语句），，使它们原子化，，平台或语言的多线程处理机制保证这些受保护的指令不被在运行时发生不确定的结果，，归根到底，是我们引入了线程，使指令脱离了它本来的非串行模式，这是应用的必然（比如需要一边等待一边作响应的gui程序），却造成了新的问题（软件抽象往往是一种解决问题的同时带来需要解决新问题的本质。），，比如需要锁定，需要互斥。。

线程不应只是执行绪吧，，程序的本体是时间和空间，，绪指出的只是时间，，那么空间哪去了，，tls??



因为线程不能脱离一个调度环境自运行,,所以线程编程(来自系统支持或语言支持),仅仅是给了这些线程一个被调度的机会和如何被控制运行的机制而已.

Programs can have user-space threads when threading with timers, signals, or other methods to interrupt their own execution, performing a sort of ad-hoc time-slicing.

coroutine实际上是一种古老的设计模式，它在60年代就已经定型，但是现代语言很少有重视这个特性，目前可以举例的有Windows的fibers, Python的generators

线程被设计为天然不合作的,,同步需要靠程序员和系统,,,而协程,天然就是协作的,不需要程序意义上的同步.

纤程用于化异步为同步。你可以进行一个异步操作以后就切换纤程，等到异步操作完成以后在切换回来，这样，在逻辑上相关的代码就可以写到一个函数里面，而不用人为的分到多个回调函数中fiber 的好处应该可以减轻锁的顾虑。在没有主动切换上下文之间，可以看成是原子操作。

fiber 就是一种 coroutine 的实现，而 coroutine 其实是一种常见的算法表达方式。只是 C 语言和其衍生的基于一个环境堆栈的语言并没有直接支持。所以才少为人知。

多线程的程序很多不是为了提高效率，充分利用多 CPU，而是为了逻辑描述方便。


用事件（Event）来同步线程,异步天然支持着同步机制??

同步是指数据同步,不是线程同步,线程同步的目标就是同步它们对数据的访问,,,没有线程同步一说....这样说有误导性.

多线程技术中,线程从来不是主体,,,锁这样的东西才是..代表线程本体的也有只有指令..它被隐藏在系统多线程处理支持和语言机制多线程处理支持的双重过程.

不是说提供一个锁就天然解决了多线程问题,你还得亲自去处理同步问题...视各种情况各各不同.

sempor旗语,,与mutex又是..什么分别

锁不是用来解决问题的，而是用来替换掉，数据共享访问.

同步不是协调资源共享，不是妥协被迫方案？？，而是主动同步以产生想要的结果？？

线程并不一定是多线程，多线程不一定带来并发，并发不一定需要被同步。。

这里的关系很复杂，，，当只有一个线程时，就不需要多线程机制（比如每个进程只有一个线程而且互不跨进程交互），线程只是互不影响时，比如它们是被串行执行的(在全局系统空间)，就不需要并发控制，，当不需要并发控制对一个数据进行访问时，就不需要同步控制。。但事实是，有纯粹单线程的进程吗，有纯粹在系统空间串行的多个线程吗，有不对同一块数据尝试访问的多个线程吗？？？

不是说加锁了，就可以避免死锁，它只能达成互斥，使不发生不确定的情形，死锁是指，线程彼此等待（一个以上的线程）一个锁被释放，而浪费了时间的情形，它是另外一种要避免的因素。使线程操作的对象--指令原子化，，跟彻底解决提供一个良好的线程机制，还有一段路要走

most programs are written to perform I/O synchronously.,,,,,,so they need mutiplrthreading programming support or unblocking io ,,or sth,反正异步同步其实是一回事.

executing and worker thread

a thread trigger a context switch(进程,线程的切换,都是函数级的切换),,,in order to,,,let other thread to run

explicitly "yield" to,,,,to a exe flow,,,a function

Kernel threads do not own resources except for a stack, a copy of the registers including theprogram counter, and thread-local storage (if any).

Kernel threads are preemptively multitasked if the operating system's process scheduler is preemptive.

in most cases multithreading is not the only way to keep a program responsive, with non-blocking I/O and/or Unix signals being available for gaining similar results.[1]



------------------------------------------------------------------------------------------------------

时序与资源访问控制，，，这二个字眼，及处理它们关系的学问，，似乎是并发，异步IO，协程，这些个并发技术的本质。。

多线程，异步IO，协程都是并发技术

并发技术中，最让我shocking的字眼是，，时序与资源访问控制，，，这二个字眼，

由执行绪可以统一，1，并发：多进程多线程对同一资源的访问处理，2，异步IO，也是时间上的同不同步，，3，协程，，也是使函数流在时间上分开与重接的技术

时间与线程，，这个论题可大了,,你想想，，，有函数不行，，，有时间也不行，，，控制流加时间，形成的时序，才是执行绪

对于线程和并发，，我还是暂时笃实地认为，，，它一开始是函数在时间上的分配，，，后来才过渡到各种层面，，多线程，异步IO，协程

interrupt their own execution, performing a sort of ad-hoc time-slicing.时间分片和函数打断分流，控制让权，就可以促成多线程？？？看来多线程果然是函数处理的本质过程。

并发编程的本质,,,,在底层是函数级控制权对流......原来如此....可以引伸到很多语言技法领域和系统实现原理方面...并统一讲解.因为这二者往往也是一回事

函数对流,控制权的转移,函数关系与函数,,,这些跟很多问题都相关.

io切换涉及到环境的保存和恢复,通常被实现为函数,,而线程往往用函数切换实现.所以这二者就被关联起来了,,,,往往是C这种包括函数的语言,,,在系统机制与语言机制方面的天然结合.


------------------------------------------------------------------------------------------------------


###### 同步

所谓同步，其实并不是什么大不了的概念，它不过就是解决可能会出现“不同步，影响通信”的诸多矛盾的一切手段的统称，在OS中，这些手段就表现为软件上的抽象，被实现在OS kernel中。

既然冯氏机本来就是一台顺序确定执行指令的机器,为什么要搞得那么复杂呢？这是因为人们需要更复杂的东西（而软件级可以通过扩展硬件做到），那又为什么在提供了并发之后,还会涉及到同步问题呢? ，这是因为简单的事情弄复杂了，就肯定要付出相关的代价，比如同步（有了多线程就要同步），这就跟说谎一样，需要谎谎相圆。
在代码中,可以将代码的一块用一个线程包装起来,这样,它就拥有一个自己的“CPU“,比如,程序有一个GUI界面,它有一个背后逻辑,在界面上又要响应用户输入,实际上,多线程的一个实用之处就是使这样的界面更反应灵敏一点. 并发并不是什么新鲜的事

>在操作系统和应用程序的逻辑中都会涉及到并发逻辑(特别是数据库系统中),并发逻辑可以多线程也可多进程,甚至多线程多进程的方式进行,当然,单核环境下的并发永远是一种对并发的模拟机制.

当然,有时你用的语言提供了并发的支持,,而且有时候,操作系统的并发逻辑会影响到你选用一种更有效的相容于操作系统的并发模型(用户级的调度与内核的调度不同)

信号，信号cao究其本质是一种异步IO，进程间的通讯，其实是指进程间的IO，，异步IO可以用于这种过程

异步本质是同步的，而同步是需要同步的 异步的本质是无须等待，无须同步 同步是为了异步，异步是源于IO，IO是源于OS的机制--进程交互 
异步IO避免了多线程的方式去解决并发问题

多处理器，多线程是二个不同的概念，一个是硬件机制，一个是软件机制，，只不过后者搭配前者就更好了(后面会说到，软件的灵活性并没有根本解决需要并发带来的本质问题。)

并发并非同步(同步要优先并发)，同步是不得已而为之，并发是积极地使之能并行进行，这二者可有关系，也可完成无关系，，某种并发可以完全不用同步（比如二个实体同共访问一个串行体的情况下）

并发[5. 完整的并发说法是这样的:进程上的并发,或线程上的并发, 线程,thread of control.一个单程序中不同的被并发执行的部分]首先发生的大背景是PC[6. 本书一开头就假设是对PC编程],假设我们是对单处理器的PC编程,因此每个时刻,都只有一个活动执行上文行存在(CPU在任何时候,当前只有一个活动的执行路径-肯定是某个进程[7. 此时我们尚不能确定这个进程里是否有线程,所以,更复杂的情况要呆会再讲],在被CPU执行并处在这个执行路径中,Windows可以允许多用户多进程,但是因为所谓多进程,其实正是CPU轮流给每个进程分配了CPU时间所以在单CPU的环境下,不真正存在多任务,多进程和多线程都不能真正给程序提速,它只能达到一种“分流”的效果,使得界面响应快捷(这主要依赖调度,它能迅速地把不需要CPU时间的当前线程 – 比如一个等待用户输入的线程,阻塞掉,复活另外一个需要CPU时间的线程,然后调度再在其中监视新情况的出现并不断地作此类分流性质的调度,以使不需要CPU时间的线程让步CPU时间给需要CPU的线程 – 可见,并发并不是什么高高在上的东西,而是随着可见的那一类问题的需求而出现的,当然,这需要为每个工作流设置一个控制,即一个“控制线程”,thread of control=thread,而这,正是并发要被提出和它要解决的问题),或其它一些效果.

###### 多任务

首先，一个现代的OS必定是需要支持多任务的，对多任务的管理，被实现在OS内核中。

在单CPU上采取多线程策略的情况下,不会提高程序的真实速度,因为CPU只是采取时间片轮分的方法.但是可以得到“界面高速反应”这样的效果,这跟提不提高速度,是二回事并不矛盾.

计算机运行并完全计算的基本单位是靠一个个的“进程”来组织的,由是多任务要么是多进程，要么是多线程。

>线程可以是进程，比如轻量级进程，这样多线程的本质还是多进程，当线程不再是进程时，问题会变成另外一个形式，此时，存在着二种任务，即进程任务，和线程任务，线程任务只需要CPU时间，而没有虚存空间。

典型的用户层线程是用协程建立起来的

解决了如何表示多任务的问题之后，下一步就是解决如何同步它们了。

于是多进程就有内存间互不干扰的假像,但实际上他们正是靠正面协作来达到这个假像的,线程的真正意义是“使一份执行流(程序的一部分)”独享CPU.当然,于是多线程就有了多CPU的假像,这二者都是模拟的.
并发问题源于图灵模型与需要开发处理的现实问题之间的矛盾,图灵模式是控制主导数据(机器的底层问题都是IO问题),这使得这种IO动作必须被协调.又因为用于开发系统的语言一般是C语言,C语言本身并非某种并发和线程安全语言,所以必须在内核层提供一套同步机制.

解决多线程的问题是多解的,,源于解决方法的高层模式各有不同[4. 也即,从开发的眼光来看,它首先是一个设计问题],有不同的相关概念,,比如锁,,,就不需要用到信号量.

不要把线程想像为:它是进程依赖的,其实,它跟任何一个进程一样,是直接面向整个VM和运行环境的,只有VM才负责为它可供访问的资源和这种提供同步机制.进程不能. 线程首先是作为OS的任务机制，应首先讨论它的这层意义，再讨论它用于并发的那些意义。即线程先是任务里面的概念，然后才是并发里面的概念。

多线程中的quene,用设置一个“单行道”的方式来避免并发带来的矛盾. 阻塞式同步,也就是基于调度的并发,,跟基于忙等待和锁的并发(蛮干算法)对应..


在前面我们还谈到硬件利用IO位图对IO请求的协调机制，，这导致了硬件级对中断的并发处理，在OS内核中，对软件IO例程进出计算中心(os io mgr)的协调工作----------软件上的io并发协调机制，也同样存在。第一段说的是作为小IO体的驱动请求，，，可是软件平台的丰富性，使它还出现了另外一种抽象IO体，，任务进程，它是在拥有了OS的计算系统中，提供给用户用的（由OS内核提供机制上的实现，，但并不直接在内核级就使用进程逻辑，否则就是使用了OS的OS内核，即微内核，），它是另外一个OS要管的被计算主体，即IO体，，是大件，不可能让任务直接参与并发。对它的协调要考虑比诸如驱动请求更多的问题。

这样，就提出了线程，线程是一种函数，，它迎合了普通IO请求一般是函数小件的形式，，所以，线程的本质，，是进程作为IO体，参与os内核以进行在它里面发生的并发协调的机制。


###### 多任务通讯

多CPU要协调好共享资源的处理,多线程也要做一样的同步工作(虽然它也可以完全不做).

在顺序语言里,一般用共享存储(就是用某个存储在公共区的值作为条件,判断通过就不用再等待)或消息传递的方式进行线程间的通信(最终是希望得到某种同步和要达到的并行性能的折中,即不能同步过度,必要的同步)

多进程需要被调度,多线程也一样,要注意三个东西,

参与并发的各个主体,线程,或进程, 并发的数据结构,比如锁,互斥体,等, 调度机制与调度条件.

可用忙等待(一直等待的意思)的spin lock或阻塞式同步(基于调度的同步,线程间自愿让出CPU)完成.记住这个说法,被阻塞是为了同步,阻塞不是出了问题,只有发生deadlock的时候,才是出了问题.互斥是为了同步,是同步的一种机制,跟同步不是矛盾的概念（同步是为了解决多进程不同步问题的大概念大方向，互斥只是一种同步机制和解决问题的方法之一）. (自愿阻塞的调度方式下)阻塞可能是一个线程自动让出同步数据结构,比如锁(比如在这个线程中调用了sleep,或input等待输入),而此时,它还在运行(没被终止,甚至没被中止),一个进程被阴塞时不是指它没被运行(它只是因自愿或某种调度被迫而放弃了同步设施而挂起,挂起的意思仅指它不再受到并发保护的影响,其实,因等待输入等条件引起的挂起是很自然的原因),只是指它不受到并发的保护,只要有机会,它可以由别的进程唤醒(因调度获得同步设施),

正在运行的线程可能是前一秒运行过,现在(测试时)发现刚刚就被阻塞了的线程

什么是阻塞,阻塞即线程因得不到而等待资源的过程.是OS的调度里面的概念 阻塞就是以线程为单位独占用CPU时间引用的事情(sleep函数就是根据这个原理来的,此时它要等到时间过了这个事件被发生,才会停止sleep),比如一个read()线程在程序中等待输入,而这个输入因为网络迟没有及时到达,这个线程就一直占用着CPU时间(因为线程所处在的系统,本质上只有一个CPU),使得其它线程也一并被卡掉(比如界面上一个关闭按钮无法响应使用户认为这个程序死了).

阻塞,怎么会跟线程有关呢?因为有 锁机制在做怪,它在协调活动的线程.如果没有用线程实现的并发(此种并发在单CPU上并非为了加速,而是为了分流协调),就不需要用到锁,因此,就不需要靠阻塞一方的方式来协调.因此,在获得锁方面,就有主动获得锁和主动让步锁的情形存在.
信号量，事件，旗语，都是用于进程间同步和通信的设施（在用c实现的windows，这些东西都被称为对象，实际上，是一系列结构和函数的统称）。进程间会在彼此的空间里交互这些对象，以实现同步和通信。比如互斥量,它锁定了共享资源,得到互斥量的当前进程除非释放它,否则另外的进程不能获得它,进而获得对共享资源的访问.

小结
-------------

**解决了这二个问题,即解决了任务问题,然后是解决外部子组件**

这些问题跟任务机制也有交集,这产生了其它问题内核同步进程的IO位图,等等,

在内核中的每一大小问题的解决,都有其相似性(就跟解决任务问题中所看到的那样),比如,用相关的数据结构表示和算法支持,有相关的系统

前面分别介绍了os kernel和进程(由于cpu和进程间的联系)，但没有介绍二者之间的关系，进程管理是OS kenel对进程的作用，进程间通信是必要的，它需要“进程间同步”机制，以保证通信的正常化(有一种是报文小消息的传递)，进程间同步也是进程间通信，但它又是低级的进程间通信，因此一般把它跟进程间通信分开来说。

IO
=============

本质在冯氏机中，存在计算和io两大过程。外部设备靠它接入计算机，用户空间靠它与内核通讯，它实质上发生在内核和用户空间的方方面面，甚至计算机硬件的本身设计。

如何使io设备的规程也做入抽象计算体与它一起协作工作，，这就需要把它们也抽象为软件，这就是驱动程序

在内核的实现中，io本身并非某种内核中的实体，比如我们说，IO让出了控制，我们只是在讲，发生IO时的代码控制情况 中断控制的同步

中断驱动的IO 中断是IO设备工作必须的，CPU不可能轮询，只好叫IO设备自己发中断 中断是主动的还是被动的，它是由内核中的哪个部分发出

将IO和异常中断入原处理过程的外来处理过程，，在OS实现中，进一步被抽象成了，将任何外部过程中断入当前处理过程,,实际上，系统调用将外部进程的请求中断入（软件上的系统调用方式）内核，这形成了抽象IO系统,,实模式下的指令和指令编程变成了OS下的系统调用和基于系统调用的编程，，前者用的是中断，后者用的是软件中断





抽象IO系统
-------------

IO实际上相当于可编程入口。就相当于会编下的中断。是对内（任务系统）也是对外（接入用户程序对核心服务中转）的必要

对于IO，中断是必须的,因为它是某种保障机制,而不仅仅是为了响应来自硬件的消息并加以处理的手段. 

io驱动的堆叠，，类似于网络协议的mutipstack,,,,io packet类似于网络协议的packet

这首先是中断支持的IO的出台,中断是打断CPU执行的外部消息,及中断处理程序(ISR)的总称,,中断和异常统一编码,由一个可编程中断控制器,在中断到达CPU之前,把它们进行仲裁,排队序列化.

内核态或非内核态,指的是CPU的状态. 门机制等,是CPU处理其它逻辑时,所需要的.门(是一些内核中的数据结构)同时影响着任务机制和中断机制..
###### os级的中断与IO
这个用户模式与内核模式到底指什么呢?当谈到用户态,用户模式,用户态线程,进程,时,

我们要分清“内核kernel”和”内核态(是CPU的动作,CPU转入或切换进内核态,来执行使它进入对应态的程序)“,“内核程序”的区别所在,,前一个内核是指OS的core,,后一个内核是指CPU的状态.这二者也并非完全没有关系,一般整个os kenel都是常驻内存的,不必换入换出的,当os kernel中的某个例程使CPU进入内核态,

其实这个“态”才是最重要的,因为用户,内核并不针对某个程序,只是程序进入了一种状态时,我们才改变对其的称呼,可见,最重要的还是指“模式”..一个程序,并不生下来就是

让我们还是从外部子组件开始吧，第一个就是IO,解决了IO问题,外部子组件,就基本可以在os kenel层被完成了.IO是属于外部子组件的底层,,手段是利用中断.

中断与系统调用,是二个并列的东西,中断是异步,不确定的(程序员不可定制)的,系统调用是同步,确定的,(程序员可定制)的. 每一个ISR,都是一个OS内核同地位的东西.那些在OS内核下运行的,只能是ISR的DSR部分.

调用system call,有相关的关于并发的保障.System call,call from process mode referring to hardware logic implented in the os core.系统调用(用户进程跟硬件交互的界面与接口),执行一个系统调用,实际上是底层产生某个中断的过程,必定有一个IO事件在底层发生(system call是os级的,中断和IO是OS下面的).系统调用,由“内核实现”,而由用户态的进程,“发出”,,故它是内核态的callbacks,这种callbacks,由一种“软件中断”的机制发出并存在.信号由软件中断实现,中断分二种,第一种是硬件消息,第二种是软件中断,软件中断分为程序错误的异常和陷阱,等等

然后是内核的同步技术,内核段,就是对于IO及中断,内核(这里说成CPU更合适? 内核只是CPU的策略)必须是一个并发程序(服务器),才能支持这些本身就是并发逻辑的东西.内核中进程提供的“多线程多进程”,是不是就是内核本身的“内核同步”??

调度与IO
-------------

io为什么也存在调度呢，因为它也常被实现为函数，要占CPU时间，可以被整合进线程处理，需要同步机制。所以，它跟多线程有相关之处。

任务有并发，IO也有并发。与任务一样，cpu处理IO的方式（中断）与调度（分时），，是以进程为单位的，因为软件封装了一切，仅对一个进程的东西可见


好多操作系统都利用优先机制（而且是多级的，从软件上模拟cpu的两级特权位模式）实现同步，进而实现并发，还有的利用延迟处理的异步让权，但通用概念上的并发中，并发体是不分权级的，对这种并发，只能由内核或用户级库作为第三方来调度，实现抢占，所以，调度与并发是本质上同源的。

先解决调都再解决并发调都（并发实际上全称为“并发调都”，，当然也有并发IO，，那也是对需要并发处理的io请求和io体，io处理例程进行并发调都），，即以任何先后顺序来处理这两者，，都是不对的


冯氏计算机,在每个CPU中,都是某种顺序确定的过程,有一个固定的以进程为单位里面的活动执行路径(内核[1. 内核,就代表PC的整个软件环境,软件资源的总管,就像py vm一样,它们总是其内存在的进程或线程的源头.]中有一个结构表示这个进程),这个确定的顺序过程,就像一本菜谱定义如何做一道菜一样,在没有开工之前,它是确定的,静态的一个EXE执行路径体,定义了未来在某个时刻被运行时的动态情况,这种并不确定的动态情况就叫进程),

然而,单进程并不代表不可以有并发(虽然CPU级是肯定没有),我们可以在(核心或用户级的)进程里模拟并发(并发即从单任务中模拟出子任务,或在单任务的内部产生大量子例程),比如某个进程形成不同的子进程(fork()),用协程定义很多不同的执行路径,让它们不确定地去运行,多线程和多进程就是在将每个线程模拟成多处理器中的每个CPU.
前面我们讲了任务与并发，现在讲IO与并发。

>较之硬件，虽然软件足够灵活，但本质串行的冯氏机还是不能很好实现并发逻辑（异步就是延迟干某事比如IO，它也可以达到提供某种优先机制解决一些同步问题以实现某些并发），这就像软件工程虽然提供了很多解决之法，但本质作为逻辑抽象系统的软件复杂度，，还是其疲于奔命的,,多道任务并不是真多道，多道IO不是真正的并发IO(内核再从软从抽象上进行突破，也改变不了硬件基础的本质，它只能使软件上出现一种假象)，，所以，，对于并发，它还是需要提供支持的


为什么需要并发呢?一个重要的原因就是,一些应用的逻辑本来就是并发的,而并不是为了分流等等实际需要.

中断就是这样一种并发,中断驱动的IO,消除了IO要忙等待CPU的必要,这种并发中,主体是OS主线程(在使用CPU)和IO硬件例程(要使用CPU),,当他们各自干各自的事时,中断不会带来任何问题,但是如果这二个线程同时访问修改同一个内存位置,则需要某种措施保证预期结果的正确性.这导出了调度条件与调度机制这是地道的并发问题.
对于IO的并发，其实,只要涉及到有对共同访问的对象保证其安全的需要的地方,就有信号量,锁(常常跟”互斥体”这样的结构在一起)这样的手段,而不是一定要涉及到线程和多线程,而多线程也会用到这些手段是因为线程作为并发的原因,它一定也会涉及对一个对象的共同访问.

信号量就是旗语,Db4o中的旗语就是信号量,像数据库,网络,企业集成中间件(比如EJB容器),这样的要求多对一的应用总是会用到并发控制,并发控制其实在很多场合都用到,只是它们往往被高度封装因此我们看不到它们而已.
