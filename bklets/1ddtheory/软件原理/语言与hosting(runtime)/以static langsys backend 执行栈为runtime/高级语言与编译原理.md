高级语言与编译原理
=============

前面说了，在一个计算机系统工程的全过程中，开发的二个因素，平台与语言往往是相互依赖的(作为编程的基建存在的)，既然OS已经软件化了，遵守了人类懒的需求与特性（它可以代人管理复杂的硬件机器，并从软件上提供了简便的软件上的功能扩展接口）,自然需要一种高级语言来配.

一个语言要考虑写法（前端），与平台的接合（后端）。


这首先是解决写法的问题。对于OS的设计是分层，那么针对映射手段编程语言,能否利用一种更强大更易于人理解的方式来编程呢？这就是编译原理。它使人们摆脱纸带，用书写的方式写代码，用类似阅读，理解的方式来阐述编译器的发明。OS与语言系统（主要是编译器），是PC软件平台上，基础建设的二个重要支柱。

解决了提供一个编译器的技术后，后来又出现了范式和数据结构与算法（解决映射端和语言端“使得编程更符合人性”的手段），它是语言系统演化的高级阶段，业界对于这个问题往往采用结构化（语言内）和分模块设计。

结构化范式，要说函数，必定先要说到过程，因为过程式语言中，函数主要是作为过程的特例的，对于语言外，，也是分块设计不但分清了抽象而且分开了编程的人可以做到并行设计
模块化提供了让多人并行编程提高生产力的可能不只是使逻辑清希

用计算机来识别的语言只需是(不是只能,而是只需)某种形式语言而非我们的自然语言(如果硬要这样,那反倒是不合理和不必需的,因为自然语言是一种形式语言的超形式,在语法语义层面存在很多歧义,比如一个句子有二层语义,虽然这是现实中一语双关的美妙使用,但是在编程中这正是要极力避免的,仅仅因为不需要那么做,计算机本来就被设计成只处理确定性的算法[1. 而语言作为算法描述工具,自然不应出现二义性,,语言逻辑,在计算机看来,都是算法..]) 而实际上,计算机上也从来没有实现过一种严格意义上的高级语言,带有它作为自然语言的不必要解析元素,可以被机器解析的只能是某种基于严格离散的形式语言,形式语言是严格的某种模型(不符合形式规定的条件就出错,这看起来似乎比自然语言还要严格,但实际上越是灵活的东西越难于用计算机表达,而对于计算机,它的本质就是一离散系统,只要给它提供某种它能识别的固定形式就可以表达进计算机,形式语言有这个固定条件,而且有对应的形式处理系统,而自然语言是活拔的,某种具体的自然语言不可能被形式化为某种模型被描述).

>正如图灵模型不是一种真正智能的机器模型一样,计算机作为一种机器,给计算机设计它能识别的高级语言只能是一种形式语言 .(巧合的是,计算模型往往跟语言模型一样,都会用到抽象识别装置比如图灵装置,整个语言模型包括它的三个阶段,都是某种抽象的识别),,我们先不谈这些图灵装置.因为它会在后来有涉及.

**如果人类能作到识别自然语言，实际上这已经超出了人类智能的成就**，所以也是不可能的。
写到这里,我突然想起什么是真正的智能化的问题,即电脑到底是不是一台有自主思考能力的设备?答案是:不是,对于机器来说,它永远管执行,所以是非智能的,而程序背后的设计才是凝聚着智能的,它是由人创造的,所以机器对智能的反映能力终来源于人,计算机只是通过执行预定义好的程序,反映智能的工具,它不能智能化地自创建程序.这就跟代码生成技术一样,真正不需要人干预,由计算机程序生成程序的技术属于智能的范畴,那些UML技术,只是辅助代码生成的技术而已.不过这些，是老远以后才会谈到的了.









形式语言VS自然语言
-------------


什么是形式语言呢,,它是一种什么东西,,因为它只是自然语言的某种,而且是有限的[2. 我们见到的计算机语言语法都是有限的,且基于原始的研究,一直到现在都没变],形式化,所以理解它的最好方式是从自然语言方面的东西举例, 与自然语言一样的是,形式语言也有语法(这归功于乔姆斯基这个外行的努力).,于是,我们不妨可以这样理解. Todo:计算机语言要变成自然语言的种种限制,与它的模拟方法,比如用类型表达概念 在人类的自然语言中,语言有组成它的最小单位即词(较大的单位有句子,段落,文章,卷等等,这些更大一级的单位又是由词或其它单位构成的,但是这些概念,虽然其中一些是指代相同的东西的,比如词和短语,但它们是处在不同的说法层面上的,词是处在词法层面上说的,单词是处在句法词面上的)形式语言也有类似的对比. 比如:

自然语言要素 在形式语言中的对应 所属说法层面 字 词法 词/单词 串 词法 单词 标符号 语法 短语 终端或非终端结点 句法 句子,句型 语句 语法 文章 程序 语法/章法

介绍完了语言单位,那么接下来就是介绍语言本身了,什么是语言呢,语言就是句子的组合.包括词在内,这些语言单位构造的语言具体或语言形式统统称为串,语言的最终目的就是得出语言的一个一个串),和语言单位进行组合(产生串)的规则即文法产生式,任何语言最终都是具体语言材料即词汇和具体语言规则即文法的组合,只要开始涉及到语法层面,那么语言要素才是语言的东西.

>一般也把语法叫做句法,从文法的眼光来看,一切语言形式系统都是文法,所以其实词法也是文法,因为语法就是句法,而词和句都属于文章单位.所以正规式,也是一种文法语言.

于是我们不妨提出一个串的概念.串是语言材料的模板(串代表一个一个的语言具体或语言形式),串的组合可以得到更高级的语言材料,比如句子啊,而文法产生式是语言材料间如何组合的规则,即规则的模板(文法产生式产生文法)
一个具体的语言,或语言形式的模板,它的产生最终是通过串与串的等价替换得出来的(串才是最小的面向行的[3. 面向行的编译器的意义在于1,写代码时是一行一行写的,复合语句也是行,2编译器或解释器都是按行来进行的.每行形成一个AST,整个源码就是一个AST森林了.
]编译器处理的东西),,如果存在w0-&gt;w1,即串w0可以替换w1,这个串间替换的规则就是“文法产生式”,,用来产生文法 而“句子”这个概念是我们最终要得到的.因为它才是构成一篇文章或源程序的最终最小单元,在语法分析中,就是起始状态(终极的语法产生式,最终需要的语法产生规则). 我们抽取英语中一个子集来讨论, 泛义上的“句子”的形成就是一个根据“语法”不断组合替换“语法产生式”的过程.所以下面“中间形式的句子”可以是成立的: 主谓宾 I谓宾 I谓苹果 I吃苹果 (当然,英语中的句子不会像上面那样不“严格”,实际上英语中的句子要严格得多) 英语“语法”中有“主谓宾”这样的“句子”,和“主谓苹果”这样的“句子”.(注意到我把一些词加上双引号了) 所以当我们在源程序中写下苹果的时候,就想到有朝一天它会被词法分析器拿走并进入语法处理过程,苹果这个“字符串“被词法分析器作为“标记”,此时它就是语法上的终结符.非终结符可以表示某个中间语法产生式产生的结果. “非终结符”和“终结符”是单个的“符”,非终结符就是一种语法产生式中的左边的临时符号(相对最终语法产生式“句子”来说)而已.它代表一个由串组组成的长语法产生式,当产生了句子的时候,编译器就完成它的工作了. 而像上面的主,谓,宾之类的就是“语义”了.后面会谈到

我们不妨提出一系列对串的处理过程,高级语言的编译器就是完成这个动作,它基于抽象机器上的识别本质,将我们写的一行行类自然语言的代码,最终翻译成计算机能执行的东西(这就是词法分析,语法分析和语义分析,暂且你不须明白太多,只需要明白这点就可以了,我们在后来的章节中会谈到更多的内节). (因为在对串的处理存在三个不同过程,会产生对串不同的说法),所以我们先来严格区别“串”,“标记”,这样才能在后来的讨论中方便一点,“符号”这三者的概念,串就是字符串,词法分析一开始需要面对的对象,是简单无意义的东西,标记和符号就是逻辑上的具有意义的“串”,其实它们本质上都是串或串的组合,我们能区别标记和符号是因为“标记”是词法阶段的“串”的说法,而“符号”是语法阶段的“串或串组”的说法(当然词法分析中只有串,而语法分析可能是串或串组).在接下来所有的讨论中,我们规范说法,当我们说到语法分析就会说到与它相对而言的下一层即词法分析上的“标记”,当我们说到词法分析就会说到与它相对而言的下一层即源程序文本中的“串”.语义分析,我们最后说. 所以说,所有的标记和符号都是串或串组,不是所有的符号都是标记,但只要是标记(当然,不包括词法分析中忽略的串,比如源程序中的空格啊,什么的),它就是词法上的串. 说完了词法对串的处理,我们再来看下语法分析对串的影响. 词,串,,还有一个符号的概念,,词,串是编译原理意义上语言的概念,,符号就是程序意义上的语言本身的概念了,,对应词法分析中的词,语法分析中的终结符等概念,,,这些东西(不光是词,终结符,而且是语句,相关的语句逻辑块比如一个for过程,我们知道在形成三元式时一切都规范化了,成了一行一行的符号加地址的统一形式,) 在被作为中间代码表示时,,就成了实质翻译成的语言(也许此时也不能称为语言,只能称为中间形式)的符号,,词法分析阶段和语法分析阶段绝不仅仅就是分析,,他们还生成和完善以及维护一个记号系统,,前端是一个所有动作的统称 词法分析中的“终结符”被直接送给语法分析作为“符号”.而它产生的非终结符要被语法分析,当然,词法分析器不知道它是不是“终结符”或“非终结符”,这二个概念只能是语法分析器眼里对不同的“标记”产生的概念. 在词法分析过程中,会给“标记”加上不同的“词性”,比如它是“名词”,“副词”,还是动词(我们知道不同的词性可以做不同的句子结构),当然这只是词法层次的“串属性“,体现在后来的语法分析过程中,就会产生语法层次的不同说法的“属性”了. 主,还是谓,还是宾.这是语法分析过程中,会给串加的“语法”属性,而词性相对而言只是词法范畴会给串加的串属性. 在人类的编译器技术中,词法分析和语法分析,以及语义分析, 从来都是用“标记”符ID的属性来说话的,即“符号表”里的那些内容.语法分析过程维护一个符号表.每个表项都是一个“词性”,因为它需要词法分析产生的“标记”的这些相关内容.(对应于编程语言中变量的类型) 语法分析进一步给这样拥有“词性”的“符号”加上语法层次的属性.比如如果标记符ID是一个名词,,那么好,语义分析过程之后,给这个具体的名词又加上了什么样的句子结构属性呢,比如它是作为主语还是宾语,这个不能混淆,否则语法逻辑上就开始出现主宾不分了,更遑论在语义分析中会出现错误了. 所以,词法分析实际上是一个“文本制导匹配”, 语法分析实际上是一个“词法制导产生” 关于串的逻辑就是产生式逻辑,关于产生式逻辑有一个就是上下文无关文法(这也就是当今很多语言采取的乔姆斯基的文法了),,而其实存在很多其它文法的 上下文无关文法 为什么说上下文无关呢?上下文无关语法定义的语法单位即句子,是完全独立于它出现的环境的,逻辑自包含,不需要其它的信息,它就表意明确. 当我们说到文法,都是以非终结符作为最小语法单位的

编译原理
-------------


编程的本质在于将语言机机制逻辑转化为应用逻辑,完成它们之间的变换,编译器的本质在于完成从源语言到目标语言间的这个转换[4. 呆会我们会看到,其实这个说法改成,如果这个编译器有一套显式的中间语言,那么编译器的要质在于从源语言到中间语言的转换,也几乎成立.因为对于后端.不存在跟前端一样的一套统一的理论.更像是平台逻辑,而不是形成语言的逻辑.],这样说不免有点显得空泛,但这正是因为其中经过了很多抽象很多迂回. 编译原理所涉及到的那些东西,就像OO一样,对于计算机来说,完全是一种迂回(在最低层意义上,计算机总是直接跟它级执行的raw指令放在一起被讨论).因为它首先是个设计(是个抽象). 最初的第一个编译器是以很复杂的方法被写出来的[5. 在1954年至1957年期间,IBM的John Backus带领的一个研究小组对Fortran语言及其编器的开发,但是,由于当时处理中所涉及到的大多数程序设计语的翻译并不为人所掌握,所以这个项目的成功也伴随着巨大的辛劳.这是个因为缺少设计而付出了大量努力的尝试,对于设计,本套丛书的第二本一开头就有涉及],后来的编译器是有形式系统与形式处理机系统这样的理论指导下发展出来的,因此,解决开发编译器的角度不同(设计方案与抽象角度),那么所付出的努力也会不同(所以说设计是主导其它编程工作的),这个道理很简单,只有在脱离编程的层面,提出的关于某个事物的计划真实可行,那么当它被编程实现时,就一定会收到预期的效果,(这种计划,就叫设计,它可能是对事物进行探索后形成的一套理论抽象,只因这个抽象简单,所以将来这种设计被实现时,编程也就能做到简单,也可能是对人的编程工作本身的一种支持一种靠扰,比如,为把将来编程时用于维护的工作量作到最小,所以在编程实现前,在思想级避免那些因为不良的考虑而带来的问题,或采取更好的方式促进这种复用或维护) 关于抽象的讲解, 其实本书行文到此,有太多的地方都涉及到这种“将问题变得更简单”的思想,比如我们谈到OS,实际上就是一种将平台问题转化成软件问题的抽象,它使开发者能面向一个一致的软件平台编程,它使应用迁移到一个比硬件系统更为强大的软件平台.当然还有很多,很多. 迂回就是抽象,有时复杂性仅仅是为了跟人靠近而不是屈就计算机,因此这个绕的弯子是值得的,是一种计算机逻辑向人类逻辑的变换,虽然最终要变换成计算机逻辑,但我们只取OO的中间变换,,,虽然OO最终要变成计算机离散逻辑,诚然,计算机的东西是死的,用C的三种流程控制加基本类型就足够反映,但是人们却需要越来越抽象的语法机制,比如C++的OO,再到Python,Ruby的那些ducking type语法机制,因为抽象带来的不是复杂性,而是靠近人的简单性,这个要特别明白,,,即,相反的,抽象是使问题简单化而不是复杂化 比如:实际上我们作跟数据结构有关的开发,往往我们是在用的是数据结构的抽象,而不是写了数据结构的实现,还比如游戏开发时的jpeg,实现一个jpeg encode,decode需要懂图形原理,而使用jpeg lib,却只需要掌语言本身的知识 – 比如OO.这就是抽象的作用. 就像GUI 问题,如果你能换一种眼光去看,,那么或许我们现在所看到GUI就根本不是现在的GUI,,现在GUI的消息机制,也许以另一种思路就能很轻松解决(比如我们将界面逻辑看成XML逻辑,在XML中提供消息机制达到的效果,或者根本不需要一个所谓的消息机制(比如QT用邮件槽) **不可思议的不是问题本身,而正是人类的大脑**,任何问题都可以只是想象,然后才有解法),在本书继续展开的过程中,你还将看到更多关于抽象,设计的东西.

编译原理的抽象就是:为了迎合人类能读懂的文本源程序(面向行的编译器[6. 因为在我们所处的年代,大家都是通过用键盘写源程序的方式来写程序的(没有人是用嘴说程序的吧?,这也就是大家说的“面向行的编译器和编译原理了”)]),所以它先提出一套关于文法的理论,为了这套语法就造出了正规式,自动机,最终到语言实现本身这中间的诸多逻辑 在这个系统工程前期,,编译器前端(词法,语法,中间代码[7. 对于中间代码,有人也说它处于后端,其实中间代码分表示与生成,有的时候,前端主表示,后端主生成.])大部分理论还是基于编译理论的高级逻辑的,实现方法和图径都比较单一,因为有统一的理论和相关的yacc.lex工具等,在后端时(代码生成,代码优化,运行时环境,错误处理和调试)就得进入平台逻辑了..这里才是发生分歧的地方和可以无限深入的难点所在.. 对于“编译器原理是给定一门语言的规范”来说,编译原理就是指前端,对于“编译器原理是完成语言间的映射”来说,编译原理就是后端,因为前端词法语法,实际上是文本识别与处理,而后端也可以不属于编译知识,,而是平台处理逻辑,,至中间代码生成时,已经完成高级源程序到代码的生成了(虽然是中间代码,虽然还要经过汇编到最终的目标语言,不过这些后来的过程不做也可以,问题不在这里,因为我们也可以面向一个内置解释器的虚拟机写这些中间代码,,,后端的动作不属于编译原理,因为视具体平台不同,,后来的过程不是统一的理论了,,比如代码优化,,那更是一个没有定论的过程. 因为我们现在是以”写”作程序的手段的,是面向行的,因此编译器也是面向文本行的,,它每次在输入的一行中开始它的工作,字符串成为编译器唯一面向的东西[8. 后来你会知道,每一行语句都对应中间代码的一个三元式,每一行都是一个编译时给定行标号产生内存地址的],,首先,从一段源程序中读入,,词法分析的任务在于得出一个一个的token为语法分析所有,,,词法分析直接面向源程序文本,,语法分析面向业已分析好的词,,故前者仅仅产生词(标记token,注意这是标记),只有语法完成才能产生语言(文法产生式),而语义给业已建立的语法和语法元素(即树和节点)增加属性等语义信息,,语义分析过程的一个实现方法就是这所谓的语法制导翻译．语法分析过后,如果是一遍扫描,那么中间代码几乎产生目标代码,编译几乎完成 编译理论给程序的开发者和编译器的开发者带来的简单性在哪里呢?正规式和自动机理论统一了词法分析的过程就像大家都用bnf来描述文法用dfa处理文法一样,它让编写编译器的工作变得科学化和统一化,有人说,nfa是给机器看的,而正规式是给人看的..这样说比较形象,因为它揭示了等价的双方存在的不同目的(一个是对人的表示,一个是对机器的处理),而实际上直接写语法也是可以的.词法分析可以一点也不涉及到正规式与自动机这样对于人的迂回逻辑模型,代码控制能力强的人可直接写此类逻辑(手工实现的编译器). 一个很简单的例子,在编译器内,抽象了位为类型,于是高级语言的开发者可以直接在类型上工作,从类型的角度出发,更专注它们要做的事,并解决它们.这将会是一种什么过程呢, 编译器首先将CPU直接支持的简单类型即机器的类型[9. 只有256种字符型能直接被CPU处理(与整型一一对应的那些,比如字母,转义符等),其它需要被通过其它抽象编码的字符,比如汉字,是不能直接被CPU处理的]映为语言的类型,再造出越来越复杂的抽象类型,,,所有语言做的,是计算机在编程层以一种数据化来解决问题的过程(编程的设计大量借助了类型机制加数学中的表达式求值这个理念).只不过这个过程会越来越抽象.最后完成没有位[10. 位域和类型,你可以参照BCPL这样的雏形高级语言的理论.]的影子.我们后来会谈到 在某个编译器实现的语言上写程序,OO和框架(FrameWork)也是一样的道理,,计算机直接执行的是二进制,,但人类若要组织这些逻辑,就得用OO思想....因为这是人类工程的需要(对于计算机来说就是迂回了) Todo:到现在为止,我们接确到的抽象有: 一个表格

写一个编译器真正涉及到了设计(把编译器分阶段完成正体现了设计,,编译器理论本身就是吸取乔姆斯基这个不懂计算机的自然语言研究学者研究出的成果,以及后来的一整套编译理论,包括,图灵的机器,正规词法逻辑这些高层逻辑模型),,编码(具体编译器的实现自然离不开编码),,算法(关于语法的bnf设计就是一个大算法,验证图灵机是不是会终止算法),,数据结构(树与递归频频出现,这个层次上的数据结构还是离散数学意义的离散结构,树啊,环啊,图啊,还没有到具体用什么语言编码的层次,也就是说还是通用的理论层次),,,是一个系统工程,从C语言的眼光来看,开发一套编译器这所有的过程,是一套算法加数据结构实现的集中体现(当然JAVA也要开发编译器,只是JAVA有高层设计工具,比如OO等,对于算法加数据结构的体现没有C深,而JAVA也一般不用作开发编译器,因为JAVA对于编译器后端开始的工作几乎力不从心)..

符号表与名字处理
-------------

关于名字与符号的语义与处理,是惯穿这个过程的.用到的数据结构就是符号表了. 符号表,或名字表(前者是对程序来言的,后者是对人而言的),其实不是标识符表,我们把符号叫做“语法上的符号”,把标号,只叫做“词法上的标号”,而这二者不是没有联系,符号中,有一类特殊的成员,就是标号符号.

符号与名字处理中,对于作用域的表现,是最重要的.

以后会谈到作用域

词法和语法,语义
-------------

正如关于词的表示逻辑有正规逻辑,对它的处理有自动机一样,词法分析和语法分析过程都涉及到图灵机,有限状态自动机dfa,无限状态自动机nfa,是一种名叫图灵的抽象的机器模型,,它刚好与正规集形成的语言(由一个正规表达式推导出的串集形成语言,这是指词法意义上的语言)一一对应,,即,对于一个正规语言,有一个dfa能够处理它(这个一一对应关系在离散数学中存在科学的证明方法). 正规式和上下文无关文法,是二类性质和功能根本不一样的文法,能拼接(有些书也称为并置),选择和重复词法单位的是正规文法(它用=表示一个名字定义的开始,而语法用箭号),但是它无法处理存在递归结构的文法(比如,名字等式右边会出现跟名字同样的符号,这就说明,它是一种用自己来定义自己的规则,即它是一种递归结构),加入了递归的就是上下文无关文法,递归几乎是上下文无关文法的特征性的东西.词法的正规式无法处理递归结构,这种结构在现代语言中比比皆是,而文法可以处理这种结构和语义. 凡是正规表达式能匹配的地方,语法分析器就能对他们进行下一步的处理.也即,词法分析器是语法分析器的开路者,因为它们基于同样的过程(都是识别出可用的字符串 - 不过词法是识别出由正则表达式简单标识的“标记”,而语法是识别由“标记”本身逻辑上形成的“符号(或组)”而已,说前者是简单标识出是因为只有一个正则表达式,说后者是逻辑上形成是因为有更高级的语法产生式逻辑),而后者正可以以前者的输出作为基础(因为它也是识别嘛).

词法分析只是简单的逻辑,它面向粗糙的文本,最终结果是导出一系列可用的“标记”；依据的是正规表达式；而正规表达式只是一种简单的标识匹配逻辑,并非一种高级的产生逻辑(实际上我们呆会会谈到,所谓的产生式逻辑也是归约移进之类的东西而已,而这样东西,其本质上也是一种标识和匹配逻辑,不过我们把它看作更为高级的产生逻辑,因为这里会出现数据结构和算法上的东西). 而语法分析则采取了文法产生式(而非正规产生式,虽然都是产生串集,但正规式本身表明一个匹配模式,匹配式..文法产生式指明如何为语言产生一个串,前者产生的语言是词会集,后者产生的是语句集,,词法过程远远没有到底语言的意义,,只有到达语法阶段了,,才能谈得上语言,,因此对于编译原理的几个阶段来说,词法处理只是一个跟语言挂不上钩的很初级的过程),它接收的输入是词,编译原理语法分析过程产生的输出是串,串的集合即语言,串即语句,不再是词了,而是语法一级的单元,,而词是词法一级的单元,, 语法分析也只是机器的逻辑(语义开始就是人的逻辑了),比如它把词法分析得出的“标记”进一步识别为“产生式”；依据的是语法产生式.我们说了,语法产生式不过也是标识和匹配逻辑而已,不过在这个过程中,除了匹配规则之外(当然不是正规表达式了而是语法产生式),,还涉及到一系列数据结构和算法上的技术逻辑,所以把它看成更高级而已.

所以这二者本质上都是机器逻辑下的“识别”,是一种形式,只是简单的匹配替换逻辑.不过后者比前者要高级那么一点点儿了.当然,仅仅就因为这个“更高级一点”的说法,这二个过程实际上就变得本质有不同了,,前者是非语言级的,而后者进入语法阶段了,所以属于编译原理了的前端了(其实词法分析可以是编译原理的一个可有可无的过程,可以不依据正规表达式而直接写提取出串的逻辑,这就是手工写的代码控制的文本处理逻辑了,因为语法分析可不管你前面是词法分析还是什么其它过程,它需要的标记能拿到就可以了). 而语义呢,就是不是简单的产生串的集合了.它是把串加入了逻辑(语法制导翻译),不过就跟词法分析的匹配和语法分析的匹配是二个不同的过程一样,这里又存在一个二义性. 即在语法分析的阶段也出现过一次“给串不断加逻辑”的过程.

给上面一句话接个下巴,语义分析正是针对标记符在语法分析阶段的那些属性进一步给它加上语义级的属性内容.所以是“语法制导翻译”.(注意到了吗,匹配,产生,翻译这三个词在措词上的巨大区别,所以,词法是词法的,语法是语法的,语义是语义的) 这些符号记号在前端被不断完善它们的属性值,比如变量类型啊,,关键字ID啊,变量编译后的地址啊, 语法分析产生一段抽象树[11. 树这个数据结构深刻并与生俱来地与递归相关,在稍后数据结构章节中将会详细讲到],,,,因此你可以看到LR,LL,自顶向上,,自顶向下这些概念,,语法分析的过程产生抽象语法树,供下一阶段的语义分析和代码生成过程用..

分析树是经语法分析后形成的对语言的表示(因为语法分析就是为了形成语言,比如表达式,函数过程,等,所以我们说,这种分析树实际上更侧重是对语言的一种表示,是对形式上进行推导的过程的一个抽象,与下面的对语法树对其它方面有所侧重不同) 分析树是语法推导的显式表示,抽象语法树是语义(相比起DAG来,它是初级的一些语义)意义上的显式表示,而DAG,就是高级语义意义上的显式表示(甚至包括了除类型检查外的优化).这些显式表示都不必在源程序中显式构造出来,因为整个编译器可能是一遍的. 而语法树,全称是抽象语法树,实际上是对分析树的一种简化和抽象, 它可以被用在 (侧重一些在与语法分析阶段同时进行的静态语义分析任务,这个时候的静态语义分析较之稍后在语义分析中的静态语义分析比较初级,由于语义分析后面就是中间代码生成,因此抽象语法树对于中间代码,本身也可以是一个最基本的表示形式) 语法树是语义[12. 因为它着意去掉了分析树中那些对于语义来说显得多余的信息,及语法识别用的节点信息]的,而分析树是属于语法的,,抽象语法树能反映程序的语义结构.

语义分析,就是将语法分析过程中产生的符号赋于语言的意义,即语义(比如此符号具有什么类型,而类型是语义上的东西),语法制导翻译(以之前分析得到的抽象语法树作为推导的翻译过程,为它当中的各个节点建立意义)不属于语法分析阶段,,即不属于上面一段的编译原理语法分析阶段,,注意翻译二字导致意义的差别..如果说词法分析和语法分析仅仅是分析阶段的话,,那么从语法制导翻译和中间代码表示开始,,就进入了实际的翻译的实质阶段了(编译就是把高级源程序转为汇编目标语言,这个总过程称为编译,,编译,编译,有一个译字,直到这里为止,译字渐渐明朗,编译前端完成,编译完成,因为进入了代码的阶段,虽然这里是中间代码表示), 什么是语义是语义的呢,比如“左值与右值”的区别,
[code lang="c"]
int main()
{
//语法上可以这样“写”,但你的思想里决不能这样“认为”,即语义不是跟语法一致的.//因为语法是语法的,语义是语义的.
//为什么呢这样说呢,看printf()的二个例子

//首先,它是一个数组,其中每个元素都是char *
printf("%dn",sizeof("dsfasdf ")); //大小为8

//而它是一个指针
printf("%d",sizeof(mychar)); //大小为一个指针长,最长为4

return 0;
}
[/code]
这就是语法跟语义的区别所在(语义就是未显式化的语法，或说，语义就是运用语义后形成的新语法，有时，也可在语法树上写程序，，树与语法的这种关系就相当于语法与语义的关系，只是一个显式与未显式的关系。).. 语义分析,首先要某种表示方式来描述语义.这种方式就是属性文法

自顶向下语法分析法
-------------

编译原理前端实际上是一个高级文本识别及处理的“领域”, 在文法产生式中,要分清来自扫描程序的“记号”和语法分析中的“符号”,前者,也可出现在产生式中作为“记号符号”,我们称原本就存在于产生式中的“符号”是“(语法)结构符号”,于是,在一般的情形下,记号符号,往往成为推导结束时的终结符,结构符号,往往成为推导过程未结束前的非终结符号,这二者构成了组成语言的符号.

而且要分清在定义情形下的语法产生式,与在替换情形下的“替换式”,前者发挥一个定义的作用,而后者表示一次替换过程.实际上,前者才是语言的主体,后者只是具体于使用前者的某门语言的推导情形描述.

在语法分析中,星号是可以通过本来就具有递归性质的产生式达到同样效果的,所以它并不是产生式中的部分.如何产生星号的效果(而且假设面向同一组产生式,产生同一个句子),这引出了推导过程中的二种明显情形与话题:一是对于一个具体串,它产生某个句子的推导过程,往往具有多个,二是如果从最左边进行推导,或从最右边进行推导.往往可以产生这二种结果相同但过程不同的效果?那么这是不是可以成为我们研究出推导过程不变真相的起点呢?

这种“表面现象”实际上唯一被决定于“这个串的内在特征”,只要用树表示“这个串的内存特征”,那么,对于推导过程中出现的二义性,我们就会有一个性质上的,且形象的理解,而我们,也将借此发现更多的东西.这就是为一个串建立它的推导分析树,以此来分析这个表面现象下的必然真象.

必然真象就是:如果为一个推导构造它的分析树,那么,表面现象就可解释为“它们是由对分析树的不同次序访问而导致的几种情形”.比如,对一棵树的前序,后序访问.(而这二种情形又恰好能推导出一样的句子)

于是,我们可以去掉一些例外,混乱,偶然的情况,而把握一些如上的“必然的情况”,并假设它们是我们研究的“真相”和唯一要研究的东西,这样,对推导过程的全部,我们假设只是由这些特例来界定的.比如,最左推导,是前序访问,而(在推导式中的)最右推导其实是分析树中的后序访问.

整个编译原理,也就开始限定于最左,最右这类问题的研究.

从分析树开始,联系到具体语言某个产生式推导的分析树,我们发现它是对相关源码的抽象表现,即“粗糙表示”,而我们想得到相关源码的编译结果表示,这就需要去除这样的抽象,使分析树透露出来的推导信息(因为一次推导实际上就是一个分析树,所以这指分析树本身)转化为某种与源码表示一一对应的东西,这就是“中间语言”,这要从分析树本身开始,去除其中对于中间表示不需要的抽象,转化成另外一样东西.

这就是(抽象)语法树表示的“中间代码”.(它虽然跟源码一一对应,但其实对于源码,它也是某种抽象表示)它不具有转换前的分析树的某些记号信息,然而,它却是对于产生最终源码表示所急待获得的(如果编译器需要维护一遍“中间代码生成的话”),而且效益上也不错.因为它去除了转换不需要的某些分析树上的东西.

属性文法
-------------

完成了语法分析之后还是分析树，在完成了语义分析之后才是语法树，指称语义学，就是语义学的理论基础,algo60第一次区分了语法和语义的分界 属性文法,实际上称为文法属性更好,因为它主要做的工作就是可以利用它(一些规则)把属性关联于文法单位,这就是属性文法的字面意义,和它的根本任务(它仅是描述规则用的,所以它并不能凭这些属性文法本身得到一组求值顺序)

属性文法实际上并不能描述程序的语义(它只是描述了属性,文法属性嘛),它只是提供了一种手段,把事先定义好的意义,关联于语法单位 属性文法即是一种-----没有任何形式规定的(它不是一个严格的形式系统,只是零散的规则集合),,单纯的(对于如何求值)的规则集合而已,但它没有提供实际的求值事务和求值顺序,这个任务是由语法分析来完成的.

属性文法是有关属性表示及计算(要严格分开这二个过程)所用的形式系统,就跟语法分析使用巴斯科范式描述产生式用于产生语言一样,也称描述属性所用的形式(比如,使用if-then-else这样的类真正语言用的结构,因为这种描述形式不关乎不影响真正的属性计算(因为它的顺序变动并不会影响这个描述形式),所以其实它是一个代表而已,即属性文法其实不是真正的属性的文法,而是对属性文法的一种旁观描述,出现在属性文法中的终结符,非终结符和例程调用 – 真正的C例程,才是影响属性计算的东西 – 故属性文法不必真正处理语义的二义性,所有的工作可以在那些C例程中完成,,在这里要分清属性计算函数和例程调用对于属性方法的作用,属性计算函数,就是对应于产生式的某个或某套属性计算的规则用“以产生式左边非终结符属性为返回值,以产生式右边可能是终结符也可能是非终结符的属性为参数的一个关于属性依赖关系的模拟函数”,,例程调用,就是属性计算函数可能调用的真正的C例程,编译器的语义分析部分可以在这里完成一些真正的任务,比如处理语义和去除语义二义性,为什么特别强调这个过程呢?因为如果此时是用高级语言C来写这个例程,实际上它就属于真正的属性文法了,因为它用了高级语言来呈现)为属性文法,它为稍后的属性计算提供内容,而属性计算,是基于属性表示的另外一个过程. 首先要解决的就是证明之前定义的属性方法的充分性,即,关于它是不是一定会计算出某个可用属性值的有效理论(属性流问题),
属性文法(一种形式化系统)指的是一种基本框架和综合过程,它用于构造语法树,检查语义规则,和生成代码,而实际上,不必专门提出一个属性文法的概念.

在以语法为主的一遍分析过程中,可以把语义分析整合到文法分析过程中.即,可以把这个遍整个看成为语法分析,而且,语义分析可以看成是文法分析中的某个特定过程.s-属性文法就是拥有特定属性流规则的语义规则(如何求值),它跟自左向右的语法分析一起就拥有了s属性(求值顺序).
既然一些语义分析可以在语法分析开始形成分析树的时候进行,那么其实有一些语义其实是可以跟语法紧密进行的(这样的分析叫一遍语法-语义分析),比如常量折叠(它是属于初级语义的),而常量值的获取来源于语法,甚至词法.当然,所有关于语义的任务,都可以放在真正的那个语义分析的阶段进行处理(这样的分析叫语法-语义分遍分析),所以,真正的语法,语义,其实不是严格必须分遍的.

什么是语法制导翻译和一遍翻译? 有一种很常见的编译器组织方式,如LCC,它只为构造语法树(或其DAG表示[13. 我们知道DAG对于描述属性流的逻辑有益])而在语法分析中使用动作例程,这样的语法树实际上将语法分析和语义分析作为统一的一遍(这篇的目的在于将生成的语法树或DAG直接作为中间代码的初步表示形式),而后通过独立的一遍去修饰语法树(完全可能是用另一个属性文法,比如树文法,去刻画这个修饰过程),,这样就最终完全了语义分析和中间代码生成,这就叫“语法制导翻译” 在整个语法制导翻译[14. 实际上,语法制导翻译不如说成是语法制动翻译,这样它能带动编译中其它动作的意义就出来了]过程(以语法带动语义,即语法一遍,各种语义任务全包含在其中的过程)中. 也就是说,最终属性值的得出,可以借助动作例程在第一遍中即时求出(它并不是专门地为了语义分析与求取,只做一些初级的语义任务),也可以在另外一遍中利用专门的溯树文法去求(专门地作语义分析与求取).

属性文法解决了为产生式中每个符号如何定义求值规则的事,而翻译模式解决了为整个语法树按某种求值顺序得出根属性的事,这二者,结合地解决了最终语义分析的任务
一个属性计算规则或一套属性计算规则可以被绑定于一个产生式,属性求值的真正意义是什么呢?首先,属性求值函数并不真正存在,它只揭示了某种产生式左右边属性的依赖关系,支持属性可计算性的理论,故真正的属性求值不是这个求值函数, 语法分析是对每个语句进行一次语法分析，后产出一个串，语法终久还是一种形式，语义则不是，它是语法没有明显用形式表达出来的东西 具体语法树与抽象语法树对立，语义分析与中间形式阶段是不一样的（它们模糊了前后端的分界），前者还属于编译中的译字，后者将译的结果用全新的一种形式（中间形式，比如一种理想的汇编语言）来重新表达。 属性文法实际上是用文法表达语义，而这肯定是不成立的，用形式表达意义，人工智能都做不到。故，属性文法还是服务于语法分析的。 语义虽然没有一个形式机制，但也决不是玄妙不可捉模的，而是经过表示了的且可以被推导出来的机制 中间代码表示和生成是二个不同的步骤,表示则着眼于产生的串,如何用中间形式(源程序到目标语言的中间形式)表示一个串(一个符合语法规则的句子,),,一般采用三地址格式(这是个形式化了的中间形式表示的串),比如对于算符优先的规则,,一般采用波兰后缀,或逆波兰形式.如果前面分析阶段主要是树和图的方式来说明和处理,那么这里栈式处理数据的方式在这里频频出现..、

《可变目标C编译器-设计与实现》,懂这样的这一本书,需要懂里面的设计(那些源程序下面的语义,比如编译原理),而不是C源程序表面的语法含义 事先,此书对章节的整理大概分如下几部分 公共的数据接口有,string,alloc,symtalbe,List,types 语法分析有expr,smp 等等,书的第十页有一个很清楚的表格 代码生成接口一章讲的代码生成接口,是后端代码生成器的接口,非中间代码的.

然后,就是需要弄明白一些概念,整个LCC的语法和语义是一遍的.整个前端包括dag以前的部分,dag以后的部分就是后端了,因为dag就是LCC的中间代码格式,它利用一种接近汇编语言的形式(即dag,它是一种)描述了(中间代码的)可执行逻辑.这种格式很利于后端利用(它是高级语义逻辑,即到达了执行意义的语义逻辑的中间代码形式,而抽象语法树,可能只是初级语义).可以很容易地被后端转换成真正的目标机上的汇编语言(因为中间代码跟目标汇编代码几乎格式差别不大),整个后端是利用一个生成接口,加一个Lburg代码生成器的生成器构造出来的.

在递归中,树与节点等价,入口与table等价,代码段基本块,生成目标代码的最小单位,对节点的扩展以注释,执行点给剖析层面建立的机会,dag定义了将树线性化的方式,属性计算顺序,提供化简树的机会,这样,从后端看,源程序就是dag森林组成的代码表了.后端关于dag的树文法即lburg模板与规范.

