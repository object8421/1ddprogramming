




###### 库

Todo:逻辑互饰,放到抽象那一节
**一堆能工作的源码(比如,用C写的一个软件的源码)的确可以称为库,**可以称为设计(实现和设计,编程和设计,都只是相对的说法,无法精确定界,库不一定是强设计的库),但只有那种投入了用人类观点良好指导的源码体系,才能称为良好设计的库

Api是应用程序编程接口,syscall也是一种api,然而它是"api implented in the core,but used by the user in applications",所以它是一种"capi"

内核程序不叫app,api最初专指c api syscalls(是一种关于函数及函数调用的abi规范),因为对用户程序的,面向用户程序开发者的接口,所谓abi和syscalls api,是内核例程对于建立于内核之上的系统开发和用户程序的规范,abi是编译器的,syscalls是语言级的,面向编译器的二进制abi,内核的基本单元是C函数,它们对用户程序只有这样一种api和abi上的调用规范要求. 其实,泛义的api,就是“程序中间逻辑”,不跟某种语言(比如C),不跟某种代码(比如c function abi)有关,比如库也是api,框架也是.
很多时候,在一个工程中,所有的实现都可以由一个Demo直接写出来(写成CONSOLE形式,也可以是一些对象集上面说了),然而,真正形成产品时,我们需要再组织这些实现,让它们最终形成的产品出现(因为一个真正的产品,必须要考虑到未来修改的需要啊)这往往是一个比写实现还要难的过程,因为我们在写“如何使用这些实现,如何把这些实现分散封装到未端”的接口逻辑,而这个逻辑,往往有时比写实现本身还要难！！

联系一下C中的函数级API,实际上API的概念就在这里扩展了,,,类库,方法,类,某个库内定义的某个结构体,都可以被称作是API(API就是面向应用级的接口,实际上大凡接口不是面向应用的[^6]还真少,所以API一般意义上还可作为一般意义上的接口),,,用户使用这些实现,通过一些迂回的办法,也即定义一系列使用它们的接口,最终可以形成很复杂的程序,,也即,我们编程大部分情况下只是使用别人的东西,我们只是在写接口粘合代码,而这,就是真正意义上的编程(一个程序往往只是一些使用某些特定代码产品的使用逻辑本身,并不实现某个算法或提供给别人可使用的某个API),,当然,也不能说人家提供API的人写这些API的过程就不是实现(只不过它们是写的目的是供别人使用而写,而我们是为了使用而写,应用永远是重要的嘛,因为毕竟我们不需要重新发明一些别人已经写得很好的轮子,,也即我们相对是开发者而人家相对是产品供应者)

大量使用别人开发的库，这是软工时代的特点之一。

按组合关系来分库存在有平等关系,上下关系,多对一关系,比如有三个库

如图,库A与B,C是上下引用,也是一种一对多的引用(单向箭头),库B与库C是独立平等的关系(可能BC并不引用各自的逻辑,说它们平等只是相对要引用它们的A来说的)
这种构架就是我们呆会在第四部分提到的总架构,库A是GameGeneric,库B是ShowGeneric,库C是LogicGeneric,当然在每个库下面还有很多库引用关系

按性质来分有架构库和工具库(库都是中间逻辑的封装者,然而这中间逻辑也有“是架构”还是“非架构”之分),非架构逻辑就是或工具函数(实现逻辑),架构逻辑就是对一种思想模型的描述,,对其它库的引用逻辑,使用逻辑(封装逻辑),通过这种方法,将利用外来库的行为封装为自己应用的架构
我们知道一个库的发布总是带一个samples目录,然而那是小例子,,大中型程序是怎么开发出来的呢,,你该如何着手写一个大型的程序呢?一般来说是找轮子和写实现.

**任何语言。其实懂简单的api凋用就能成就大型的软件**,说了这些你可能还是不明白我真正要表达什么?我是说:可以由几个API写成一个巨大的程序,而程序中往往真正实现某个算法的API(这些 API有理由说它们是真正的实现,通俗来说就是面向过程里的某个算法过程),而我们天天看到的程序,,真正的技术算法部分API可能也就那么几个,说了这么多,我只是说:我们天天看到的程序,其实组成他们的大部分只是非算法的架构逻辑们！！(这就是被称为接口逻辑的逻辑,,因为它们主要提供为以后的可复用性提供的架构逻辑,是真正的发挥桥接口作用的中间逻辑,那些能发挥实际作用的算法逻辑中间逻辑往往由这些架构串联起来,,离最终的应用逻辑还远呢,)

所以说,库更多地,体现的是一种设计.

就复用逻辑(比如一个使用了OGRE的游戏的实际代码)来说,,它往往是OGRE中的samples演示小程序,如果是一个用yake写成的大型游戏,那么起码可能还存在造其它轮子的过程(比如你还用到数据结构,而不想用STL,那么你需要自己设计―这是在造轮子了,或直接复用GLIBC),,逻辑间的大量复合,和与其它维度上逻辑的结合(比如不仅是图形方面的,还有网络方面的代码等),就会构成一个大型软件了.

然而幸好有一个YAKE的程序考虑进了几乎你能用到的很多库,,当然如果你想用其它的库替代,或者加进其它的库逻辑,或者自己在复用中会想到自己开发自己的库逻辑,也是完全可行的.但是我们一般不改造YAKE(因为如果它不提供SRC我们就无法改造,其它很多库都是这样的).而是拔插使用其内组件库..

>库的组合=功能的组合(类库设计是一种跟语言同级的设计),当然这种逻辑在使用同一种语言下是成立的(不同语言时也可以用Swig等技术来改造或Bind),然而库作为中间逻辑的封装者(库让你跳过库的实现即中间逻辑这些细节而直接面向大逻辑大架构编程,只要引用它们就可以在自己的程序中实现它们),可以一直细化接近最终实现,诚然单逻辑的一个类也可以被封装为一个库但是往往不样做,一个库封装了一套互饰的中间逻辑的有机组合,,这里的中间二字是相对最后的应用逻辑来说的,往往把最终的应用逻辑称为实现,这就是一种实现逻辑了而不再是中间逻辑了(这就是说库可以是一种内含高抽象的架构逻辑或具体的工具函数的实现逻辑,或基于其它库之上的架构逻辑或实现逻辑),库可以直接深入到实现细节,但是我们要控制这种过程,一方面是中间逻辑与最终应用逻辑不可精确定界,另一方面是因为设计与封装是个无底洞,不必做这种深入,第三方面是有其它的库可以plug进来然后在这些“轮子”上实现(库应只提供BaseGeneric这个库构架(此时库本身是一组架构逻辑而非实现集)和对一些其它外来支持库的引入接口(一般接口需实现,逻辑需继承,此时其它库可按需进行plug in 或者out),这就是库引用库,这种情况下有一些未端的实现是不应该加入中间封装的,比较好的作法是用一个库定义架构和基本工具函数集,以及对其它未端工具库的接口逻辑(此时先前定义的那个库就是主库,其它的库是可选的辅库,比如Yake的实现就是这样),实现就是最后一节提到的几个Demo(作为基础的逻辑已经被库封装起来,其它的就是实现了)

像Yake,它提供了一个Base core和很多构架上的接口逻辑,每个接口逻辑都实现了一个对外来库的引用,Base core是工具函数集(也有一些接口逻辑),这是Yake的主体部分,而接口逻辑(Yake也在这里实现了一些工具函数库比如)和对其它库的引用逻辑(也是一些Adapter)才是Yake的重要部分(Yake包括它的base和对其它库的引入逻辑这二大部分,当然还有它的一些工具实现,这样算起来Yake有三大部分).

编程界的可复用主要是面向对象和构件复用和设计模式和设计复用,库也是语言内部的可复用(就跟你拥有库的源文件一样.因为有头文件也是一样的,因为你还至少清楚库的构架,这也就跟理解并应用一个库只需了解其API就行了但不需要了解其SRC级的实现一个道理.ode的头文件集却是一个例外),COM的复用就是纯粹的二进制的复用,因为有真正的接口的隔离作用(此时你根本不知道库的构架),在库定义的接口中,你必须透过接口才能深入接口更下面的逻辑(可能是另一个库的实现),因此接口一方面提供了方便性,另一方面也增加了屏蔽性,这是一对矛盾,接口的定义是为了引入某种架构或桥接二种架构使其配合工作,而这种机制在提供了方便性的同时也增加了理解和使用该接口的复杂性和运行时空的代价.












/*!

\page C的标准库与Gnu Libc.html

============= C的标准库与Gnu Libc


Unix被产生时,是用汇编写的,汇编有移殖问题和开发效率问题(汇编是任何硬架构上的CPU专用语言),因此Unix的作者又创始了C语言,并改写Unix,所以历史上C是产生在真正的Unix之后的,而且正是跟操作系统的诞生密切相关的,并强烈地服务于系统开发的(C是最初作为UNIX专用系统编程语言出现的,后来发展到通用的系统编程甚至应用开发[1. C一坦被发明,立刻就被用于系统实现(因为Ｃ就是根据这个任务写的)Ｃ作为系统实现语言,这决定了它不需要提供异常机制这样的太面向于开发者的影响c程序执行效率的东西]).
C的移殖性超好[2. 这并不表明C是可移殖语言,跟java一样，是相对于具体平台上的可移殖]开发效率良好,这个作者又写了一本书,形成了C语言的第一次标准化[3. 此时的C叫K&amp;R C而不叫ANSIxx C,].在系统方面,几乎是Unix产生之后,各种类Unix系统不断出现,,为了规范这些类Unix的兼容性,及对它们之上的基于C的那些开发工作,提出了一个Posix,对系统调用例程接口进行了规范,因此产生了Posix api规范.然后在这个Posix上发展出了一部分的system crt.C的标准库也一步一步发展出来了.

posix只是松散的语义跨平台，而且只停留在定标准级别，真正的跨平台要二进制，源码，语义层次无修改地跨平台。 

>C语言的最初的版本是作者借用了B语言一些理念的,不过C语言强就强在它被大众接受并进入一系列的标准化进程(第一次民间标准化是C语言的二个创始者K&amp;R写的一本书,上面谈到),但是在89年的时候出现了C++,C标准一部分停留在C++中, 即C89,第二支继续独立发展,发展出了C99,目前最新的C标准是C99,支持并实现了它的编译器市面上比比皆是. 所以,当人们单独说到C的时候,其实他们指的是C99。
注意语言库与平台库的区别，它们是一个OS建立SDK以导出语言扩展和系统开发扩展的那些库，对于C，这二者有重合的部分。
c库实际上就是OS api(crt是c stdlib runtime binaries)，但这个os api不比mfc,qt这样的东西，因为C库要首先是语言的库，然后才是os 的库，所以C库的核心就是些io,string等的通用逻辑了






------------- 库与语言的关系



语言之于系统的关系,就在于:语言扩展系统,比如在开发层面提供新的类型, 很多时候,编程其实是一种对编译器逻辑的扩展,比如编程时从内置类型中派生新类型.库与语言的关系,也与之类似:库可以扩展语言。

我们在前面谈到**编程有实现抽象（建立抽象的过程）和组织抽象（复用抽象的过程）**。那么抽象来自哪里呢？除了语言编译器内置的抽象，库级抽象，其实还有平台提供的抽象和编程提供的抽象，我们要分清这些抽象都来自哪里，比如，C语言中，语言版的数组是用语法和语义写出来的,而库逻辑版的数组是扩展出来的

在如上意义上，系统编程的另外一层意义就是对系统抽象进行抽象。移殖就是一个先要确定哪些抽象来自语言哪些抽象来自平台，再封装并处理平台抽象的过程。

库更多指代一种设计过程,而不是实现.因为它是面向为了程序员的复用目的,考虑了应用,语言的一种综合抽象过程. 一门语言提供的语法形式不是越多越好,而是越少越好,而它导致的库逻辑可以越多越好(表达力强)

------------- C标准库

api与runtime分离

系统开发是一个除了C标准库，posix标准，就没有中间件的领域，apr算一个，但没有一个像qt这样的大块头存在
wine与apr接近一点还是与c stdlib,posix接近一点 
c的综合库大都一样，如apr,glib,glibc，各种os的langsystem附带的c sdk，因为C处在系统开发领域的最开始处

glibc首先是libc,为C提供一个标准lib,而C的应用领域很狭隘（如果它定位于系统开发的话），，所以GLIB，as gtk+ based c support lib,,跟glibc就会有很多共同之处


C的标准库为什么这些小呢?因为C本来就是提倡从一穷二白开始实现的语言,特别是C专注的系统实现领域(C是系统开发的DSL),只需要有限几个函数,比如printf,malloc等.历史上,形成C标准库的历史,就是以“纯C”为中心(开发OS前,我们是没有库可用的,只有语言本身),仅用语言而不涉及到库,来实现出一个系统的过程,在系统实现后,它形成的头文件,就成为C标准库的原型.即,用C实现系统是仅依赖于语言本身的,而系统实现后,形成的以头文件为代表的可复用单元,就成为最初C语言标准库的原型.

Ansi c的标准不仅包括语言,还包括预处理[4. 使用word时,可以录制宏,进行一些免重复性的,对word本身的控制工作,这往往是vbscript,这就是用脚本语言辅助应用的潮流,跟SQL是一个道理,因为这类脚本语言,往往是对工具逻辑的调用,这就是将软件应用上升到了脚本编程的境界,是UNIX发展shell的初衷.是“使用工具的语言”,比如unix下的grep,swd等等,同样,对于C++,有许多的宏,把编译器从工具的眼光来看,这些宏组成了一种“编译器控制语言”],以及标准库.这里谈到的标准和标准库,都是指某种概念规范上的东西,因此各种实体[5. 包括x/open这家掌有unix版权的组织]或第三方都有它们的实作,其中以各种编译器,unix libc[6. C最初是作为unix专用系统语言而出现的,这时的libc叫older unix libc]和gnu libc为主(它们当中都包含了std ansi c lib的实现,但libc,gnu libc C 简称glibc,它们虽然也实现了std ansi c lib,但这 C 为了实现一个附语言发布的语言标准库不是它们的主要任务和全部任务,因为它们更主要是一种系统开发库,因此还需要包含其它的内容).Linux以前主要采用 older unix libc[7. 所以,也叫older linux libc],在libc5之后,逐渐采用gnu libc(沿称为libc6).

上面“其它们内容”主要指os系统开发相关的东西.比如posix,svid等等,在libc和glibc中都有实现.Posix与ansi std c lib又有一些相重的地方.这因为posix规范中的一部分正是ansi std c lib.

你可以这样理解:

posix,svid(面向整个OS规范)

=libc,glibc(一定意义上,posix,svid这些规范的实作品) = std ansi c lib +libc,glibc 中的os core部分(面向os core规范)+ libc,glibc 中的addons

当然,还有一些不只是针对os系统开发的应用级也提供一些类似libc,glibc的东西,比如gtk中的glib,它与glibc只有一字之差且二者内容相当,但却不是glibc.还有一些libc,glibc的特殊版本,比如uclibc等等.

------------- C的输入与输出流


一门语言本来是没有宿主的，输入输出本来是宿主的概念而非语言的概念，系统编程语言如C，接纳了它，并形成作为本身的一部分（这是系统编程语言的使命）

平台抽象可以与语言抽象结合。比如：

从语言的观点来看,文件可以被做进这门语言作为一种数据类型,当然也可以是C语言这样的open()出来的一个指针. C++版本有个Iostream(Cin,Cout就在里面,实际上C++的IO库很大,是一个复杂的基于对象的模板系统),C也有它的Stdio.h(有InputChar()和Printf()等这样的函数),这是C语言的标准(库)独立于所有的硬件和软件环境,是语言本身的因素,,,一门语言的IO机制是很重要的,比如,JAVA的I/O封装得很完善,,它细分成了多个OO表达的＂流(不必一次性读入内存的流，想象一下可用水龙头控制的水流)＂,极大地方便了程序员.

>I/O绝非仅仅输入输出这四个字这么简单,首先这是一种语言机制(就跟语言提供异常处理,这样的语言机制的地位一样重要),是关于这种语言对向它输入和由它输出的所有抽象的全部集合,它涉及到一门语言如何处理与系统的交互,如果将用户输入转成该语言写成的程序所用,,如何看待OS＂文件＂的概念．并发展出一系统概念,如input steam,file steam,等等 在PC的架构中,语言是高于OS内核的(一般在一个系统的架构中,开发层是高于内核层的),Windows是用C写的,C有它的I/O,是先于Windows的,一门语言并没有具体的数据类型,,比如unsigh,sign这样的区别是来源,起决定作用的还是硬件(这就是C语言平台相关性的由来),,C语言只是对它们提供了一些名称指代,,比如int在有些机子上是32位在有些机子上是16位,这对考虑一种程序的可移殖性是十分重要的.

在C的眼光中,一些输入输出都是某种流,语言接受用户输入,或者程序进行输出,先以内存作为根据地进行缓种,,缓冲分为二种,一种是缓冲文件系统(这是C标准的文件系统,,即不是一次性输入用户数据到程序中,而是输入一次缓冲一次,因此不刷新Flush就看不到最新结果),另一种是非缓冲文件系统(每次输入就完成一次绝对的i/o),这是,C把显示器,打引机像成标准输出,把用户输入键盘,想象成标准输入,,并把它们看成＂标准输入出流＂,,,把OS的文件想象成filesteam.


------------- C的组件技术


可重位代码，动态链接库

*/

*/

[^5]: 什么称为逻辑堆栈呢?因为下面是承载上面的.只有下面完成了,上面就有可能被完成

[^6]: 无论是在这个基础上再开发(扩展),还是直接产出产品,都是属于对接口的应用.

[^7]: 周爱民说,一切软件源于需求,我想他的真正意思在于:设计跟编程,谁是源头谁是支干的关系.这种顺序绝不可被颠倒.因为只有良好设计过的东西,在编程和维护时才能得到更好地实施.这是放在编程之外都皆准的道理.
