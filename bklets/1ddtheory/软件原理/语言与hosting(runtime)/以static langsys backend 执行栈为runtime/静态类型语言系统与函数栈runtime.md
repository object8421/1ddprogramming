====前端主定义规范与识别====

编译原理指的不只是编译过程，和运行时过程，而且是具体语言相关的部分，比如具体语法如何被编译(
a lang implent is made of a tree of ast formed forest)，如何针对一套具体的语法语义提供运行时过程，这些具体语言语法语义相关的部分

业界对于编译器的定义中其实少了一个方面,**编译器不仅是作为翻译工具的意义存在的,而且更重要的是形成某种语言规范,这才是编译器这个定义的主体**. 

这首先是各种类型的语义实现。各种语句的语义实现。变量的作用域等

语言的类型系统
=============

计算机发展到后来，它不光是数字，文字信息处理器，而是通用信息处理器（因为它的处理速度和存储水平都极大地提高了）。而且它还有作为记录计算机语言的高级语言设施 - 编译器；而且，OS软件平台和上面各种应用提供了大量抽象，这使得它具备可以表达各种抽象的条件。

如序言如说要分清编程科学和编程艺术，数据类型与图灵类型处理（运行时支持内置类型），是编程科学，是高级语言对计算机的科学，，数据结构则是封装艺术属编程艺术。
内置类型in a langsys,本身就是一种数据结构。

那么，该如何表达更高的抽象呢？这样使得计算机和语言设施都可以表达并且也可以处理。这就是语言要解决的问题。

###### 类型中的抽象

高级语言使用类型来解决如上的抽象问题。并将它集成在编译器内。

高级语言必须在高级编程层面[1. 对编程层面的理解参见前面有关章节]提供比机器简单数据更复杂的数据和信息表示,因为现在已经是高级语言+高级平台了,高级语言如何解决这个问题必须要站在高级语言层面和新平台问题的做法和要求来进行(比如,利用语法语义的方式,而不是不具有语法属性的定义数据的原始汇编指令.
###### 类型中的高级东西
汇编语言的程序元素只有二种,即栈式指令和栈式数据.它们代表机器执行平台上“能做什么”和“怎么去做”这二方面，在“类型中的抽象”只完成了对应于会编语言的“能做什么”，而高级语言必须要实现所有这些(抽象和设计并不是没有根据的无端设计，它们的背后是问题和应用)，这一切依然要在语法级借助编译器实现。

>这就跟内存和CPU之于冯氏机一样(冯氏机借助内存和CPU来运行栈式内容，语言编译器首先要做的就是将执行平台上的数据和代码转为语言级的元素然后再运行它)。

还比如,高级语言要在程序中提供语言要素表达数据,而且要以一致的方式[2. 一致的方式和高级的方式,比如,仅需要在程序中声明,就可以产生一个数据,编译器负责从“关于这个数据所属的类型逻辑”着手,来保证对这个数据的定义的正确性和有效性.]来生成简单数据与抽象数据,编译器数据和用户数据,甚至代码也可以跟数据共用一套表达形式,这就把数据表达的问题把代码表达的问题综合起来了).

这样的做法就是编译器类型[3. 源于BCPL这样的雏形高级语言实践]机制.这种类型机制的引入,就为语言引入了一整套其它机制.
编译前端解决了如何分析的问题，编译后端则负责实际运行在语法的基础上构建的这些语义及语言要素(这就是编译器后端为语言在一种平台上执行提供的runtime),这形成了各种各样的语言级的代码结构抽象和数据抽象,分为语法要素和语义要素.

类型和语句就是最基本的语法因素。类型与语句，是语言编程时的二大基本主体和编译器设计时面向的二大目的，其中，类型解决“能用语言来做什么”，------ 从编译器开始，出现了语言语法级的类型，变量，而语句（它们是一类运算系统，不一定就是语句）“解决语言怎么表达，怎么串联类型”(或者进行更更高级的类型抽象和语言语法级抽象)，----- 从编译器开始，出现了语言语法级的语句，表达式。函数。

而那些语义，活用的习惯用法，就是语言文化，也是语言的一部分。
高级语言层面的数据从此(在编程层面)可以是更为复杂的数据,一切的一切,仅赖于编译器能够识别它(前端在语法语义上认识它,后端为它分配到内存 - 和分解为指令- 能实际实现它),它作为这种抽象意义的数据就是有效的(因为语言是作为描述计算机的算法的,语言能描述的东西,计算机一定能处理,编程层面的类型是受算法支持的,图灵成立的,所以,这样语言的数据就是计算机的数据了,这些数据,在编译器层面是用类型实现的).

>这揭示了前端与后端的区别与联系,前面主定义,后端主实现.语言的类型可以是抽象了的类型.因此,只要编译器支持,那么这些在编程层面用类型表达的抽象概念,就是成立的,这就是把编程上升到一种对于类型的设计境界上.
其实字符串逻辑,数据结构逻辑都可以完全不直接跟内存挂钩(c语言才需要那么做呢,比如用模板实现的数组和C实现的数组,模板可以完全不用指针的方式),语言都可以站在一个比较高的角度来抽象(像C++,JAVA,Python这样的语言都在库上抽象了各种数据结构为种种高级的概念,它假设复用者知道这层抽象,于是不用实现数据结构重造轮子,只是能直接拿来用就可以了),甚至如果可以,一门语言可以把字符串抽象为Rope(当然还可以是其它东西),因为语法级是设计抽象,可以不跟运行期有任何关系(但是像子过程,闭包,线程,这些都是基于执行期逻辑产生出来的),,编译期后端才负责运行的事,才有运行效益和能不能实现的说法,所以语法级,也就是设计期可以站在一个完全脱离运行逻辑的抽象高度上进行对字符串的抽象,因为语法是C++,Java这样的高级语言支持的那些写法和映射能力,它只负责这方面的高级逻辑的事,而编译前端跟后端是可以分开的,只有到编译后端时才需要做映射到汇编语言这样的机器逻辑.
而C不一样,C用底层来表达语法级的设计抽象,,比如它将字符串看待是指针数组,这就是C语言跟其它所有第四代语言不一样的地方,,因此它产生的运行期抽象跟语言级抽象最接近,虽然是运行抽象但几乎等同设计,因此可用在内存有限的地方,因为它抽象小,比如手机等特殊平台上,但即使是这样,C的抽象能力也是巨大的,它可以抽象OOP,抽象结构,抽象Windows,抽象...

所有这些决不是简单的升级，而是本质的变更，对于汇编语言,代码的本质是指令(调用数据也是一个指令,我们可以把数据独立出来认识),对于高级语言,代码的本质是语法的形式(比如一个语句,一个代码块),而且对于数据,它也发展到“用类型组织代码,而类型本身也表示一个逻辑”,

所以,对于代码的本质,汇编跟高级语言是根本不可同日而言的.二者基于的本质不一样.虽然高级语言最终要被反汇编到某些汇编代码对应的东西,但二者根本不是一一对应的,绝不能拿一者当成一者的等价形式相提并论[4. 工程与反工程,它们之间的抽象沟壑太大,不是同一个层次的].

高级语言引进类型机制,其意义是重大的,一方面,它丰富了计算机作为数据处理器的内容,没有高级语言之前的机器直接抽象了现实生活中的简单数据,比如数值,字符,这使得计算机可直接用来作科学运算[5. 数值型是计算机从CPU级能直接提供的类型type,因此可直接拿来使用]. 而现在，计算机不仅能抽象数值,还能处理人类想象出来并能通过计算机表达的其它抽象[6. **除了那些系统编程的功能性编程,编程还包括应用编程和逻辑编程.**].

>所以,编程是除了写作,说话之外,另一种将人类思想接上其它东西的手段.说它是艺术并不过份.而且一点也不。

所以在计算机开发领域,对类型的抽象是必要的.这就是数据抽象解决的问题,它为数据结构提供了可能,**而数据抽象和数据结构是计算机用数据化模式来抽象它能抽象的问题的方法**.





变量
-------------


编译器提供了类型，于是在语言级我们就可以由类型定义出我们所需要的数据 - 变量了。

变量，使用变量的方式，几乎决定了对几种语言的区分，纯粹函数式语言(不是指那些建立在传统OO上的函数语言)对待变量与类型，是与传统的冯氏语言不一样的。 对于变量的使用,存在使用变量的引用和使用变量的值的二种不同方式,由此变量也分为二种.引用类型与值类型的不同,,导致了二派语言的产生,一派是C,C++,这样的使用变量的值模型的语言(就连指针变量,也是用它的值来表示它作为一个指针变量本身的意义),一种是JAVA这种使用变量的引用类型的语言.

>变量是表值,还是表一个地址呢?不同的语言都会有不同的做法 Java使用变量的引用模型,而C采用变量的值模型,这也就是说,就其意义来说,Java中的任何变量都是一个作为对某内存起引用作用而存在的变量,其内容,在意义上是个对某内存的引用.而C中的变量,其内容是个值(这就是说,虽然Java,c中的变量性质相同,都是变量,但其内所存储的内容的性质不一样),能最大程度表明这二者区别的例子就是指针变量,在Java中,一切变量都是指针变量(更正规的说法是引用),而在C中,只有指针变量才在意义上表一个引用(它只是一个名字,着重指这个名字本身代表着一种引用,而不着重指名字背后引用着的对象或值),而它是一种变量不是一个值,值不能代表变量的全部,但这种变量的值,是个引用而已.故C的变量,其实,是在用变量里的值去表达引用.而不是用作为变量的整个意义本身去表引用,这就是Java和C中变量的本质不同.比如复合变量,容器类型和递归类型

这样做的意义在哪里呢?
Java中一切容器复合对象都是引用,引用即地址引用,操作对象只要操作对它们的引用就可以影响对象本身,因为引用本来就是对象本身存储在内存中的物理表示嘛 地址是变动的,因为一块内存在不同时刻可以存储程序中用到的各种数据,因此称这些数据为变量,数据的本质是类,构造函数就是实际为某种数据分配内存的过程, 在程序中我们常常需要作数据的移动,复制,比如函数的形实演绎 实际上,我们根本不需要操作数据本身(在面向对象的范畴里,类对象就是唯一的数据,比类的成员更能代表数据),因为往往有时候这样的代价太大了,传值的方式就是直接复制一份原来对象的新的对象(需要给产生这个对象的类一个复制的构造函数),这样就会产生一个临时的复制体,现代的应用中,一个应用中有成千上万个对象是很常见的(因为往往是用某种大型库写的),,给系统巨大的时空开销负担,而且很不安全,在没有提供垃圾收集的语言中,涉及到二次删除的问题 而引用方式就不需要作频繁的复制,因为从抽象上来讲,,引用的确可以代表对象本身(因为对象是程序的,而引用是计算机的,引用本质上就是对象嘛),

>这导致的一个结果是,当我们用逻辑操作符比较二个相同的对象时(一个对象和它的复制体),返回的结果居然是False,这是因为实际比较的是它们的引用,,,由于第二个比较对象是原对象的复制体,因此它的地址即引用是与原来的对象不同的,因此比较结果会是假!!


>类型跟变量的区别不要混淆.. 类型是类型,是编译器的概念.编译型语言将这种机制过继给程序员.而变量是数据,是程序员利用数据化模式进行编程的方式,而Python这类脚本语言提倡类型即值, 程序员不需要利用一门语言的类型来进行设计[7. 它有专门的class as object],虽然类型都是变量产生出来的地方,,但变量才是程序的概念,Python这样的语言认为:一般程序员只需要值. 诚如指称语义所表明的,广义的类型是程序员用来操作内存的规则,比如定义一个变量,类型和变量,类和对象,本来就应是相对而论的东西,从编译器的角度来看,对象就是类,类就是对象,都是某种编译器数据(类型),只是人们(程序员)看它的角度不一样,语言要求他们把其中一些当一些的产生模式.比如,Python中,类型object可以是一个无任何后继行为(继承扩展)的对象object,它可当类型也可当对象用.就像C语言从int typedef新类型一样.从struct产生新类型一样. 即类型机制本来就是一种强大的编译型语言通用的设计手段 你可以简单地把类型理解为变量的模板.

###### 作用域
作用域是书写式的传统编程语言固有的特点 实际上,作用域这个概念远远早于名字空间,最初的语言有作用域的概念,但只有特定的一些后来的语言才有名字空间的概念,所以,对名字,及它们的作用域,作用域规则,的一切讨论(包括它们如何导致一个运行期关于某语句的引用环境),都可以不借助名字空间这个概念. 符号表是一个编译系统最重要的数据结构之一，字面量是从词法分析器的眼光来看的，给除关键字，标记符之外的其它单词，如数字，文字等，取的名字

作用域有名字所在某个区域的作用意义，也有这个区域所在它的父区域的作用意义 即,我们可以独立名字空间来讨论作用域

引用环境是活动的,表示一个活动执行的情况

名字空间,指明了这个空间(稍后我们会知道这是一个不确定的动态的概念,名字空间跟作用域一样,都有一个范围的意思)有什么名字,是对名字所在空间的一种逻辑,, 而名字,其实就是约束本身,每一个名字都代表一种约束(这个约束是指约束的发生,即名字与它的所指物在某个名字空间里进行动态绑定与消绑), 当然,约束的起作用(在某一代码正文无域)都是有上下文环境的(而且在一个相同的上下文环境中可以有相同的约束,只是会发生某种规则用一方去屏蔽另一方而已),,所以,约束,约束的发生跟约束的起作用是三个不同概念(前二个概念一样,都是指名字所代表的约束的发生,这二个概念与后一个概念并无联系,约束在某个作用域内不起作用,是指,被屏蔽或其它什么原因,不是指这个名字再不再存在,所代表的约束被取消了,或名字无效了 C 其实都有效,只是根据一定规则一方会屏蔽一方而已),某一具体约束的某一次起作用(作用域是名字相关的,即谈到作用域就要谈到,是关于哪个名字的作用域,而名字空间不是,一个名字空间里有很多名字并不是某个特定名字相关的), 那么这二者的联系是什么呢?

>然而,作用域也不是就不是一种名字空间,是另一种意义上的名字空间,是一种特指的名字空间. 比如,名字空间中的某个名字的约束情况,一定跟它的作用域属性(它有没有被屏蔽)有关,这个名字的作用域就影响了这个名字空间. 都代表着一个作用域的存在,(某一具体约束产生和起不起作用总发生在某一作用域内), 而所以名字空间跟作用域不是一一对应的,这就是说,),每一个名空空间,都代表一个活动上的执行环境,即名字空间.(名字空间可以在作用域所代表的源码正文区,导入或增删名字.

总结: 名字空间和作用域,都指代某种范围,这二个范围中,都存在名字.只是这个范围对名字的约束发生和约束起作用的所指不同,并对是指代名字本身,还是指代这个范围本身有所侧重. 详细来说,作用域是针对某个名字来说的,作用域是关于(某个具体)名字(更确切地说是名字的约束起作用,注意这里是某个)在源程序级的概念(这个概念指代一个静态的词法属性,代码行组成的正文区,是一个范围), 名字空间针对大运行期(某个逻辑上的空间单位)来说的,它关乎这个空间中的名字(泛义的,它并不指代某个具体的名字所代表的约束的发生)在执行环境级的某个空间动态被导入或增删 C 即名字所代表的约束的发生跟消失,的情况)这个空间被称为一个名字空间,这个所谓的“所在的那个空间”就是名字空间的概念所指.

在处理过程的作用域问题上,最小内欠LGB做得很好[8. 用低一级过程内的同名名字屏蔽外层的那个名字是故意的.],然而,最最例外的情况是欠套函数.闭包,就是用来解决这个问题的体现(借助更强大的最小内欠的直接外围原则LGEB). 除了实现诸如欠套函数那样的东西,闭包还可以解决什么问题,由函数和函数调用表达的过程式语言借助作用域的有关概念(最内原则)在处理名字以提供信息隐藏和模块化的过程中做得很好,,然而子程序存在它本身就有的局限,闭包,就是这种随着由针对子程序的局限解决之法的产生而产生的. 一般情况下,在普通的过程式的语言中,一个子程序是不能单独立成为一个可复用单位或模块 C 比如一个类,的(因为它没有保存数据的地方,子程序中的局部数据存在于代码区不能被修改,因此只能用静态变量的方式,而且,不光堆上的局数据不能被保存,栈上的参数也不可被保存),闭包就保证了,在子程序产生的每个实例中(假设它被作为一个可复用单位被实例化),这个变量是互不干扰的,就像类一样(显然,闭包解决的是作用域问题) 怎么样把一个子程序(如上所说,它的参数,返回值,临时变量都是环境依赖的)抽象成为一个“复用单元”呢(比如它要像类一样,作为一种可被派生的数据或数据模块,是一种可被实例化的复用单位)?通过闭包就可以,即,这时的子程序不再仅作为一块仅发挥处理器作用的代码(从要把它弄成一个模块的有效性角度看,它的缺点是没有数据,而我们知道,一个可复用模块必须同时要有代码和可隽带的数据才有意义),它其中的数据是种独立实体.这种子程序,即“单子程序”构成的模块,它必须要在被调用时,产生某个可供保存的结果.这就是闭包和模块. 有时,对闭包有这样的定义:如果说类是有过程的数据,那么闭包就是有数据的过程. 闭包,欠套函数,单子程序,这些概念之间产生的关系是怎么样的呢? 产生闭包.产生欠套函数,,闭包表达的子程序,可以成为一个复用单元,即单子程序
作用域是语义的,而非语法的.因为我们可以写一个合法的,但在运行期会出现动态错语的程序,比如,变量超出了它的作用域,此时,它就出动态的语义错误. 作用域就是程序元素(变量名字啊,函数例程啊,单行语句啊)起作用(存在某种存储中,或与某个值发生约束)的范围(静态源程序中,或动态某个上下文中),所以,作用域是包括存储的(临时的,还是静态的),因为作用这个词是相对程序的,而存储是相对内存来说的. 我们来具体看下py中的作用域 作用域是怎么样被定义的呢?作用域是一种描述性的概念,从来没有真正的作用域所指的那个真正的东西存在.(我们可以粗略地把它当成一种代码正文区块,但实际上这个所指是不存在的,因为正文区域不代表任何形式上的东西,不是某种高级语言的语义,也不是汇编的执行上下文,因此无法对它形式而论) 让我们先来规范一个说法,名字与它的所指对象在某个作用域里存在约束.即,具体的约束在具体的作用域发生. 非形式来讲,名字空间揭示了一个名字或约束在不同的名字空间里存在不同意义的机会,这是名字空间的具体作用.对作用域的描述性概念是用它的作用来表示的,代表一个名字,或一个约束,对于他们所指的对象或值,在它们所属的的名字空间存在有不同意义的机会. 我们说名字的作用域,其完整的说法应是,这个名字与某个它所指对象发生的那个约束所处的作用域.而对于同一个名字,在相邻的作用域(比如嵌套结构里),可能会产生不同的约束导致这些“约束对应于不同的作用域”的说法. 作用域可以粗略看成代码上下文区块,约束的上下文不是语义因为它是一种伪概念,而约束是一种形式上存在的语义(Python vm中用pydictobject来表示,而对于作用域,是没有明显表示的). 让我们从开始讨论Python的模块开始来讨论这种作用域 在py中,模块module是一种类型,而不仅仅是模块是一种程序元素的逻辑管理器.一个模块对应一个动态的pyc文件,第一次编译时会产生这个pyc文件,在以后动态执行这个pyc里面的指令后,会形成新的pyc文件. pyc文件是动态的,它的内容是变动的,里面存储的pycodeobject的序列化,它是变动的,当pycodeobject(它是一个用C表达的大数据结构)里面的某些字段,比如,最重要的指令发生了变化,那么pyc文件就会产生新的内容

py中,一个名字空间对应一个作用域,难道名字空间就是专指名字的作用域,名字空间在py中是用pydictobject表示的一串串名字与值之间的动态约束

pyframeobject是执行层面上的基于指令选择的活动对象 而pycodeboject是语法层面的基于语法的活动对象,对这二个东西完成了定义,那么基本上约束了编译前端与编译后端的全部

built=in是一个名字空间（LGB中的B就是指builtin）

模块化程序设计用模块,一个模块并不总是一个编译单位,来组织源码的逻辑单位,而不是编译级的物理单位,而以前的C是这么做的.py中的程序,无论是逻辑的,还是编译物理的,都是用模块来组织的.而模块,也关系着名字空间的组织方便性

名字就是符号,词法的名字,语法的名字,,,符号是语义的名字 动态语言比静态语言更强烈依赖名字,因为名字是运态语言在运行期唯一能找到的东西.(pycodeobject运行期只保留这个信息,查看pycodeobject中的names就可以发现)

约束经常在赋值语句,具有赋值行为,或以赋值作用为基础的一类语句中存在并产生

在module对象中,维护着一个名字空间,而约束就存在这个名字空间中

一个module,定义了一个名字空间,要引用处在另外的module中的名字,像引用属性一样引用object.x. 因为名字是作为module对象的属性的,这就相当于class中对对象的实例的属性引用.后者在py中也是用pydictobject来表达的
在一个module内部,又有多个名字空间,而一个module本身,对外就表示一个名字空间,其内部和外部的名字是分二套不同的机制被对待,以决定对这些名字的作用哉进行讨论的

一个约束起用用的正文区域称为这个约束的作用域,而一个作用域是指一个程序正文区域, 在这个区域,可能有多个约束在起作用.这里的区域是约束可能产生的代码区块,作用可理解为“在某个代码区块,约束运作使名字处在哪个名字空间,以决定对他们的讨论,比如怎么样求值,引用方式,即由约束的作用域得到名字的名字空间逻辑的一种过程”,而从来就没有真正正确的名字的作用域的说法.也即: 约束语义,作用域名字,名字的名字空间

作用域是代码正文,是物理的,而非语义,约束才是语义(py用pydictobject来表达这种语义),是逻辑的,求作用域的过程,是由语义开始的,而约束也必定发生在某作用域,因为约束只会发生在某个代码区块中,我们最终得出的是名字的名字空间.名字空间也是语义.
###### 类型的转换
[code lang="c"]
GameObject&amp;amp; rgo = *pa; // rgo 的静态型别是GameObject,动态型别是Asteroid.
[/code]
为什么说动态呢,因为=赋值时就经过了一个隐式的转换 dymic cast就是对动态型别的转换 注意此时rgo就是gameobject类型,,而不是asteroid类型,,也即,,一个变量的类型永远是它的静态类型而非动态类型 这是什么呢?rgo被声明为一个指向GameObject的引用(引用就是引用,,而非指针,引用就代表对象本身,取地址操作符不是引用,这二个东东根本不一样,虽然可以通过对一个对象取地址就可以将它变为指针),,但其实它就是一个对象______即rgo是一个GameObj对象,因此说rgo的静态型别是gameobj point to someobj跟ref to someobj是不一样的 编译期断言. 断言首先是一种逻辑(借用了逻辑式语言的机制)．然后才是一种编译器技术和后来你用这门语言来进行编程所涉及到的编程机制．



语言的运算符系统
=============






语句与过程
-------------

表达式与语句的区别:一门语言有它的内置类型和UDT类型,一般UDT扩展内置类型,语句就是所有类型共享的,,而表达式仅是关于内置类型的语义,如果某个UDT扩展自某个内置类型,它才能运用这个类型有关的表达式的语义,而其它的UDT不能,但可以运用py编译器的那些技术,模拟内置类型的表达式语义.这就是方法当成表达式的意思.比如py中的富比较,C++中的构造,析构式语义.

能够计算出值的语句就是表达式，可以用这条规则分别出何为语句何为表达式，比如一条赋值操作是赋值表达式还是赋值语句

由于cpu的速度足够快，虽然它仅能完成有限的表达式，但在语言级呈现出来的语句效果足可以完成任何逻辑，语句是高级语言的基本单位，表达式是一类特殊的语句(从编译器处理表达式的角度来看，它的确是将表达式看成一种特殊的语句形式来处理的)，因为要考虑它的优先级。在整个由系统到语言的架构中，表达式是基础语句是上层，在语言架构级，表达式是语句的上层（是一种特别的语句）

语句是程序的基本元素,我们是利用编译器所能表达的概念 C 即运行时类型系统和表达式语义系统,和“编译器能提供的语句”来表达这种语言能表达的软件的.

类型机制使我们以人的眼光来使用内存,当然,这仅仅是类型指称语义所达到的第一个目的,对于计算机系统的目的,它对于人的目的就在于:类型作为数据产生的模式,使我们可以以预定义类型的方式,来抽象使用内存并从人的抽象角度来表达数据所附着的编码逻辑(而且,一种语言的编译器实现中,在编译器的运行时级已内置了它能直接供程序员使用的类型[1. 如果说机器语言利用0,1编程,那么它实际上仅能识别这二种逻辑,而拥有类型的高级语言,能直接识别first class 的编译器内置类型逻辑.],而且在库级也存在很多类型逻辑可供程序员使用).

那么表达式呢,自然,表达式是建立在类型语法和类型语义之上的,它使我们能让作数学计算的方式来写程序.

C语句之赋值
-------------

赋值跟变量的使用模式有关.比如它是引用类型的,还是值类型的 形如以下的一个表达式

[code lang="c"]
char *p = &amp;amp;somechar;
[/code]

我们知道p是指向字符的指针变量,作为一个变量,它的内容为somechar的地址,它的指向对象为somechar,然而,p不是不可以指向其它的字符,比如我们p=&amp;anotherchar;这同样成立. 我们说,在赋值表达式char *p=&amp;somechar;中,等号右边的&amp;somechar是一个右值,等号左边的p是左值； 也可这样说,对于char *p=&amp;somechar;显然等号左边也为一个表达式,在这个表达式中,p是左值,而*p是右值. 左值与右值的概念与区别最初来源于编译原理,大致是指表达式两边的左右值是有严格区别的,分左右的. 在C中,左值就是可以改变其值(被赋值)的一方,所以要求赋值表达式的左边是一个"变量"(不管右值是什么,左值接受右值的内容,此例中为&amp;somechar,是一个value,然而语义上可以看作为指针)； 而右值可以是变量,也可以是常量,或者临时值.(不管怎么样,它有值提供给左值就行) 归纳起来就是,右值把它的“值”(是个值或地址值)赋给左值所指的“地址”(必须是个有地址的量,比如不能对常量赋值)

>Todo:这段移走 左值与右值的概念就来源于此,考虑以下一个式子,int a= int b,,, 把数据b的值赋给a的地址所指的一个空间,datatype的值部分就称为datatype的左值,,,datatype的地址部分就称为datatype的右值

所以在C中,左值一般指能变动其内容的,有地址的变量,而右值就是有值,可变动或不变,但不一定要求其有地址的量. 但不能单纯的其值变动或不变动来判断,比如char *p = &amp;somechar;的表达式中,显然地,p和*p都不固定可以变动其内容. 所以判断的唯一依据是:赋值中,是哪方把哪方的值赋给了哪方地址所在的空间. 在C++中这两个概念经过了改动.因为C++引入了引用这个东西,还有引用到常量. 形如int&amp; max(int a,int b)的函数表达式中,max因为本质上是一个返回int的函数引用“类型”, 函数引用也是一种“语言类型”,而且它有一个地址(函数都有地址),而且这里还有&amp;,所以它是一个左值. 引用的in-place 而形如int* max(int a,int b)的函数表达式中,max因为本质上是一个返回int的函数指针“类型”, 函数指针类型也是一种“语言类型”,而且max必有一个地址,但它表明的是一个函数值,所以它是一个右值. 试归纳之,具名(显式给出了其名字)对象就是左值,不具名对象就是右值. 所以,对于C和C++来说,总的判断步骤可以如下进行: 1,分解认识出表达式(左,右,或整个表达式)内含的“量”的类型； 2,因为任何类型都是语言的类型,所以可能有地址,有值. 具名且有地址的就可以是左值,不具名而且有值的就可以是右值.

高级语言中的流程控制
-------------



其实循环,跳转这些东西来自于汇编语言,,,高级语言接纳了这些理念(因为汇编语言几乎就是机器逻辑,高级语言提供类汇编语言这样的机制是为了符合平台逻辑,,,况且高级语言最终要编译成汇编语言和平台逻辑,,循环语言要最终被还原成汇编语言的形式,这些处理速度就可大大加快),,,发展出了它们关于循环,跳转封装了的语言机制.. 对语言机制的理解,应该始于编译后端,再终于其语法对应的语义.为什么控制结构如此重要呢,因为它代表语法和语义方面的要求.比如布尔条件式,语义允许短路的语言会直接编译出条件判断后的结果..有时如果语法语义允许,语法上布尔运算也可等同算术运算..因为布尔结果用数值可表示..C语言就是这样 C语言字符串有大量指针这说明了与C++的抽象字符串不一样,说明C是用底层来描述问题和设计的. 这些说明,要更好地了解一门语言,,最好要上升到他的语法规范.联系编译原理知识来了一解一些东西.以及编译实现时是如何满足这些规范的. for的条件表达式可能短路(可以借由它的这种能力实现一定程序上的延迟求值),即你可以用跳转的方式来解读短路变相了的for表达式,它的update部分可以是任何算式,甚至不要updata部分 一般把最常发生case的情况放在最后面,如果你学过汇编就知道,编译器是从后到前搜索的 注意汇编是没有逻辑运算符的,只有移位运算符(而往往C++中把它们同用) 有三种,,逻辑(与,或,异或,取反),移位(无符号左移,,右移,,高位补0等等), 在汇编中 contine和break的区别,contiune放在循环语句的某一具体层中,当满足条件时,继续执行下一个当前循环(即重新判断条件),而break可以放在一个循环的任何地方,是跳出当前循环(注意因为循环可能是嵌套的,所以这个当前循环是指break所在的那一个嵌套层次),,然后继续执行这个循环外的第一条语句(即结束循环). C语言中的信号是什么东西呢,, 是一种高级的跳转机制,语言的流程控制结构,进程通信手段. 高级语言在封装机器汇编逻辑上损失了一定的灵活性(因为只有汇编才是与机器逻辑一一对应的) 而高级语言的流程控制,分支逻辑等,,终归是某种抽象品,,只能提供有限的If Else形式,这些封装了的高级语言关于流程的逻辑(其实判断,循环都是流程控制逻辑) 这就是封装,抽象,与原来可获得到底层灵活性的矛盾所在 第一个if往往是最基本的条件逻辑,else是一种变相的if逻辑,是针对于已提出的if的反面,,是if正好相反的条件,而其它的if,在一个if存在的条件下,,相当于else if 一定要明白这里的区别,,这些语言逻辑产生的对应的汇编码的绝对性决定我们得明白这些细微的差别 理解这一类汇编逻辑时,我们得理解intel平台的逻辑,条件指令逻辑,,和分支逻辑这二大部分典型的有,高级语言的条件逻辑转化为汇编逻辑时是它的倒装形式,而且else部分是放在所有分支逻辑前面的. 明白这些,将有助我们理解高级语言汇编出来的逻辑,从而更好明白高级语言的这些关于流程的语言机制










 

====后端主计算实现====

后端,语言层的执行:运行时类型系统与内存模型
-------------

既然操作系统提供了执行时,那么它只解决了进程的问题.它不可能负责为语言产生的程序分配内存的事,它只负责执行一个个业已生成好的exe文件,而不管这种exe在被产生的过程中是从哪里获得内存以及获得多少的问题,那不应该是操作系统管的事,因为这是生成一个exe的事,而不是运行一个exe的事[15. 在这个exe被生成前,操作系统甚至不知道这个exe是否正确的可不可以运行,编译器后端,就是解决“OS运行该语言程序”的实现,是语言实现与OS之间的接口.比如c的main()向操作系统传参数.],操作系统只提供开发可用的内存资源,编译器生成程序在前OS运行程序在后,所以理应由编译器指定如何为程序分配内存的规则,然后这个得到内存的程序才能进入某个OS进程被执行(是一种前后相承过程,不可混淆).

>将内存资源分配给一个应用程序所有,而且做到高效,是开发一个服务器性质的程序经常用到的手法,比如web服务器,数据库服务器技术中经常使用到的内存池技术(而且,这在OS core中也用到),这形成了系统编程的一支,是应用程序处理它自身模型的手段(获取内存),就跟一个应用程序处理它关于界面的自身模型一样(系统编程中的GUI).
注意,当我们谈到系统编程时,我们指C,而不是C++,上面谈到的“系统编程中的GUI”中的“系统编程”一词并不准确.因为QT,GDI一般用C++开发,C++是基于C“系统(实现)编程”基础上的“系统(应用)开发”,,而只有实现编程才能更配称为是系统编程.


从发展高级语言和制造编译器开始,程序的执行就有一部分被下放到编译器了(编译器是作为系统软件的,其本质是针对某种语言的系统实现层),这就是运行时.在汇编程序设计中,程序是直接进入执行路径的,因为程序员包揽了这里面所有的内存分配操作,因为没有变量,他们的工作直接涉及到为每一个程序里的数据作内存分配,那时没有OS,程序的一切都需要手动分配[16. 这种分配涉及到最直接的低层机器,不光是内存分配,还包括指定flat,nake等等],稍后出现了OS,在基于OS的汇编编程中,内存不能从机器中直接获得,因为那是系统资源,只能通过system call去获取(比如C语言库函数中的某个封装形式).而在高级语言中,完成这个工作的是编译器,程序员要直接接确到的只是变量,这种对内存操作(基于高级语言开发)进行了抽象的手段.

为程序的产生和运行分配内存(注意这里提到了产生和运行),那是编译器要管的事(比如对于C系语言,都是建立在C的内存模型接口malloc,free上的),这是一个什么过程呢? 编译前端负责一直到中间代码生成的所有动作,至此,实际上编译器已经差不多完成了.但是还差一个内容,就是代码运行环境问题的解决,比如,它如何向OS获取内存等必须的运行时空资源,,还比如,它如何获取一些程序运行时所必须的其它高级库逻辑.编译后端的中心任务是给前端生成的中间代码提供一个运行环境,这导致了运行时的概念,当然,编译后端,除了给代码提供一个运行环境之外,还指代码优化之类.

运行时是不是移殖的产物?比如apache运行时,是一个抽取最核心的运行库,比如C库的运行时,等

编程语言中为什么要提供编译器自带的运行时呢.这二者之间的界限要分开.前者解决任务和进程问题,后者解决具体的内存来源问题.当编程语言发展到虚拟机阶段,进一步模糊了这二者之间的界限.因为虚拟机既带进程运行程序的功能,作为一个类OS的执行系统,又是作为一个语言系统存在的,负责从OS获取并分配内存的工作(甚至GC这样的强化功能). 运行时,也可以理解为编译时用到的库,比如内置类型,需要独立出来所以形成一个运行时库,运行时中最重要的部件还是内存支持库,比如内存模型,运行时中的内存模型是为类型数据向执行系统的OS申请内存[17. 比如针对某一种内置类型type,编译器都会给它一个construct()或init()函数,可以说,内存模型是一种“后端对前端定义的具体类型提供支持逻辑的库”],支撑编译后端的必备(把变量映射为位和内存地址,内存模式即类型实现系统,使这种语言的类型得于在执行平台上存在的库)

>Run time (lib),本来对于一门语言来说是可以不要的,一门语言只有自身的一个实现就足够了,它可以在裸语言的基础上,发展逻辑,不需要什么运行库.但需要运行时.run time!=run time library
其它语言是没有crt的只有c有,因为C有标准编译器实现必须实现它,这个意义上run time是语言的库逻辑,run time是编译后端,是每种语言包括无标准库的语言都需要的,这个意义上它是系统软件是语言对于系统的接口是编译器后端一套完整编译器实现必须的,(我们知道解释器一般是系统软件,作为编译后端的意义的crt是相当于解释器对于一门语言的意义)


运行时其实不如叫做运行空,就是程序运行的物质环境,比如CPU架构(里面的寄存器,就是专门为通俗意义上-不只是一门语言的程序,,,的程序而设置的最终运行时,里面的部件全是程序专用的),,当然,运行时,也可以是虚拟机这些软件逻辑上的东西,,其实程序不可能纯粹以硬件作为运行环境(除非电器化的微指令,或者裸体指令,运行时不是纯粹指CPU构架,因为单纯一个CPU提出来,只有指令,并没有程序的概念,必须等OS机制,高级语言的汇编原理出来,然后程序机制出来,才发展出运行时这个说法),还是有OS逻辑来封装CPU硬件逻辑,然后为运行时所用. 所以,什么是运行时呢,就是,不跟具体编译前端有关的,跟具体平台有关的(虚拟机或本地)那些编译原理知识,给前端生成的中间代码在上述二平台中提供一个运行环境 如果给本地平台就是C,C++这样的运行时或解释器,如果是虚拟机,就是.net,Java那样的. 编译后端会对目标平台产生代码,这目标平台包括机器和OS,最主要还是OS,因为OS是封装了系统调用(BIOS中原子基本的几条IO功能接口,可供OS和系统进行以后的抽象)的,在语言看来,封装了的OS和语言的其它库一样,也是一种语言逻辑,有接口就可以调用(语言跟OS并非一种鸡生蛋生鸡的关系,往往是OS出来了,然后有一种特定运行于这种OS下的语言实现即编译器,tiny甚至可以自编译自身,但OS与语言的确存在不可分割的联系,这也是本书把OS分为《上》,《下》这二部分的道理即来源于此.),OS与语言并非鸡蛋谁先生的问题,关键是分清,语言实现和语言写出的程序的实现这二个概念之间的不同.这就是写新的操作系统之前,标准C库是用不上的一样的道理.当然C库是建立在OS上的. 那么如何在OS下运行这种语言写成的代码呢,它如何从OS中获得空间等运行资源,如何获得system call IO操作文件(比如c stdio中的文件操作实际是封装了system call io逻辑来的)呢,把运行时想象成语言后端逻辑(编译后端代码生成器及其生成的代码)跟OS的逻辑接口就行了.对于OS来讲,它解决的是OS如何运行它,对于代码来说.它解决的是如何从OS中获取资源进行运行,和提供main()这样的接口,,当然特定编译器商甚至也包括一些语言实现std lib dll,因为这毕竟算是开发完整一套编译器嘛..一般会把std lib dll当成crt,这是不对的和不完整的. 从解释器的角度我们来看一下,的确是这样的,解释器不为特定目标生成代码,它只负责运行语言源代码(虽然这其中会有一个中间代码,但解释器不运行目标代码[18. 以后我们谈到目标代码,就是指,比如为Win32生成代码],它的目标就是解释器自己,目标代码就是中间代码),,解释器就相当于机器和OS,它没有c runtime,,编译环境下的crt相当于额外的中间层.. 编译时是编译期的事情,运行时是运行期的事情,这里的时可以理解为期间(运行期间),也可理解为空间(运行逻辑关于使用reg还是stack的逻辑), 一门语言同时提供编译器,和这门语言实现的运行时解释器,一个编译逻辑,一个面向某平台的运行逻辑(针对本地机器的一般称为运行时,针对类JVM机器的一般称为解释器,所以jvm跟解释器是分开的,一个是平台,一个是平台下针对Java代码的runtime实现),

在学习C++的运行期动态OO对象时,我们也要学习一个称为rtti的东西,,一切高级的语言机制,都可在运行期探求它的平台实现细节,如何用stack内存和reg展开,..这样才是深克理解了高级语言该机制(因为了解了某一平台下具体实现的细节,而且是最细节的汇编逻辑,因此该语言抽象也被在高层次被体现并理解了).. runtime的意思在这里进一步明显,,实际上不只执行函数要用到stack runtime和stack frame,在执行诸如堆栈队列数组链表树这些高级数据表示与组织的内存逻辑时(即运行时逻辑,这也属于运行时逻辑),,不一定直接用到stack runtime机制,,虽然执行函数时的stack机制的是代表机器就是一种堆栈机运行时的典型.. 运行时,从字面上理解为代码运行的环境,无论它是机器套个OS执行引擎,,还是虚拟机这样的软件模拟的运行时,无论如何,代码要得于运行,必须需要内存和CPU指令,,JVM就是JAVA字节码的运行时(并不包括JIT,JAVA的编译器等部件,这些都不是执行字节码必须的,只是负责生成字节码的,而运行时是驱动目标代码运行的环境),C语言代码被编译后到WINTEL上执行时,Windows操作系统加编译器的runtime支持就是机器代码的运行时.. 再者比如.net的通用runtime,也是这个道理.

#函数与过程的计算原理，后端实现

------------- 函数


函数在不同的语言体系中表达出来不同的角色和意义，函数可以是冯氏过程式中的，这时，它是过程式语言中的代码结构；

函数也可以是lamaba演算中的lisp面向函数式的“类型”。此时，它是函数语言中的代码结构，或数据结构，这二者统称为类型。

但是函数并不是C语言的内部类型。但却是C语言内置的后端支持的代码结构。

###### 原型

函数有三个部分,,一原型,二类型,三,参数,对一个函数的把握要从以下几方面进行中

首先,原型部分(只有编译型语言才有原型的说法),各个编译器在编译并汇编相应语言的同一段代码时,会产生相同的反汇编序列(这就是progo原型,这成为在汇编逻辑中发现一个函数开头部分并借此发现这是一个函数逻辑的方法) 我们知道基本的原型有C的自右向左和pascal的自左向右方式(其中,由于C函数原型方式下,将执行权交由调用代码来完全,这使得被调用函数中可出现可变参数)

一个函数必定要用一种调用协议,就像Python要用C++的函数要经过一个叫swig的改造一样(再比如将Lua集成到C++的源程序中,必须向其宿主C++代码提供Lua-call方式,因为Lua的函数调用协议有它自己的一套方法和数据类型作为函数参数,每个虚拟机也都有它具体的入栈出栈方式),在一种语言所能支持的所有调用协议中,也有不同的协议,一般有stdcall,fastcall,pascal, stdcall主要是用于api,这个协议由子程序控制出入栈,参数由右向左入栈,fastcall用了ecx,edx寄存器以加快参数传送速度,因为寄存器的速度要高于最快的内存和外存,,,,类的成员方法不同于一般的api,类的成员方法这种call协议一般只用ecx作为它的一个隐含参数,即用ecx传this指针,this即自引用,考虑rose中对象交互的消息机制有自身向自身发消息的那种 比如C++类的成员函数,它实际上是一种变态的函数..从他的汇编逻辑中可以看出来,,在压参时还压入一个this指针.从这个眼光来看.跟普通的cdel,fast,pascal函数都不一样

vptr是一种变态函数,这说明OO从来都是建立在过程式之上的 如果你发现一个函数调用(类的构造函数),传递过去的this指针(指向该类, this只用来指类体在内存中的指代,而类的实例自有变量来指代.所以不用this这样的设施)居然是指向了栈中一个未被初始化的变量的化(作为this的ecx一般不被初始化),那么你基上可以确定这个函数是一个对象的构造函数,因为没有程序会在栈中放数据.rdata,特别是指针数据

**所以说,函数作为一种机制和设计,有不同的实作品.**

###### 过程

函数就是子过程的一种抽象说法。那么**subroutine究竟是什么呢?它是一种对执行路径中出现的代码结构的抽象.**

因为子程序放在不同的环境下有不同的本质,比如放在汇编里就是一套基于指令的例程,而放在高级语言里,子程序是语义定义的,有语义的属性.所以对于子程序的讨论自然要分别对待.
从字面上看,Routine是例程,例行程序和步骤,指一种在某行业某领域解决问题的基础举措与设施(并已成为某种例行的程序[1^]),在程序中,这就是子过程,子程序,那么这种程序中的子程序设施本质是一种什么样的东西呢?

子程序首先是一种设计,宏就是子过程中的一种。在汇编语言里,为了使程序员不致于写重复的代码,于是发展出宏,带参数的宏这样的设计手段,这些设计手段丰富了汇编语言本身. 而会编程序员了也可以工作在高于选择式的层面去编程了。

>注意,我们在这里谈到pure的汇编语言,是指那种80286之前的对裸机的编程,而不是某种“高级的汇编”,pure汇编语言有带参数的宏子程序,但却没有函数,它们是基于指令选择的,这跟高级语言中以函数和无参过程,是很不一样的.其实没有语法语义上的含义,所以对他们的讨论是要分别对等的,因为编译原理抽象的作用已经使它们在本质上发生了变化. 比如对“OS的汇编”(比如在保护模式下对OS的API的调用),汇编语言对高级语言机制只能是一种模拟.
高级语言产生的汇编码是与高级语言源程序不一一对应的.对高级语言子程序,流程的讨论存在语法语义上的含义,而不能拿简单的指令选择来说事.

函数机制往往被作为过程式语言的代码结构代表,但其实无论是C这种纯正的过程式语言,还是RUBY这种OO式语言,,与其说函数它是一种语言机制,倒不如说函数是一种接口,更多地来说是一种过程式非过程式语言通用的机制(一种泛意的函数,Python就深刻地体会了这点),

比如class里面其实也可以是过程式编程的函数调用,一种具体的构造逻辑的接口形式(一种单入口多出口,而且可被其它函数无限调用的接口,因为它是一种跟执行时的堆栈嵌套接近的动作,这也就是C语言采取的自顶向下的形式,而函数又是最接近计算机单路离散算法的逻辑(比如Lisp与Lisp机),,,所以实际上这种简单的形式可构造一切计算机逻辑(冯氏机虽然在计算模型上不跟Lisp机一样CPU就支持函数,但是冯氏下的语言可以做到以函数的方式抽象编程),就是这种机制,,决定了函数实际上可构造一切逻辑,包括被C++用来构造类机制,注意函数有一特点就是它的返回并不决定函数一定就结束),,虽然这些语言谈到的函数都不是一个意思(C的函数是通常意义上我们说的函数,语言直接支持的第一等公民,而RUBY的函数是另一种运行时支持下的函数变形,比如虚函数,成员函数,COM接口,RUBY并不提倡用函数为主体进行编程) 所谓程序,就是执行体中套中运行体,执行体就是子程序,例程,运行体,就是数据和以数据形式存在的代码,比如class类型,既是对数据的抽象,也是对代码的抽象,函数就是一种对子程序的抽象(它是运行体,并非指代子程序例程的执行体本身),所以,编程,就成了协调这二者之间的关系(不断地抽象它们).

**数据和代码才是冯氏程序的最小单元**，而不是函数。函数跟类一样，是基于数据和代码的封装形式，这在一门冯氏语言中随处可见。

也即,机器直接支持函数的执行,不过要程序提供不同函数的策略而已. 函数的不同原型和函数的不同表现正是子程序机制在不同的平台和语言的不同策略表现。


在机器级，可以说基元的元素只有二种，即栈式数据和栈式代码；在编译器级，它们是用大量的类型和表达式组成的，这二种元素在语言的语法级，又变成了变量和语句，语句结构，其它的高级语言元素(数组，指针等)，及由这些东西复合而成的一系列其它更高级概念，比如作用域等等。

**流程结构和过程语法，实际上代表了一种计算模型，即冯氏机上用冯氏结构编程，这就跟函数结构，表处理语法，在lisp机上能更好发挥一样，它代表了另外一种计算模型。**

现在新发明的语言，往往组合使用了二者，

=========================


函数的内存模型，是拥有函数为代码结构的语言必须在后端提供的，，相比于整个运行时，它一般解决运行中的执行部分（图灵计算），，所以可以称为执行时



runtime
=================

当高级语言被发展起来时，程序的运行除了受OS执行外，还受语言运行时的影响。

----------------------------

原来反射技术cpp也有，不过它没有太多，，总言之，反射很常见，并不突匆，so whatis the essinal differs between cpp and .net
为什么在1st compiler then run it的情况下，还要提供反射。。。与什么同类技术可以类比
run it(run 中间形式 with interpter或者os run 最终形式 with runtime support)
在提供了软件interpetr(the vm)的情况下，保留compiler时的元信息，，具有重大意义，因为运行时可由vm用到它。。反之cpp这样的rtti就不需要太多
语言只有二种，先设计后运行，或者边设计边运行，这二种语言可以解释一切现存语言或混合语言，整合语言如C#
或者，平台独立语言或平台面向语言

----------------------------

why runtime has so much nessnary with software extending but not static defaut defs

所谓runtime，就是库的二进制形式，支持着使用它的某个应用能够运行的基础设施,,,,,脚本语言的runtime就是一个宿主的transltor
backend,,,,,,,,,,,,,,,,,,,,,,,,translator is partof scriptor lib

如果将一个平台(native或soft vm)上的语言系统（这个语言系统总是这个native或softvm的系统编程语言）宠统地分为compiletime（的全部设施和活动）和runtime（全部设施和活动）的话，--------此时，让我们撇开前后端之类的语言系统概念，，那么有：



runtime中的代码生成器为前面生成的中间代码(此时，它仅是一种运行结果的中间表示，并不是最终运行结果)编译生成最终面向native或softvm的平台代码(这个称为编译的步骤完成之后， compliletime结束，可供运行的最终平台逻辑已经生成，进入runtime运行最终平台逻辑的阶段,native runtime(由于平台直接参与语言结果的运行，所以runtime这样的说法也可以是平台的)或softvm runtime中的运行器或解释器--也是一种runtime运行器,来运行这样的平台代码，得到最终运行结果，完成一个应用程序的生成与运行过程。 

>>可见，compiletime,runtime只是对一个语言系统中各种设施和活动的统称，native,softvm,编译器，编译，native runtime运行器（由语言系统提供，由native调用执行），运行，softvm runtime解释器，解释，这样的字眼，才是我们用来一切的最好字眼。而不是按时间这样的生硬概念来分，比如，当上述这些部件组合交叉欠套运行时，并不按常规出现在所谓的compiletime或runtime的时候，就会混淆我们的视听，比如：

如果这种编译结果以runtime中的运行器的眼光来看是静态的（全部运行结果在编译期就成形了，那么runtime编译器在生成最终平台代码后，仅需进一步调用native或softvm去解开运行它），并且只存在这样的一遍过程（一次编译完成了，以后每次都是运行），那么以上compiletime和runtime的说法是最准确的。

>>以上过程往往是一般的native+静态编译语言+静态系统编程常采用的方案(编译期，运行期分开，一前一后，编译设施，运行设施分开。)。 

可是，当编译的最终结果还需要等待runtime的合作(仅一部分运行结果在编译器生成好了，一部分需要等待runtime去裁决----语言注重运行期的逻辑，对代码结构需要在运行期作变更，比如动态类型语言)， 

这时，往往一个soft vm就没有那么简单了，它的runtime往往动态调用编译器（解释器往往与编译器一起被组织进VM，VM就是所谓的虚拟机RUNTIME），完成原来由compiletime编译器完成的事。

>>这往往是脚本语言或虚拟机语言，采用的半编译半解释的方案（编译期，运行期虽然分开，但并非总是一前一后，而是交替递归组织，编译设施，运行设施往往组织在一个VM中）。 

<b>编译型语言不需要一个运行时，直接以OS为运行时，，而解释型语言需要提供一个软件的解释器作为运行时的一部分</b>

除此之外，还要注意一个runtime与runtime lib的区别。往往同时有运行时和运行库的说法，前者往往语言后端，后者往往指某种语言运行时必须的核心库。当runtime被做成开发上可用的东西的时候，也称为runtime lib,这是库即应用的表现，在.netvm,jvm这样的平台上表现得尤为明显。 

>>区别：runtime lib实际上是,基础类库的二进制化，作为运行这种语言所写程序必备的，当不只是类库，还有GC等语言设施，与前端一起作为OS一部分作为系统软件存在的。实际上是对OS执行程序的扩展（以运行某种语言所写程序为目的，为这种程序向OS提供运行接口），这时就称为runtime 

小总结：由上面这段话可以看出，编译与解释是前后端二个阶段的事，不可能拿来相提并论。一个语言系统总是不可或缺地存在编译时和编译设施，运行时和运行设施（解释设施），native语言系统和虚拟机语言系统都是如此。 

=========================================================




静态语言系统
=============

对任何相似概念的区别,都要上述到它产生时所带来的那层面意义上.这样,才能不致于讨论时把它跟别的概念混淆而论,而且一定要分清字眼间的不同.
语言系统指一个包含了转换与运行单元的语言系统,编译或解释语言都有这二个部分.(前端:词法分析,语法分析,语义分析),执行(后端:语言运行时和目标平台执行路径,比如OS)

编译与解释都侧重于指一个独立的语言系统而非指这个系统的具体某一部分,当提到编译和解释这个字眼时,我们不知道它是指一个编译器,解释器还是一个编译语言系统,解释语言系统,所以要分情况而论,比如,当我们谈到“C编译器”时,它指某个C语言实现中的编译器,当我们谈到“C语言是一门编译语言”时,这里的编译二字指代这种C语言系统是编译的（存在解释运行的C语言）,即,编译或解释不应脱离它们所处的语言系统的大环境来被讨论,比如这种语言是编译的,还是解释的,编译器是首先作为语言系统的子件而不是独立的子件,而存在的,说明编译是什么之前一定要说明它所处的语言系统这个大前提,才能把问题说清楚

所以，编译与解释是一个本质下的二种现象，不能庞统地说编译语言就是静态语言解释语言就是动态语言。





语言系统
-------------

Xx

设计期与运行期
-------------

那么什么是编译期呢,什么是运行期呢?什么是编译期静态,什么是运行期动态?什么是静态语法错误,什么是动态逻辑错误呢?RTTI与Runtime有什么联系,为什么有new这样的动态分配内存．
我们知道,在编译型语言中,比如c和C++中,写代码就是为运行做设计,程序设计期design time的就法就因此而来,写代码的本质就是在C的数据封装抽象基础上,C++的基于对象抽象上,C++的OO抽象上这些语言机制逻辑上+操作系统封装了的CPU逻辑上,写最终面向CPU的二进制代码,这就是我们说的,系统编程语言的本质在于基于系统逻辑(并且语言本身也是基于系统逻辑的,我们把计算机系统离散基础,语言实现离散基础,CPU汇编语言所涉及到的那些机器离散基础都称为系统逻辑),写面向系统逻辑的代码.(与它对应的脚本语言更多地是为了直接为应用服务因为它极力让开发者绕过系统逻辑).程序运行的本质是什么呢,程序运行从根本上来说,是执行时中套运行时(数据).就是向操作系统和CPU请求资源,CPU执行二进制,(任何我们写出的源程序,在经编译优化后形成目标平台二进制码,我们向PC编程以构造应用的过程只是系统逻辑到应用逻辑的的一个维度变换),这是指比如C++这的以本地平台为运行环境的系统编程语言,而非指自带VM的,向VM编程的脚本语言而言的.
设计期就是写代码期,是用户动作,发生在编译期前,编译期不是用户动作,运行期又不是用户动作..如果说编译和运行各司其职,那么程序员也仅司他自己的职.他写描述运行的逻辑,以体现他要的设计.
而且强调执行不单是执行,而是承担了跟编译前端所以这里谈到的解释系统和编译系统都是指语言系统,而不是单纯的编译中的前端或后端,普通模式与交互编程模式都是这种大模式下的二种策略,不过半编译半解释系统指语言系统中的二个阶段,而不是指静态语言和动态语言都有一个编译阶段,故它们的区别不在于是否存在一个编译,因为它们只道出了语言内部的类型机制上的区别,区别在于对运行期还是静态期语义着重一点,比如:对于静态语言的编译期,维护作用域的逻辑在编译器的语义分析阶段,那么对于运行期,维护作用域的逻辑在哪呢?(其实也在编译时)
动态类型当然是相对于静态类型来说的，但不是运行期类型，像C++库级的类型就是运行期类型，运行期类型不一定是动态类型，但其编译器级即语言级的类型却是静态的(比如PY VM在启动时，在其内部就静态初始化好了int等内置对象)。

>编译器的工作在于将高级码转化为平台目标码(这里的平台之意主要指CPU执行平台,OS运行平台,或者指某种虚拟机的中间码,这是因为编译的意义要分是纯编译,还是不纯编译,但是现代的编译器和ＩＤＥ还加了一些高级单元,如汇编器,装载器,重定位器,链接器,调试器,这些的功能来直接生成可运行文件． 一个编译器,如Windows上的GNU,VC,BC等等,,对应于一个特定平台,编译器实现,链接器实现都是平台相关的(这里的平台主要指OS)往往有一个Runtime库,,这个库是什么呢,,一个OS一般由C编成,这些C的库一般向程序(向编译器编译出来的,往往是用户空间的程序)提供CPU进程,,线程,Socket等资源,运行库就是提供这些访问功能的地方,这就是编译器跟平台发生联系的地方,一般一个编译器都有它对应于某个平台的运行时库.. 编译期静态和运行期动态主要是指类型来说的, 而相比之下,C++直接在语法级支持更大的抽象,它沿袭了C的Core(流程控制什么的,C被称为最小内核语言),但在比较大一点的抽象上它沿袭了C的指针和预编译这二大抽象模块,并自己发展出一个运行期的OO,接着面向运行期的模板可以产生STL这样的泛型抽象集,面向受限编译期的模板可以产生Boost Mpl库这样的元编程抽象集,而其它的第四代语言比如Java,Ruby,Lua,Python,它们在语法级直接支持的设计抽象就更多了,因为它们不需要像C一样处处屈就运行期,,而是屈就人,想怎么样设计就怎么样设计,至于运行期,,完全是虚拟机的性能和对语法机机制的实现支持问题.. 以上可以很好地解释C++的模板泛型和元编程.我们将在以后的章节中讲到.

那么泛型编程跟模板又有什么关系,一门语言的语言机制必定可在它的编译器实现找到答案.那么模板技术在编译器中是如何实现以支持泛型编程的呢(我们会在抽象之高级语法机制那章中讲到) 我们知道,一等公民在一门程序语言中是重要的,C++不支持数组的直接拷贝和赋值,不支持对象的直接赋值,不支持范型类型,这就是因为对象和数组是C++用其它方法抽象得到的语言机制,比如按位拷贝这种机器很擅长做的事,其实范型编程是可以用很多方法达成的,C++唯独用了编译器的＂参数化类型＂作法来实现模板再由模板实现泛型编程,而Ruby等语言有它自己的范型编程做法,,基于对象编程跟面向对象不同,不要以为你会写Class就是面向对象,如果没有用到OO的继承和多态,你同样是在写基于对象的东西(比如OO不但作为一种抽象机制,它还是一种接口机制,类的成员函数是接口,类本身也是一个接口,你需要用OO的private,protected这些接口控制机制使一个类足够内敛,方使多人开发的子程序协同工作,使一个人的工作不必涉及到另一个人工作出来的类内部,比如不宜在里面直接写实现逻辑,要一层一层地下放到它的子类中,如果你还不用private,protected,那么你实际上在面向过程编程,因为这种情况下,class只是一个public struct[1. Class是struct的一种特例,Cfront把C(unix下C++后缀常被表示为一个仅大写的C)翻译为c时,常把class翻译为struct]而已).

静态语言系统
-------------

静态语言系统不光包括静态类型系统，它还强调在设计期就布置好一切运行期逻辑写好代码(静态代码系统)，因为对不可预计运行期的控制要比对可预计的设计期的控制复杂，所以这种方式就保证了编程的简单。

###### 首先,不要把解释系统与编译系统混淆

解释系统[2. 实际上interpreter(解释器)的意思就是翻译者,这说明解释器首先是个编译器作用相当的东西]就是”编译一行,运行一行”,这跟编译系统其实本质一样,都是编译后运行,编译即一种转换,而且这二种语言系统生成的目标都可以运行在一个VM上或一个OS上,以其作为目标平台,只不过解释系统它的编译期和运行期是交替的(但是这种交替,并不会影响编译在前,运行在后的本质,所以说这跟纯编译的本质是一样的) ，也即解释语言是一套结合了分析和运行的系统。

>>比如，JVM就是以CLASS同时为编译和运行单位，因为它有一个强大的软件解释器，它可以调用编译器编译CLASS，然后全程解释，在需要的时候，又动态地调用编译器编译运行过程中用到的类（一切得益于它以CLASS为最小单位），继续解释。在这里，解释过程是不中断的(因为它是软件控制解释器而不能控制一个真实的PC OS来解释)，编译是按需进行的，可以看出，也是先编译后解释，**所谓动态，只是动态得到编译单位而不是说编译过程是动态的**（编译就是编译，又有什么过程？）。除此之外，这个动态没有任何其它意义。

>>对于类型，编译期对于动态不动态的意义在于编译期“完成语言运行前的所有工作，尽可能将其集成到运行期，类型信息大都已经被打散（动态语言在运行期维护相当多的类型信息）”，因为它有一个强大的软件化的后端和软件运行平台（所以总是比native平台的后端灵活，平台与语言后端可以相互迎合，而不是由后端迎合平台）。

动静主要指后端与之相连的那个“运行平台”，如果在软件上能达到支持将前端的类型在运行期换类型，那么其就是动态的

我们知道,语义发生的时机和语义检查的时机才是代表一门语言特征主要的东西,编译型语言就是语义在编译期聚集,解释型语言不妨说成运行型语言,语义在运行期聚集.准确的分法是运行前语言和运行时(运行中)语言,把类型逻辑及语义(比如语义检查,程序查错)弄到运行前,书写源程序时,称为运行期语言,这样编译期本义就少了,程序可能在编译时通过(检查并编译成功),但在运行时出错.py边编边解,可以快速完成编译和在动态运行反映语义结果,这是因为大部分语义在运行中的原因,语义在编译时很少(这样就可以快速完成编译)

###### 也不要把解释系统跟动态类型语言混淆

在Python这样的动态语言中,它跟普通的解释语言一样都是解释的,情况变得有点不一样的地方在于:动态语言的语言结构在运行时会发生变化, 比如,在运行期给某个类增加新的成员,编译的结果:pyc文件中会产生中间内容 (当然,解释器并不会把这个中间变化写到pyc中).而且程序员可在运行期,对程序进行编程.动态改变程序结构.
所以,Python这样的解释语言系统,它跟其它语言本质的区别不在于编译转换跟运行之间的区别,而在于,python作为一个完整的语言系统,它包含转换用的编译单元,和运行用的虚拟机单元,故它能把语义分散在这二个部分(主要还是在运行期),而普通的编译语言,只是一个向OS的接口,所以它们的语义主要维护在运行前,运行时的语义是在运行前就被抛弃了的,程序员对运行期有没有往后的控制权.即主要的程序语义部分,是集中在运行前的写代码时,还是写完代码后进入的运行时.

###### 更不要把解释系统与半编译半解释语言混淆

在纯编译的语言中如C,C++中,编译和运行二者独立,当编译完全之后,编译器的转换使命完成之后就不干任何事了,也不可能继续对运行产生影响,因为这二者是逻辑上一前一后相承的关系(编译器仅仅给运行提供一个源,编译器仅做一个中间过程的动作(转换),后者不可能反过来影响前者) 在Python这样的半编译半解释语言中,它先把中间语言(编译转换的结果)显式表示出来,再运行它.而一般的解释系统可以不提供这个显式表示.比如VB

###### 更更不要把解释系统与交互执行方式混淆

Python是一种“编译与解释交替进行”的语言,这并非指交互运行,交互运行下,可以一次性执行多行代码,实际上,交互运行与解释语言不该放在一起被比较,因为它们不是一类东西.交互运行不是语言系统,而是一种编程策略,后来会讲到 注意,解释系统才能被做成交互执行方式.

