抽象了的运行时,整合了编译层与运行层的语言系统-虚拟机与集成开发平台
=============

前面我们谈到C与系统编程的局限性，以及，脚本语言和动态语言对传统语言的冲击，这促使我们改良语言。





不光是语言,还是平台
-------------

当系统编程不能表现更高层次的应用而且还阻碍了一部分应用时,当C语言不适合于做它不擅长做的开发方面的事情的时候,需要出现一种新的语言.甚至是一种新的平台(这跟出现OS后一定要出现一种语言替代汇编一样).

首先是移殖问题和分发问题的出现,导致了要出现一个更高级平台的需求.我们知道,移殖问题历来已久.各个平台上使用的硬件架构都不尽相同,虽然有C语言这样的跨平台语言,但其实起最终作用的还是各个平台,比如各个平台都有的与其它平台不一样的类型[1. 联想一下C语言为了解决移殖用Macro抽象一个通用的类型的过程,比如typedef unsigned之类,C语言只是对他们作了一个封装,起最终作用的还是平台本身.虽然C提供了可移殖inttype之后扔是如此.],类C语言这样的与平台紧偶合的语言存在太多系统编程级的陷阱和因为指针导致的语言细节的陷阱.而这导致了低下的开发效果(C太不抽象,C++抽象能力很强,然而也太复杂且陷阱多),当开发效率问题都成了一个问题的时候[2. 软工时代主要矛盾已经由性能低下的硬件与执行效率之间的矛盾转变为快速变化的市场需要与低效的开发],软工迫切需要转向另外一种语言[3. 语言与应用的关系是微妙的,请参见语言之争那一章开始的部分].

为什么用java,python,Ruby呢?一个理由是移殖问题,我们知道在一个架构中(比如Google手机平台),应用往往搭建于软件的机器上(visual machine),而往往非real machine(cpu 架构 + os)上,才会具有最大的移殖性(因为在vm上实现,只须要一层,而直接实现在real machine上,有二层移殖障碍需要考虑,而real machine是必须存在的不能发展出一个所谓的“Python机“来,因为OS是必须需要的,一个机器OS不仅仅是像vm这样的东西就可以的,所以解决开发导致的移殖问题,就发展出一个VM出来,况且,对于以后更多的问题,基于软件上的移殖问题会比基于硬件的移殖问题容易得多,所以,某种语言的VM,你可以把它看成是OS的一个组件,它提供给应用层和开发层一个标准的软件支持平台),就拿mysql来说,你当然可以移殖C的mysql到一个手机平台上,然而你也可以移殖Python过去,再移殖pysqldb过去.显然后者具有更强的移殖能力.其实这也就是Java和jvm产生的初衷.

>一般情况下,软件运行环境=硬架构加软架构

那么虚拟机就是专门为了一门语言而出现的高级软件机器，，虚拟机其本质是一台集成了软件上的exe routine的语言runtime，只不过传统的虚拟机摸拟realmachine是为了在其中安装os以应用，而langsys的vm是为了给软件一个exe routine不必一定要发明一个OS发明一个runtime就好了，而且可以突破传统机器的限制加入面向语言的高级机器特性

那么虚拟机就是专门为了一门语言而出现的高级软件机器,,它直接在裸机上(加OS?)运行,因此去掉了OS的作用,是语言跟它运行环境的直接结合体(虚拟机是虚拟机,虚拟机里面的编译器或解释器就是它跟语言发生联系的地方),是为了一门语言而出现的优化运行环境 对了,只是为了跨平台,所以一般发展一个虚拟机(这个虚拟机为一种语言的源程序提供了运行环境,更更重要的是,一般虚拟机内的解释器就是翻译器,如果说虚拟机本身是为了执行,那么内置的解释器就是翻译器了,,因为要把作为高级语言的这种中间语言翻译为虚拟机能直接执行的目标语言,目标语言这是目标平台能直接执行的语言的简称)

这种语言应该是一个大家都承认的标准语言和这种语言下的标准库(用来呈现领域相关应用的那些东西.Java不单因为它是Java,而且还是因为它有一个Jdk而成功的.[4. 语言与库的关系请参见后来章节]),只要这样,只要在意识形态上统一开发了,那么许多问题就不用再考虑语言陷阱导致的开发效益问题了.

然而,人们并不仅仅就打算只提出一门语言,他们进一步想到,如果能把开发平台从CPU+OS再抬高一层[5. 在软件界,抽象永远是解决问题最好的办法],在这个层面上提供统一的东西,比如类型,那么,当这个层面能够被移殖到不同的平台上的时候,语言不也就实现跨平台了吗?这种用软件的解决硬件上的问题,-这里是不可移殖问题,的方式,我们还见得少吗[6. 你看,平台和特定于某平台上的语言开发从来都是同时被解决,密切相关的,请参见第3章《开发模型与语言模型》]这样就不仅解决了语言问题,还解决了移殖这种语言的程序和因为平台不容带来的语言陷阱问题(Java还是因为JVM而成功的,Jdk使以VM软件平台为基础进行编程的工作进入了一种标准,极大地迎合了软件工程的实际需要).

>>整合了平台可以对原来没集成之前的平台因素和编程因素进行组合，比如，可以设置一个类似JVM的CLASS为编译单位和运行单位的机制，这样，就可以在软件层实现统一管理，，最显著的，就是实现动态编译，，类就可以在运行时一边编译一边运行，所以JVM的动态联编是类级的，并不是模块的比如一个JAR包

这样的平台就是虚拟机,虚拟机就是在这样的历史使命下产生的,它是软件上实现的机器,是语言模型跟机器模式折中的产物,因此有些人提出它,目的更多地是为了迎合某种语言的提出[7. 实际上虚拟机并不企图提出一套机器标准,因为硬件上很难实现这样理想的机器,我们的OS和这样的VM根本担负的作用和地位不一样,我们的CPU只能是晶体管认识二个状态],只要给程序执行提供一套执行路径即可,因此也需要OS设计中的运行时,进程,中断等等.虚拟机也有执行路径这样的东西.
虚拟机的意义远远不只是为程序代码提供一个可运行环境,它真正的意义是使编程工作完全远离操作系统跟硬件架的差别(传统的源程序总是要考虑到移殖,而且要考虑到平台本身给语言造成的复杂性,比如C库的I/O),,在JVM和JAVA下编程,我们无视有一个OS和平台的差别,所有人都面对同样形式的代码..JVM有了这个优势,,JAVA因此成为了工业语言的原因之一.
而且这样的机器不必屈从硬件实现(可以基于某种高层理论提出以趋向语言的高阶语法机制),所以虚拟机上的语言,往往是一些刻意区别于系统编程语言的高阶语言,脚本语言.比如Python,Ruby
虚拟机,虚拟机语言,及基于虚拟机之上的开发,其目的有二:1,为平台开发提供一个统一的平台,2,使平台开发的比例极小化,使程序员腾出更多精力来开发基于系统之上的应用.即为了使系统开发变得简单,它可以统一平台(用软件上一致的虚拟平台),也可以用脚本语言的方式使开发尽量脱离真实平台.然而脚本语言对系统开发的封装不是它的重要方面(而且也不提倡对虚拟机系统本身进行开发 – 因此上述提到的1,2反而不是虚拟机及基于其上的开发要完成的主要工作),而是它给予于程序员“开发应用逻辑”的能力.即后一句话才是重点.

>因为建立在PC上的应用几乎不可能不涉及到系统逻辑的开发(特别是真实系统的开发),脚本语言的那种“脱离”, 我们知道也只是“某种程度上的”,它只是简单地假设你不打算面对本地进行开发(因为它只是用了封装的手段,而非直接面对而开发的手段,那是C,C++的能力),而一般的开发中总要涉及到系统逻辑,特别是(真实的本地系统)平台的逻辑 – 除非你总是从事web开发那样的远离真实平台的开发工作.因此,为了在一个广泛的意义上进行编程,我们得同时学习C++和Python,这二门语言都要学,C++给于程序员“开发系统逻辑”的能力,几乎一般的应用,Python给予你“开发业务逻辑”的事(以隔离真实平台的方式),C++也可以给予你“开发业务逻辑”的事(但以建立在真实平台上的方式),总要涉及到这二个方面.因此,对于“一般编程”,C++和Python是必须都要学习的.

因为虚拟机只是软件上的东西,为硬件移殖比为软件移殖难多了.当移殖问题的一个好方法只是把硬件问题移到软件层面上来时(比如OS的提出),历史重演了这个步骤.VM就是企图把编程移殖一个专门为开发定制的软件层面上,VM上.

虚拟机是对OS执行功能的强化
-------------


###### 更强大的直面程序的内存分配策略
xxxxxxx
###### 对执行时栈的抽象 : 更强大的执行路径
基本上,一般虚拟机的实现方式是基于OS的执行路径的,闭包

执行系统层面的对并发的支持
而且,一个VM启动的时候,它还代表一个interepter prosess,即虚拟机进程.Vm里面运行的函数是interpter-level 线程(虚拟机一级的线程,就是说,以虚拟机为一个进程,从中派生的线程共享这个虚拟机进程中的数据).GIL就是进程级的锁(每个进程一把锁).Python的多任务模型本质是以操作系统kernel-level thread为载体的interepter-level thread.
当谈到Pythonsys时, 我们实际上指代Python interpter,启动一个Python(system),实际上就同时启动了一个虚拟机进程(这个进程如果是活动的,就是当前进程,因为一个虚拟机进程是OS级的,而py vm内部又有它自己的进程表示intereperstate,其内部即interepter-level,可以有很多的进程)和一个GIL,Python vm的执行时环境是c call stack机,Python interpter里的内存就是一些能访问的运行时栈式数据[8. 执行时路径中套着运行时数据] - object(Python中一切数据都是object),那么代码环境呢?(进程或线程作为大的运行环境,其内包含了对表示栈式结构的frameobject的封装,这就是代码),可是一个无线程无子进程的interpter ,也可以是一个有线程或子进程的interepter(可以从一个进程分裂出子进程,或在一个进程的内部产生大量线程,以实现并发),比如,在拥有线程的单进程中,这个进程里可以产生很多线程(其实线程也就是进程,不过是轻量进程,即他们跟进程唯一不同的是共享数据,所以需要加锁机制以进行访问控制,即从进程的眼光来看,线程是需要协调访问的那一类进程,如果是从interpter进程中创建很多子进程,那么不存在协调访问的必要,如果是从interpter中创建大量线程呢,那么GIL就开始起作用了),如果由线程来访问这些执行路径中栈式结构内的object,由GIL进行序列化对它们的访问,因为存在很多非线程安全的代码.GIL就是为了保证:任何运行在Python中的object,都是线程安全的.(纯的Python源程序,就一定是线程安全的,不线的,可以用GIL来调整它)
###### 更强大的出错处理:异常系统
OS层面也有对程序出错的处理,不过那是对于指令选择集意义的程序提供的处理,功能十分低级.对于更抽象的程序,比如高级语言产生的程序,因为此时它是基于语法的,所以得要有一套语法级的异常处理系统,它可以被作到虚拟机内部.因为OS级往往只有一套低级的异常,比如Windows的SHE.而更强大的程序需要更强大的异常.说到异常,我们首先要把它跟执行系统相关起来,而不是具体编程本身.即异常啊,GC啊不是语言机制,而是支持语言机制的执行机制,因为它首先是属于虚拟机的,再是属于虚拟机上某种编程的,即在编程的三个大层次中,异常,GC是属于执行系统层面的,而不是语言层面的.而虚拟机上并不总存在一种编程,Java最初是成就jvm的,而py vm最初是为了成就Python的.这就是虚拟机跟语言孰侧重孰偏重的关系.
###### 无需手动释放的堆上数据:执行系统内置的GC
对象不可达,所以需要回收

垃圾收集器只能在确认对象失效之后才会行收集；它是不会知道你对垃圾的定义的(在用引用计数实现的GC中,没有引用的那个对象绝对没有用,但拥有引用的也不是表示它们全有用),个典型的例子就是堆栈:有一个数组和指栈顶的索引构成.你知道这个数组中有效只是在顶端的那一部分,但Lua不那么认为

内存泄露不只是野指针和这样的东西,可能是由大量正确的现象组成的,最终导致的一种,使可用内存变得少的原因.它只指内存变少后的结果

悬空引用(回收了要被使用的内存)

整合的平台
-------------

虚拟机作为整合方案，它还整合了对编程语言的支持。虚拟机提供对运行程序所需的那些功能,即执行功能,不但这样,它还提供专门对于py编程的一些特性支持,vm并不强求对应一门语言,它更多的是提供一种建立在OS之上的软件的执行平台,但是另一方面,它又是强烈偏向于某种语言和编程方式的.

虚拟机提供对运行程序所需的那些功能,即执行功能,不但这样,它还提供专门对于py编程的一些特性支持,vm并不强求对应一门语言,它更多的是提供一种建立在OS之上的软件的执行平台,但是另一方面,它又是强烈偏向于某种语言和编程方式的.

java和C++一样存在二个层面，因为它是对系统编程和超越系统的那部分编程的整合化方案。
虚拟机模糊了OS的执行与程序的运行之间的区别.因为一个功能完善的虚拟机也可以抽象出进程,网络,界面,IO这些程序赖于OS才能运行的基础(虽然虚拟机也可能正是在OS的基础上抽象而来的,但语言的虚拟机提倡脱离以OS的执行路径为目标的编程方式,比如,虚拟机的确可以做到只用用户级的进程来抽象并发而不用到OS的进程.并在这种虚拟机支持的语言内只使用这种进程抽象出的并发编程)
Java语言虽然有一个JVM,但并不特别地针对JVM编程(它跟C++一样，存在二个层面，第一个层面是系统编程级，即j2se级，第二个层面是脱离了系统的层面，即j2ee级),所以它不是完全的系统编程语言,因为它的目的还可以开发跟系统 – JVM无关的应用,系统编程语言跟应用开发语言之间的差别不在于它们是否有一个平台,那个平台是软件的还是win32的,这个平台是标准的,还是对于编程来说是原始的,它们的区别着重在于:这些语言,是针对系统本身进行基于系统类型之上的扩展开发(C,C++之于win32的关系就是),还是针对独立于系统类型之上的那些非系统的应用开发(这就是脚本语言,java就是).所以C++是系统编程语言,Java不是.(所以说,java偏向于指一种脚本语言.但一般人还是把java看成是系统编程语言.)

.net类库的system和runtime命名空间中，有鲜明的“平台承载语言”的特点，比如，其中有“面向编译器的通用类型cls”和“对编译器的runtime支持

总结
-------------

**OS,就是对裸机的虚拟机,而JVM,PYVM,CLR这样的虚拟机,就是对OS的虚拟机,如果说OS是强烈面向各种用户的,那么JVM,PYVM,CLR就强烈面向其上的程序员.**

于是,我们应该说,py语言系统,单单用py虚拟机来指代py的说法是很容易弄混的(我们得把它们看成一个**语言系统组成的整体**), 在接下来的章节中,我们将用py vm为例,谈谈这种软件上的执行平台作为编程平台,它对传统上OS执行程序的功能作了什么样的强化.

很明显,我们不可能在OS层面直接造一个GC,因为OS更多地是一种执行平台,换言之,它是系统平台,而不是完全的编程平台,虚拟机作为软件的OS,它就是要达到一种为编程提供全程支持的抽象了的执行系统,而我们显然不可能为了开发就去改造OS(OS和VM的角色使命是不一样的),因为支持开发并非OS的唯一目标,它还需要做其它的事情,比如作为系统软件区动硬件,而显然,OS层面对于执行程序的功能跟虚拟机有相重之处,虚拟机的使命就是要彻底分离开执行系统与语言系统,虚拟机假设语言不该是OS管的事.

>Java这样的语言为什么显得慢？ 解释型语言慢是因为整合了语言时到运行时，这种强开发（为了开发甚至重造一部分OS功能）的方案使得语言背负一部分OS功能，故慢 而且这种语言在vm上即软件机器上，而且加了很强的异常等语言要素，整合化的东西往往很大，故慢 而且这样的vm一般使用软件上的堆栈空间，故慢

对于Java,你会很是奇怪?为什么Java不作为游戏的脚本语言被广泛使用呢,这跟Java的性质有关,Java自它被设计出来就作为非本机语言来提出的,它的数据类型全都不是win32使用的,Java虚拟机独立平台,Java虚拟机的出现完全是为了配合Java语言而出现的,Java语言中的jni(Java native interface)就是为了让Java本地化而出现的东东


>对于C++,同样为编译型语言,java编译为什么那么快?为什么C++的那么慢,当不了网页开发语言.而java虽然是编译型,但因为其编译比较快,所以可做到一点点的边编译边执行(用户对一个未编译的网站模块的第一次访问实际上会导致它的编译,要么出错,要么快速编译通过).当然,C++不能当网页语言,另一方面是java有servlet与jsp这样的规范,java语言内有很好的正规式支持,等等,它写出来的网页往往是能快速编译好的源程序,而C++写网页,往往做成(比如vcl的websnap控件组)可执行文件的格式,这就是“编译型网页”,往往烦琐难维护.除了C++本身复杂性导致的源码问题之外,C++它依赖本地的性质又使它不能符合网页服务要求变动性的要求.