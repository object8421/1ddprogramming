soft VM
=============



soft vm vs better c这样的方案比较：
作者不满意soft vm只知道集面不知道创新的方案，提出了jvm.netvm不如vb plus vb runtime的wtos方案，详见以后文章







虚拟机的实现
-------------

实际上编写虚拟机是编写OS的技术之一[1. 参见选读部分有关章节],计算机的功能的一个重要方面是它如何响应中断和执行程序,所以在软件”机”的实现中,也必然要涉及到这二个东西,而至于像文件系统那样的子组件,可以直接采用封装了的OS文件系统与IO(虚拟机作为平台上的编程机，是软件上的运行时，是独立的编程层，故直接封装OS上现有的抽象作为其软件基础，比如宿主进程的调度和时钟等),这样, 其实Python vm就是简单的for switch case一系列VM的instruction来的(跟《虚拟机的原理与C实现讲的那个VM差不多》)..而且它的执行方式也是堆栈原理(运行时),跟普通的虚拟机的实现原理也差不多,至于它的架构,采用的也是类Java那种“编译带解释”的“半编译半解释”语言.

实际上虚拟机技术,也是 PC开发工程的一部分,当在构造一个硬件环境前,首先构造一个虚拟机,然后给他设计一套汇编语言.除非你不打算给这种虚拟机进行开发,一旦有开发的需要, 就需要实现一个汇编语言或一套高级语言.这种必须要实现一个汇编器,,,只有这样,虚拟机才能开始执行,,虚拟机本身并不需要一个汇编器才能开始执行字节码,你可以直接为虚拟机手动写字节码,,提供汇编器只是为了开发的需要..上面说了.

软件实现的虚拟机往往是一种高级机器(是一种刻意为了适应程序的运行而设置的完美环境,实际硬件上的这样的机器没有),而往往是一种虚拟机能执行的中间码,,当然,虚拟机上的语言如果有特定编译器和编译技术的支持,同样可以为操作系统和硬件生成机器码(JIT技术)

不过Python vm就是高级点嘛,它的指令不是像jvm那样的简单的模拟机器处理内存,中断这些低层机器的功能,而是高级的指令(在实现这些指令的时候应该难度很大,如果说jvm是汇编机,那么py vm就是C机,你可以这样理解,即强虚拟机(弱语言),当很多事都被虚拟机干了的时候,编程就可以写很少的代码就可以表达很抽象的软件逻辑,所以人们一般说Python代码实现起来写的代码比Java,c++少,大约为它们的1/4),比如load_attrib这样的直接跟语言相关的指令都有..其实 Python vm的实现原理并不独树一帜,我们关注的是Python vm在动态期如何运作,,以支持它的那些动态语言特性的(Python源码剖析到那里就断了),比如内省,饰符,函数式编程等.这才是对学习Python 编程大有利处的地方

.netvm ,jvm
-------------

虚拟机是对桌面系统应用的完善，在开发，运行，发布，等所有方面的完善（作为其平台基础服务）

asp.net 跟 ado.net 一样。不但是一组 net 类库。而且还是一个 clr 功能组件。

clr 提供了安全执行程序 。 分发程序 。 为不同模型的程序提供不同宿主的内在支持 。 比如 。
支持 asp.net 的网站空间不能执行通用 .net 程序。因为那里的程序是运行在 asp.net
hosting 宿主中的。

传统的托管程序与 .net 上对应的程序并不等价，要说转移和封装其实更是一种全新的重实现，要知道。比如 xna 不是 .net 版本的 mdx, .net 并没有为 mdx 设置一套专门的执行环境 。 这样的例子还有很多 。 net 的 windows 和 wpf 是 .net 的 gui. 决不 是 win32 gui 的 .net版本。

Python Vm 的执行路径
-------------

CPython版的Python vm有二大模块,第一是解释器,这也就是Python core(内有词法分析器,语法分析器,编译器,执行器,一般称这个执行器为解释器中的执行引擎,就像OS中给程序一个执行路径的那些支持逻辑) 执行时和运行时在这里有明显的分野, 第二是运行时环境,包含(对object/type 结构支持,内存分配支持,虚拟机状态支持),一般运行时只有内存分配支持这样的东西,从这里可以看到Python vm是种高级的机器.甚至需要object/type这样的东西来支持其运行.

如果硬说有第三部分,那就是语言库和用户自定义的那些库了.
Python 启动的时候,实际上它在计算机中的驻体,就是那个Pythonx.x.dll文件.这个驻体代表一个interepter sys.即sys module, Built-in module,main 都是系统启动默认情况下的东西.__builtin__,__main__交互模式下,加载文件执行的模式下,都是这样.

Py系统实际上包括py本身语言系统,和它与C的接口系统,无论是在C中调用PY(embeding,这是指在C中调用Python.dll),还是在PY中调用 C(extending,这是指将C的DLL转换成Python接口),都是使用的这个接口(py2c,c2py,都是同一套接口).所以,如果你要使用到Python的与C交互的功能,而不是仅是py本身,那么你将要学会它与C的接口系统

所以,学习的第一步或最后一步是考虑学习不学习与C的那些接口

就py本身(我们称这个py为py语言系统)来说,它包括学习这个语言系统中的执行系统,即vm(那个既是编译器又是运行器的Python.dll),还包括学习py编程系统本身,这是第二步

就执行系统来说,有interpter系统和compiler系统(tokenizer和parser)

对于执行系统中的指令系统.指令执行和存储是冯氏的本质.它关乎语言的语法语义中的表达式和语句.是基本的流程控制语法结构的来源(顺序指令逻辑到高级顺序语言结构).

(不光是指令系统 – 虽然它关乎语言级的东西但因为它还不是语言级的东西.在执行系统中最重要的部分还是类型系统,这些类型为后来的语法语义级的语言要素所用.所以,类型在整个py语言系统中是主导地位的)
对于执行系统中的类型系统(也许是运行时中的),我们要看它的类型系统中的builtins类型系统,即builtininterpter_interal 对象(codeobject,frameobject等),和builtin_compiler对象(str,dict,module等等),以及这些 builtin类型(此时它们还是c对象,我们要注意它在C级的语义,即实际上,在cPython级是pyobject*,在Python级 (metaclass,class.object,instance)是abstract object layer 和concret object layer,应结合对这二者的综合考虑,理解Python的类型系统.),它们在Python语言本身中的对应语义和形成的Python级语言要素 (Python中对访问这些内部对象形成的的“compiler services”,和”interpter services”的”language 级services”).

然后我们要学在1,py本身的语言实现中,和2标准库级扩展出来的extended_types&amp;objects

语言运行跟二个东西有关.执行环境和运行环境,上面仅说了执行环境.对执行时栈的抽象系统(c call stack导致的泛过程抽象),以及指令导致的过程语句等结构,上面还说了运行系统中的类型系统.可是对于运行系统中的任务系统异常系统, GC与内存模型都没说到(这些运行中的东西.都被对象化,可以被编程控制),

我们应知道有些操作符是用OO来实现的.即Python语言中(那些出现在py语法教科书中,为我们拿来写程序的)的语法语义级的东西,往往都是(C级的OO实现)扩展(operater overloading,descriptor是oo的dict来的,method方法是对象.for实际上是..),并非编译器内置 builtin_synax&amp;sematic的.

>首先, Python中的过程语言要素.它本来就是高层的.这源于虚拟机本身的指令的高级性,它的指令不是像jvm一样的处理基本primitve types的内存搬移,跳转等的指令.它的指令是直接涉及到C的语义的dict,closeure,c call stack等(整个Python语言的语法语义在C级都是用这样的东西实现的)

指令的高级性和内置类型的高级性,这就导致了它的理念一开始就别于c++,Java这样的语言.Python的OO语义本质上也是用这些C的语义实现的.所以,最好的学习PYTHON的OO理念的方法是学习cPython级的那些类型.

**当然,这些类型是adt(注意这句话)**,所以它们不是primative types(这相比实现C之类简单语法的编译器实现来说，由于其编译器内直接利用了ADT，所以其上层语法就直接可以是ADT了，而且可表更复杂的语义),这些adt可以表达很复杂的语义(descriptor,propetrys等等).

比如OO,object只是py中的对象(也即,classobject的出现).这样就把对象弄为一级公民类型.

一级对象,是不是不是单指“编译器内置类型”,而是指表达式里面的因素

以上是第三步
第四步(当完成第三步之后,实际上第四步的内容也就不多了,因为第三部分几乎是对第四部分的一个全面支撑).就Python编程系统来说.因为编程实际上不是自定义就是扩展内置类型(py事先把这些大量的东西都类型化了)和内置库,我们要学习它的语法语义和标准库第五步.学习Python编程系统中的语法语义中的过程部分,OO部分和functional部分.实际上如果知道第三步,这部分的内容也不多第六步是对标准库的学习.除去前面谈到的编译器服务等那些跟语言设施有关的东西以外(threading,ref count,compiler services.interepter services).这里的内容也不多了前面六步说完了对于程序员和运行期的那些东西,第七步,是py中有关设计的东西.IDE,test/build循环.Descorted((直接用语言内的东西做设计的地方表现2),dp,ds,tricks(用生成器实现协程),Idioms(标准开发方法) 如此,则大计可成要学习Python,我觉得C语言是起码要学的,即使是以后只会用到Python这样的高阶语言作开发,最好的途径还是先学C,比如学习编程必定最后要涉及到系统逻辑,所以本书名为学习Python用书,但却从一开始就作了足够的铺垫,从系统,编译原理这样的话题说起,浅而不缺地阐述了你学Python所必须要懂得,或了解的那些东西. 对于学习策略,是首先学习上述的计算机专业课程的知识,还是先学语言呢,,,,我觉得是先学语言,,因为理论的知识在没有实践的前担下很难掌握,,而一开始就学习语言(我这里只指C语言)是最好的办法,,,因为在学习的过程中,你需要一门语言来实践,,,验证各个小问题的语言实现,来掌握更多的知识,我所推荐的学习方法是先学C,再学数据结构,C++只需要学习其OO和STL就差不多了,最好严格按照这个顺序进行.

Python编译和运行的基本单位,是一个一个的modules,再由这个modules,深入到其内部的某个可运行单位.
###### 调试
而其实,编译期是机器能发挥它的能力的地方(是最适合设计的,比如模板策略),只有运行期才是最靠人的应用的(比如实时显示结果,但调试困难)这就是一对矛盾.
为什么动态类型语言不太容易调试呢,比如一个函数,形参没有类型,调用时可以往里面放任意类型,这就导致了这个函数的设计者与使用者产生了一对矛盾,使用者没有放上设计者期望的函数形参,而函数也可能罢工.此时就需要异常,GC等语言设施来避免.

从下面开始谈到的Python都是以Python的C实现来作为基础讲解的


vm提供了对虚拟机语言组件机制的解决
-------------

运行时终究只是某种二进制的语言设施(比如一个库被发行时的情况),,,后端,,是编译原理中的说法,,它们最终的所指,,,其实是解释器,转换器,编译器,,,这样的东西,比如运行时中有三者中的任何一者,后端中有三者中的任何一者

qtcpp有一套“让库即应用单元，，发行单元”的功能（类jvm,pythonvm对于sitepackage的管理导入）？？是它的组件吗，，，基于gcf的行不行能不能达到？
cpp这类语言天生不支持运行期可动态装载的单位,,作为运行单元同时又作为发行单元,,,所以无法形成形成真正的类级的组件化,,gcf这样的东西实现的也只是二进制组件级的大粒度组件,也因此signal/slot connect classes这样的东西,,就是qtcpp所指的语言级的"组件吗",,,

抽象架构和组件架构,,,语言系统对这二者的支持都要完备
意识到组件机制(执行可执行体的方式)，也是一个语言系统的基础(它影响到程序发布)，-------虽然不一定要建成一个二进制级别的组件编程方式，有了组件机制就可以不仅依赖操作系统的组件(将其与操系统执行可执行代码的方式分离)。它与class一样重要。它可以从组件级架构抽象。就像从源码级那样做一样。
组件，应首先是语言系统支持的，，，架构抽象的机制。。其它的意义，应是以后的，都是它附带的。。
如果用虚拟机来解决，在这种意义下，，虚拟机是用来成全组件机制的
class is src lvl abstract building cheanism,,,compent is bin lvl abstract structing cheamnism
组件是必须的，因为它关系到进程的单位。。可执行单元无论是OS还是语言运行设施都是需要的，，所以组件是必须的，在受语言产生时，它代表的是将来运行期的进程单元，在对应源码中的抽象体。

终于理解了组件的终极意义！

组件的本质是创建进程和可执行体的单位。


组件机制是组件机制，是系统支持，组件开发框架是组件开发框架，是语言支持范畴
组件开发技术重点不是强调如何从源码导出接口，而是组件间的接口如何交互，组合形成应用，即组件层编程而不是源码级。
强调将小类做成组件形式，，而不是完成大量源码class集，然后才形成一个大组件。这样才能发挥组件编程的优势。
放弃编译单位，，库什么的，一切都是组件，放弃操作系统的运行单位，将这一切统一到语言管理的组件机制。在需要的时候，才将大量src lvl class组成一个大库，且不组件化。
组件开发的典型情景：比如为一个编辑器增加多种不同的插件，这样编辑器(组件)就可以动态与插件组件交互，动态期发现它们的接口为编辑器的新功能，这一切都不是源码开发的
要摒弃这种开发空间，，将一切做到src lvel dev space
很明显地，组件不但与分布相关，而且与发布相关。
