title: C与系统编程的局限
prev_title: socket programming
prev_url: socket programming.html
next_title: 如何更好地解决可复用问题及其它问题
next_url: 如何更好地解决可复用问题及其它问题.html

为什么这章不写更多? C还善于用来作什么编程?
=============

算法和数据结构将应用问题离散化为软件上可用的抽象,基于高级语言的系统实现和基于系统实现上的系统开发,进一步发挥了抽象,促进了软件的内涵.也使编程进入了一个新境界.甚至是应用编程.

系统编程就是对系统的实现和抽象，应用编程就是那种在编程意义上已经脱离了要直接处理这些事的开发,它直接面向的是某种概念逻辑上的东西.所以需要某种高级语言或抽象语言,这就是脚本语言或虚拟机语言

系统编程第一要考虑的问题不是方便性和灵活性,而是安全性,特别是类型的安全性,高层编程注重的速度上和人力上能得到节约的效益. 大都是业务逻辑。

>请注意，业务逻辑不是不重要，相反，它们是系统编程语言解决完系统映射问题后，要针对的全部目的（如果依然要用系统编程语言来完成业务逻辑的话）

比如，web架构的集成分语言平台和集成化框架的条件下，使得人们有更多条件专注具体的业务领域。





形象理解C语言中的一些至关重要的二义性
-------------

C语言的灵活性很大一部分在于它的二义性(语言的或者非语言的都有),甚至多义性,只要掌握了二义性,那么C语言就是一门不灵活的语言了,下面试举几例: C语言中没有字符串这种“型”,C的字符串实际上是字符数组.只有字符才是“型”； C的布尔也是数值(当然,新的C99有真正的布尔了) C中的字符是数值(编码的),所以可以跟数值型作转换或计算.因为字符就是“字节”,所以像memcpy()这样的函数一方面是字符中函数,另一方面却又是内存数据操作函数. C的赋值是一种表达式,而非语句,所以可以跟其它表达式进行无穷有意义的复合. C的多维数组根本就是一种本质上由一维数组变来的,C在语言上只支持built-in“单维数组”； C的“可变数组”实际上并非“动态数组”,动态数组指数组的大小可以通过增删元素来变其大小,而可变数组光指数组的维的大小. 而且所谓可变,,也并非真的在运行期可变(否则就是运态数组了),而是编译期可为维数大小指定一变量. 在用了数组作为函数的情况下,对函数原型的声明可以省略变量名写出来. C的传指针给函数,实际上还是传值,不给传的是指针值.虽然语义上正确,但语法上没变. C中,一看到数组名就要把它跟数组第一个元素的地址相提并论(但它毕竟是相等,不是同一),不能产生其它想法.这造成了对数组元素表达上的多义性.

[pre]
Int myarrary[10];int *ptr=arrary+5;
[/pre]

在这种情况下,ptr[2]是错误的定法.因为不能对一个不是数组的ptr取下标. 屏看和近看原理.比如 int *p实际上正是int* p; int const a实际上正是const int a;

int const *ptr跟 int * const ptr不同,前者为指向“指向const int的ptr指针”,后者为“指向int的const 指针ptr”
<ol>
	<li>define实际上只是一种编译前的替换,所以</li>
	<li>define someformdim char*; someformdim a,b； =============实际上定义了char *a,b；</li>
</ol>
(当然还有其它,比如经替换产生的声明语句会导致在它出现的位置无效) 总而言之,C的二义性正是它的优点也是缺点,C正是借助这些具备多义的东西达到一种紧凑的效果.

C与系统编程的局限
-------------

###### C的观点:底层不需要直接代码抽象

**任何语言都有算法+数据结构之说的设计,但C更为突出,因为C只有这种设计范式**,相对其它语言众多的语言机制来说(除了基础流程,类型系统那些东西不说),这更像是C的设计全部[^1],为C而生的,在用语言机机制表达应用方面,C++有“类”,有设计模式(但设计模式用C来体现,似乎没有人作过尝试),有模板,有编译期多态,有范型,当然也有“算法加数据结构”,但C仿佛只有这种““算法加数据结构””,,,是设计的非常原始阶段和手段..
在C中提供了很多支持数据结构和算法的元素,比如数组,链表,指针,struct,typedef,相比其它语言,c还提供了比其它语言的更好的支持数据结构的语言机制..特别是,C中的一些语言机制,如位移(其实大都机器提供的位指令并不直接操作位,而是对整个字节进行位操作,进而间接控制所需要的位,我们常常通过对原字节进行位移的方法得出bit mask,再将这个bit mask跟原字节进行与,或,异或,最后得出需要的效果,比如提取1位,消去0位,颠倒特定位),跟搜索算法中特定一些算法直接相关,,相比之下,其它高级语言的数据结构都是基于高级语法结构的.甚至于像lisp这样的语言就将adt内置为其一级类型.
但是在C的开发中即系统实现和开发中，也不是就不涉及到抽象，比如，管理器，这样的概念频频出现，实际上,脱离平台逻辑的那些领域问题,基本上人人都会有一个解法,宜在这里采用OO,OO最应该出现在脚本语言中,并且面向对象和基于对象也是二种几乎性质的东西,虽然都是设计期,都是对运行期的设计,但其底层支持下的RTTI有性质上的差别,C++作为底层开发语言,它提供的“基于对象开发”还是比较接近C“封据抽象”的风格的,但是它的面向对象,就有点脱离系统编程语言向DSL发展了,一般来说像RUBY这样的语言才提供OO和其它一系列语言机制.因为这些语言机制都是脱离系统编程的高层问题所需要的.而给底层开发提供一个OO,反而让人觉得封装过头,,抽象得太象了,,太象人的思想了,反而不能够让人家了解系统编程语言作为描述底层的透明性要求..

###### C需要什么补充

如果再回到C++用Template等高级抽象语言机制实现的语言要素和C版本相对应的那些语言要素, 那就是一个更大的区别了,因为处在不同的抽象层次有着不同的实现理念,.比如C99的数组跟STL的数组,一个是C上面的plain old的面向用内存来抽象问题的,一个是C++的模板技术上面的面向用范型理念来解决问题的,编译实现的支持基础自然也就不可平等而论． C++为了成为多范型语言[^2],先是杂合了C的很多特性,提供了指针,位,函数,流程这些原C的过程范式的东西,再加上异常,严格类型,就成了一个”better C”,所以,C++除去C89 ”Better C”的这一部分才是C++的主体[^3],即C++的基于对象和面向对象开发范式,模板语言机制,还有它的一系列用模板实现的标准库.. 又实现了一个运行期OO — 其中有运行期多型机制(这是C++之父"发明"的),再后来是在没有任何原C的编译技术的支持的情况下发展出了一个Template(也是C++之父所在的研究小组"发明"的),是C++首创的独立编译技术[^4] (并由此＂发现＂了C++的编译期多态和实现了Loki,Boost MPL库等),STL就是用了C++的Template而出来的东西,STL是面向运行期的,而Boost MPL库是面向编译期的.

>为什么要出现C++? developer是发展,向前发展的意思,C是好的系统逻辑实现语言,然而不好的系统逻辑再发展语言,它只能很好地把它的工作进行到这里为止,即对于编程者,它不是一门好的系统开发语言,系统开发需要更强大的面向人的抽象机制,这些抽象机制需要被集成在语言中,因此需在不改变C的情况下(注意这个条件非常重要,C++如果不首先是C,那么它就不是系统编程语言,比如delphi,也是本地指令,但强调rad),增加新的抽象和设计支持(这就是OO和template) 在C中,数组就是原生Built-in的,,数组就是连续的同类型数据在内存中的分布,,,注意,1,连续空间2,同类型数据,,如果不是连续的空间就不是数组,,比如用指针link起来的就是链表,而不是"数组表",,注意"表这个说法",,数组是一种表,,因为它用索引下标索引数据对象,是一种key:value对,而链表也是2同类型数据,, 在STL中,模拟数组比如Vector,List是用模板来实现的．．这二者之间明显存在差别,静态数组一般直接用C的数组,,但是正因为C的原生数组是没有边界检查的,编译器根本不保证这个栓查全部交给程序员来处理,,而STL版本的模拟数组就会非常严格．． 这就是二者之间的差别

###### C可以用来表达应用吗?

诚然,C只有有限的语言要素,它的语法只是稍微抽象了汇编,它适合描述系统底层,而不适用表达过高的抽象,比如它没有直接站在OO角度上去描述除系统底层问题之外的其它问题,C的那些语法机制是C在语言级能用来表达所有问题的唯一方式(即使这样,C还不失为一种系统编程和应用编程的综合语言,它的表达能力还是巨大的而且C的优点是易于学习进门但进阶难,不像别的语言连进门都难比如OO语言,它的OO机制一时半会是很难被初学者理解的,我们在本书一开头就讲到,OO的简单只是相对会OO的人来说的,像,java的OO就比C++的OO简单)C虽然没有语言级的OO,不能直接用C的某种语法机制进行OO思维写OO代码,但C的一些简单语法机制同样可以实现模拟了的OO的抽象(作为库级抽象来进行OO)..这导致“如何用C达成高度抽象语句或程序”这样的问题的产生(不只是OO,C也可以实现C++的template各种各样的抽象来间接解决现实问题而不满足于用C本身来直接解决问题,这里,间接解决现实问题定义OO等库逻辑,就是抽象的意思所在). 这就是说,抽象并不用C的语法机制直接写应用,而是在进行某种设计,在C模拟的OO中,它企图先在库级完成C模拟的OO,再去解决它要解决的最终问题(是一种跟C++的元编程一样的手法,是一种拙劣的抽象迂回行为),当然这只是C抽象的一种,C的抽象主要表现在四个方面,

1．用C来解释的数据结构问题本身就是某种抽象和设计,在一些教材讲解到的C版本的数据结构教学中,可以大量看到C写抽象的方式

2,C的指针是C的主要抽象手段(这样说是因为一些其它C的语法要素也跟指针一样用于设计导致高抽象,),C的指针可直接产生很多复杂的思想

3 跟上面一开始谈到的一样,我们想用C构建某种靠近现实问题的抽象,比如我们想用C来实现OO,或者template,这样C的这些逻辑就成了dsl了.再来解决问题.

4,我们不想先实现一个OO,template这样的通用解决问题的C抽象,这样的通用抽象称为范式,而是直接面对要解决的问题,用C的语法语言要素去产生一个或一套习惯用法的抽象.相比OO,template这些范式是小规模的抽象惯用法,下面我们来讨论一下C高抽象的习惯用法..我们还有另一章专门讲解OO范式.

1),,用指针,struct,typedef,,这样的东西可以声明一个链表的结构本质,这在数据结构中大量看出.指针是“通过地址来操作变量”的抽象,struct是建立在简单数据类型上复合数据类型的抽象,typedef是type redefine的抽象..这些抽象分别使用,或者组合使用可表示很多其它高级抽象.. 2)形参定义为指针,实参向它传地址,实质上是传值然而意义上是传送地址,这种指针的抽象用法,可用来影响调用函数中的实参. 3)void这种类型可作为形参,实现一种多态机制,,void函数也是如此. 4)C语言数组的本质是地址,多行数组是按行优先描述的一维数组,因此其元素地址都可由数组名抽象得到. 5)字符串是一种变长字节,操作字符串的那些函数,也可操作内存块,这就把字符串抽象为一种数据结构的东西. 6)C用void (foo *)(int)这样的结构来表示返回void,以int为参的函数指针foo.这遵守屏看原理.关于函数指针和数组指针还有很多抽象的变形..来实现回调函数等抽象. 7)C的指针在链表中,实现了一种"指针即变量自身"的指代作用,比如stack-&gt;next=stack-&gt;next-&gt;next,这种指针的赋给,实际上就是指针所指变量在意义上的直接替换..这也就是C++中为指针新增的引用语法..

typedef实现了换名和子集定义抽象,用旧类型定义出新类型,新类型就是旧类型的别名,或者是旧类型的一个子集,这样的抽象语义..特别是define实现了一种变量替换式的函数抽象. 9)用const或双层const进行防修改. 10)还有很多很多.. 对于多人共工的软工来说,一门语言的灵活性反而是它的缺点所在,而且C不抽象,需要大量工作要做.所以它不软工语言.

>要说C是一门应用语言,那么它的应用领域就是系统领域.当然,C也可开发那种脱离了系统的“应用”,但那并不是C擅长的领域所在.而是C++的. C语言体系[^5],包括C和C++,但主要还是指C++,因为在C语言体系中,库是高于语言的,而STL,BOOST库都是C++的模板上面的东西.我们在前面说过,C++其实还是C,不过是C加进了OO和template的advance版本和特例情况.这是从C++眼光看C.如果说这段话并不有太多的说服力,那么下面还有说明: 但其实,C++才是C语言体系中的常例,C才是特例(它适合做系统低层和极度效益敏感应用,还有一些需要特殊性目的应用[^6],去除了设计的C语言系统刚好运用于系统低层).C++才是C语言体系的主体.因为一般的编程,几乎不可能不设计到那些构造在基本结构化设计手段上的OO设计体系中的手段(这是从C眼光看C++,因为C++是C的增强,它代表C整个语言体系的新发展,故更能代表C语言体系本身,这是跟上面从C++眼光看C的同一个问题的二种说法其二).而OO,已成为现代设计的代名词.况且,C++还有模板呢.更并且,现实的情况是,C语言体系的库,主体都在C++这边,而且,都是模板库.以至于有些初学者,一谈到C语言,都会以为是指C++,而忽视了C也是独立的. 故,C++才是C语言主体的常例. 基于这样的考虑,本节我们在讲解C与系统问题的时候,并没有涉及太多.只涉及了C与OS core的东西.(甚至数据结构,也主要用C++ STL来解释,而不是POD C).而系统编程,其实主要还是指C++.下面我们就会来一一讲解.

一般,当判断一个问题是用C来实现,还是用其它语言好时,请参照本章从头讲到这里的所有内容,这些内容之外的问题,一般来说不是C擅长的,也就是说,C的确能直接解决一切问题,但是它最擅长的,却只有初级系统问题那一类问题[7^] (C一度被作为Unix专用开发语言出现,甚至对于系统逻辑中的高级部分,它也显得力不从心).它并不擅长表达太远离(初级)系统问题之外的高级系统逻辑或高级设计,或高级应用逻辑.因为这样的话需要写很多代码,而C太不抽象,无论是可读性,还是开发速度,移殖能力,都比不上用更高级一点的语言来表达好.

但是,有一些例外的情况.比如对速度敏感特别高的程序,此时可读性和使源码量降少,移殖能力这些问题反而是其次,此时才用C,比如XML实现(这是一个非初级系统问题),可以用C+数据结构的方法来解决,也可以用高级的手段和高级的语言来解决.此时,考虑到它是速度敏感的,你就可以用C来实现(这样的话,日后它还可以被其它高级语言bind后复用).

还比如编译原理这样的东西,其实它属于高级逻辑(而不是初级系统问题),但是因为其内部大量用到了数据结构逻辑和算法,而且,其对编译速度是敏感的,所以,经常用C来实现.

当你从本书开头看到这里的时候,你也就熟悉了C语言的语言能力和语言优势,和它在历史上能很好解决的那一类问题了(这些东西,都成了开发的惯例,当你学习到这里,C语言的开发你就基本学习到家了:)我们将在丛书的第三本里向你讲述一个系统的例子,届时,你就可以说你已经学会用C语言来进行开发了).
在本书接下来的部分,对于高级系统问题,有新选择即C++语言.它不但是个better C,而且还有显式的复用和设计手段OO.(我们此时不讨论C++的template机制)

[1]: 我们在前面谈到,一门语言的表达能力主要体现在三方面,1数据结构,2代码结构,3设计模式

[2]: C++的理念就是允许程序员可以在同一种语言里有多种设计方法,就是所谓的多范型了,C++几乎没有任何一门语言机制是它首创的, 重载来自ada,,模板来自ada,oo来自smalltalk

[3]: 所以说学习C++是学习C语言和C++语言这二个过程,我们知道++是C家族语言中特有的运算符,C++这个表达式表示,第一次的运算过程只首先取C的值,第二次及以后的运算过程才在保留原值的基础上开逐次始加1,并形成C++,当然,C++是可以没有C而独立的,可以独立被学习的,它也有自己的stdc++lib,比如string等,IO等,并且还有stl

[4]: 也有人说它是参照ADA的模板语言机制来的

[5]: C语言的标准包括预处理,C本身和C标准库

[6]: 比如Jxta,它没有理由不用C++,但它用了C,它只是为了求得一种最小接口和效益的原因,使得同时用C和C++都能开发

[7]: 操作没有OS前和有OS后的那些,跟系统资源处理有关的,初级逻辑.




