title: C++与OO编程的缺点及局限
prev_title: 混合了函数式的语言手法
prev_url: 混合了函数式的语言手法.html
next_title: C++与桌面开发
next_url: C++与桌面开发.html

抽象语言的适合范围，及其缺点和局限
============================


/*!

\page 为什么只写这些?C++还善于用来作什么编程?.html

============= 为什么只写这些?C++还善于用来作什么编程? 

应用问题:文本处理(内存模型,文本处理,IO,SOCKET IO这些话题应属于C级的初级系统编程),科学计算,多媒体问题.虚拟现实问题,

给C++本身定性的重要起点是,它的内置类型是平台相关的,而且是本地平台相关的.(跟C语言一样)

所以从这个方面来说,C++的确是一门系统编程语言,但是它的UDT语义系统,又使它变成了混进了设计和复用的语言.这似乎有点模糊了C++作为系统编程的本质,因为一般高阶的应用语言和应用问题才需要设计和复用,但其实加入了UDT的支持和原C的主旨没有根本的矛盾.C++最主要是利用它的UDT系统来处理系统相关的应用(应用分系统相关的应用和非系统相关的应用,所以这里其实是在说“C++跟C不矛盾,它只是强化了的C,C++是一门关于描述系统应用的语言”,而不仅仅是C一样,满足于开发初级系统逻辑),.

(这就是出现了C,还得出现C++的必要)

当系统逻辑以UDT的方式来被处理时,它是基于经过了复用和设计手段考虑的,而加以了复用和设计的处理的系统逻辑,它就变成了某种高阶的系统逻辑.,必定有别于初级系统逻辑的.所以,要明白C和C++的这点区别所在.

首先,C和C++针对开发的大背景是相同的,都是系统逻辑,但C++和C用的手段层次不一,C能很好地用它初级的类型描述系统类型,C++ Better 了C,而且可以在Better了C的基础上,运行复用和设计的方法,这就使C++对系统编程的境界,进入了一种比C还高的境界,这就是系统应用编程(而C 是初级系统语言) --------- 不光是UDT语义的功能,还是Better C的功劳,它使原C中的一些繁复细节去除了.使C++迎合它作为一种“比C更高阶”,“比C解决的系统问题更高阶”的效果语言.

换言之,C++擅长于开发高阶系统逻辑(跟本地系统有关的,在被其它语言bind前的,那些开发).(比如Game,而不是脱离了平台的应用)

当你看到这里的时候,你就知道了C++的根本任务和它能很好被用于开发的那些问题和领域,但你进而继续看完本书第三本的时候,你就可以说你学会了C进行开发.

>我们这里不谈模板. Template是C++的uniform design lanuage level,语言层中的统一设计层,可以分为二大体系,泛型编程和元编程.当我们说到template时,它包含了OO,所以,template和OO不是C++中二个被分割的部分.而是高级方以低级方以手段的关系.

*/



C++与OO编程的缺点及局限
-----------------------

OO与过程范式的比较是C与C++比较的问题.

面向对象在复用工作方面做得很好(比如它提供了继承,多态,还提供了二进制复用比如COM,还提倡用类聚合代替继承而不是tear off,还出现了诸如设计模式这样的复用经验),但是这是相对现实生活的那一端做的工作,,然而它对于编程工具端(编译器)本身来说是不友好的(程序源码必须要进入runtime才能让我们看到这所有的OO里面发生的事,在编译阶段(一般也称为design - time)我们不能控制这些OO对于问题域的实现),我们应该在没有让程序进入某种具体编译器之前,,就让它得以被控制,而不仅仅是预测这些编译的文件进入runtime以后会形成怎么样的逻辑
也即,类的职责单位是类文件,这种机制有一些的缺陷性,问题域是巨大的,如果我们动手一项工程,我们不希望被无穷的细节所困扰(现实问题总要分解为一些类,最终要形成类文件,一般每个职责形成一个类,类体中的逻辑进入运行期的执行路径,这种机制是与执行系统的执行逻辑紧密相连的而不是基于人的设计),我们希望有一种介于编译器和现实问题之间的更大的整合层来考虑事物(而不是一个一个的类文件),,也即,我们不需要考虑现实问题到类的实现路径,我们希望在设计期就考虑现实问题到一个“比类还大的”,“更接近现实问题”的逻辑层上去,再由这个逻辑层到最终的类实现路径(比如单例模式,就是指代设计中只能出现一个实例的逻辑实体,这已经十分接近设计了)

而在我们的方案域用于表达应用的抽象元素只有类是最大的,库是最大的(即使是框架也需要了解很多东西),这种细小性决定要去的地方,要达到的应用还很远.软件活动是一个真正体现人类心智的地方.是一个真正工程级的活动[1^],个人几乎不能独立完成(程序员作为实现者可以不懂大设计和系统级的设计,但设计师要管).

>程序的抽象可以无限发展，基于设计目的的抽象工作可以无限发展,接近到最终的应用，但库不一定要写那么多，一个（库）设计可以是间接映射到“利用该库完成最终应用”前的某一阶段的设计及抽象考虑，把其它的工作放到库外完成，一个库只应提供机制，抽象策略不应全考虑进来，这就是分离设计的最高境界。语言的抽象还很初级，OO只是语言，它的表实际抽象还很低级，你无法从仅是std::dosth()很好想象它应映到你实际需要的某种逻辑，这充其量只是语言的功效。

**面向对象的缺点不在OO本身,而在于人们对OO的滥用**,这主要体现在人们对继承的概念的偏解上,设计模式指出,对于复用,我们应该尽量用聚合而不是多层继承(单层继承和对等继承还是允许和鼓励的),JAVA不支持多重继承,一般也提倡不超过五层以上的继承(然而在策略的提出中,多重继承却起了不可替换的作用)

不可复用问题的出现绝对不是面向对象才有的问题,,面向过程更甚,实际上对象机制的确在一定程序上也促进了模块间的藕合,然而设计良好的对象构架可以很好地为以后的更改预留空间,并且似乎也并没有更好的比面向对象更好的机制出现,比如完全面向复用语言,,极端化地求完全可复用性又是不对的,因为复用这个概念本身完全是一个相对的概念,,,考虑一下MFC,它内部的各个组件都不能拆开来用,只有在作为MFC这个整体的前提下各个组件才有效,在这个意义上它是不可复用的,,,然而,就其内部来说,当你在MFC下使用MFC编程,你真的可以做到重用其中的一个组件可以避开不使到另外一个组件(这就是说,可不可复用从来都有一个最小可复用单元的概念存在),stdafx.h就允许条件编译和预编译(stdafx.h是VC给你的标准预编译头,它可以通过project wizard为你清理出一套专用于win32 app,win32 mfc app,win32 console..etc的文件头,当然你也可通过project.settings,C++.precomplierheader来定义自己的预编译头),条件编译常被用在一些大型库和软件系统的编译上,比如一个由很多可plugable的Dependencie组件组成的库,常常提供有具体的宏条件编译来让你自定义哪些组件要被编译进来,哪些组件不被编译进来,而每一套编译出来的库都是有效的,,还比如一些用到include了dx头文件的库,有时为了让没有安装dx sdk的用户能正常编译,就提供有宏让自用户选择不inc进这些东西.

对于抽象，构建在OO之上的设计模式却导致了越来越深的复杂性,这是因为人们没有想到OO以后的思想世界和现实世界应用,其实比OO这种形式要复杂得多,比计算机内部的离散形式还要复杂得多,换言之,OO并非一切,相反,在一定程序上提供方便性的同时,在另外一些维度和应用上导致了另外的复杂度,因为思想永远是复杂的嘛(杀鸡用了杀牛的刀)

然而这其实是抽象的方便性也是抽象的另一面，带来更多的问题所导致的，，所以，复杂性是不可避免的，然而，人们往往只取抽象给人带来的简单性。

>对于学习曲线来说,设计模式是OO范式刹车的标志,因为它拉大了计算机与要解决的问题的沟隔,怎么说呢?OO 以后的OOP范式太多了,有设计模式,框架等,其实计算机内部的离散形式是死的,但用编程语言解决的目标问题才是巨大的(实际上OO加重了编程的负担和新手的入门难度,用OO来描述现实世界只能做到"对象"层次,如果向模式,向框架发展就越来越庞大和力不从心了),只能越做越复杂,有了OO就应该适可而止了,不要再发展OO以后的东西了,比如设计模式,比如框架,因为OO以后的东西其本质还是计算机内部的离散形式,这二者南辕北辙,造成的结果是适配这二者的负担太重了,叠在裸机上的逻辑太多了,有OS,有虚拟机,有运行时,有PE载体逻辑,有解释器,这只能给机器越来越重的负担,这是第一,第二,计算机底层的离散形式本身就是固定和简单有限的,自从有了OO之后,编程逻辑发展为远离计算机底层(向人靠近)的高级逻辑,而现实问题用OO来解只会越来越复杂, 不如用固定的编程范式,,比如C语言规范来表达,这最大的证明就是单例,c可以用极为简单的形式来表达单例,而JAVA要用一大堆OO的思想,,

一个问题出来了,,抽象显然是为了简单化,但是这是对系统编程环境的简单化,,在高级层次会造成更大的复杂,但至少脱离了大量需要原来人脑去维护的细节,　人们只需要掌握大概就可以去复用了(接口),,,这是一个很大的进步,,,而且有些被实现了被开发过的东西和轮子可以直接被拿来复用,C代码却要基于平台的考虑修改大量细节,这种修改的代价超过了太大,就没有可复用性了,,,所以无论如何,C++比起C,,使人们掌握细节和系统的机会减少了,但需要人们掌握设计和复用上的知识多了(人们更专注应用领域)．而且在这个时代,由于JAVA语言这样的语言的出现,语言标准得于统一,因此可复用性首先不用考虑语言本身,更而且,JDK统一,SUN的J2EE规范统一,,可复用性就成了人们之间的契约文化了,可复用性的地址会越来越下降．C的难点就在于系统本身,, 系统细节和语言细节都过多,,造成人们掌握它的成本过大,但C的代码没有绕OO的弯子,跟系统逻辑几乎一致,因此效率很好.

过度抽象不是提出一个简单模型,而是在封装的基础上提供了一个很复杂的模式,甚至超过了人们学习C和系统的那些知识,那么这种OO模型(或称呈现的供可复用架构)就是不成功的,

OO的缺点需要在OO上整合更强大，更抽象的OO手法来解决，比如DP,interface base oo designing

c#,languages based on .netvm
-------------------------------

高度集成的dotnet意味着高度重复，它只是将本地开发的东西重新做了一遍 


[^1]: 设计无论是大体设计,还是详细的设计,都是语言依赖的,说是语言独立,实际上只是一定程度上的独立.而且,设计师对于设计的展开,又是问题依赖的,需求敏感的,所以,软件问题的大体,其实是个工程问题.