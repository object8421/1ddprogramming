实际上,数据结构与算法解决的问题是整个编程中最有限,最底层的那些问题,(它没有涉及到设计,用户等编程三层架构中的最重要的后二层),它只解决,对于计算机(注意这五个字)在组织内存,支持对这些内存中数据进行操作(排序,查找)等有限问题的问题[2. 当然,我们说数据结构还可以提出新的内容,但它的根本学科任务不会变],它仅仅能很好解决这些问题,所以说它是面向计算机的功能性方案[3. 一个在理论上完美,但运行效益超过10^8的算法是无效的算法],是计算机的科学,解决对于计算机来说最为迫切要解决的那些问题,比如效益敏感类问题.

如果放在整个大编程中被讨论,那么它是颇为有限的那类东西.
###### 数据结构与算法的关系
算法分一般算法和通用算法，我们在这里讲的数据结构与算法，数据结构是主体，通用算法是附属（仅是查找，排序等），但在一般算法体系统中，具体算法是主体，数据结构是附体。泛义的算法二字是指代一种数学概念，一种用科学（特别是数学）来解决问题的方法。
你也可以这样理解，算法是针对数据结构的,如果说数据结构是计算机的结构,那么算法就是用来解决计算机问题的（数据结构和算法是计算机的而不是编程语言的科学,这个说法就来源于这里).
从开发(者)的观点,我们可以把OS看成是提供API的软件抽象机制,同样从计算机开发领域的角度看,我们可以把数据结构看成是算法的附属,,因为数据结构是源于算法的,而数据结构是开发中的数据抽象,,,,因此作为从开发眼光来看的数据结构是算法的附属。

数据结构与算法是属于计算机[4. 承载计算机科学最最根本的东西,是数据结构跟算法,而不是语言(语言只是表达工具).难怪宏大的《the art of programming》写的全是数学和算法等内容,跟语言相比,语言本身并不能解决一个问题,它只是反映事物的工具,跟解决问题没有绝对的联系,数据结构与算法,才是“真正能解决”计算机问题的手段与技术.你看路由器算法,这些低层的东西,都是数据结构与算法发挥作用的地方.]的,而不是程序设计语言的(因为它[5. 支撑算法理论的数学基础与证明(复杂度,可计算等等)]在纯数学上也成立[6. 当然,像递归这样的东西,需要被离散化成嵌套的过程]).更多在出现在计算机系统实现上.比如操作系统实现,编译系统,计算机图形上.是一种实现模式.

数据结构用于编程
-------------

###### 数据结构与数据抽象
一切语言机制都是为了抽象,,,抽象真的有那么重要吗?? 对数据的抽象必要吗,,,

什么是真正的数据,,什么是抽象了的数据,,,,数据类型就是数据的模板,,计算机和语言用了什么样的形式语言的形式去指代和控制他们?

如果说数据结构是非语言级的设计抽象(它也是一种实现相关的设计抽象),那么高级语法机制就是语言相关的设计抽象(是一种代码相关的设计抽象),而我文章中最后一部分谈到的设计就是工程相关的设计抽象(相对实现相关,代码相关,这似乎可以称为结合了二者的综合的设计抽象了.)..

算法不是设计,(算法更多的不是代码逻辑的设计,用最小内核的流程控制比如C都可以实现算法跟数据结构)。

算法并非代码逻辑,而只是附属于语言和数据结构学交界的那些东西(算法是从属数据结构的,, 数据结构与算法问题比如排序等是紧密相连的,相互支持的),只有设计模式才是代码逻辑和代码抽象学。

我们在前面谈到了类型与数据，那时我们就谈到，语言的类型机制为计算机运行更抽象的数据提供了基础，那么这里就是开始介绍这种抽象数据的地方了

数据结构的“数据”可指计算机的简单类型，或抽象了数据类型(因此数据结构的准确含义是“计算机开发领域中的数据抽象学”),汇编不需要变量是因为程序员包揽了内存分配,而高级语言提供类型抽象,和变量,变量的内存分配由编译器或运行时完成,因此可在这个基础上发展基于靠近人的抽象数据结构,而OO既是对数据的一种抽象(当然,它跟数据结构对数据的抽象是站在不同角度的),也是一种对代码的抽象

首先,数据结构在type的基础上进行抽象,,它看不到汇编的位,只是考虑如何将type翻来复去地变换形式进行使用,而算法,看不到汇编的指令,只是考虑如何用高级语言的语句来操作这些数据结构,“即算法是对如何操作数据结构的抽象”因此数据结构和其上的操作称为adt,

而算法和数据类型是建立在type和施加在type上操作的更高级抽象..是语言,大凡具有类型机制的高级语言通用来的,用来设计应用和解决问题的方法..

数据类型Type是高级语言对汇编直接操作位的“位”的抽象,,而这句话中的“操作”,,也被高级语言抽象为施加在这些类型上的操作,比如,对于整型数,有相加,但是不能对整型数执行浮点数的运算,虽然程序员方面是直接使用Type,但在编译器方面,其实对应的还是位,编译器为程序员隐藏了内部逻辑.使我们的编程工作能维持在使用类型而不是机器语言“位”的高阶抽象层次.

一切都是抽象,数据类型的提出本身就是一种抽象,而至于提出什么样简单类型也是一种抽象,数组,记录类型,联合(要说有,其实还有递归类型),都是C的复合类型,实际上C只有int,float,char这三种类型,高级语言提出这三种类型是因为它首先是对机器类型的一种封装,这三种类型抽象了我们的现实事物.比如int,float对应数值意义的抽象,char对应字符意义的抽象..
类型机制几乎是从讲解一门语言的语义就开始涉及了,这导致了在使用此语言的一个实现时进程编程时,,如果没有弱类型机制(我们知道,强类型机制几乎是保证系统编程质量的要求之一,相比之下动态类型太偏向程序员而远离了需要严格控制类型的底层),那么我们编程处处就得涉及类型机制,变量,直到对数据结构的掌握..

>语言内置类型一般包括在语言的运行时中,是该语言源程序代码跟平台(OS,CPU)的接口,,运行时驱动该语言代码映射到此平台逻辑对系统编程,,就是用"平台能干什么事情"..来构造应用...一个一开始就学JAVA而不了解低层的人,不可能深克知道如何从低层驱动计算机构成逻

一句话,type和type上的操作是抽象汇编的,,那么,数据结构和其上的操作是高级语言站在type和type操作上的抽象,一者是高级语言面向汇编,一者是高级语言面向高级语言的type.

函数是这里最能体现这种抽象的机制,首先,函数接纳实参或数据结构这些抽象,,函数体内的代码是“施加在实参上的操作的整合体”这样一种抽象..
###### 数据与数据属性
理解数据结构前理解什么是数据和数据节点,以及它们的属性,这是很重要的,但很多人忽略了它,以至于有些教科书都混用Ordered与Sorted,实际上,对这两个概念的理解至关重要,对它们的澄清工作是一本数据结构方面的书最应该首先完成的.它直接关系着数据结构学中诸多基础概念的导出.那么什么是数据和数据结点呢,数据节点又是体现了什么样的重要属性呢?这些属性(比如刚谈到的ordered,sorted)影响了这些逻辑数据结构在以后被拿来讨论时的哪些方方面面呢?
数据结构绝非仅仅数值数据结构.数据结构不仅用来研究数值,节点数据还可以是任何类型type.或ADT(从拥有类型的语言眼光来看,一切用代码结构能编码的计算机数据都可以是节点数据),数据结构研究的数据是施加了一定限制的数据而绝非广义的数据,这主要体现在数据的二个属性上1.存不存在order还是sorted,2.有没有key value的分别,还是根本就无所谓这二种属性.
首先,数据结构能处理的数据节点是逻辑上分存不存在order的,如果无所谓order,那么集合就是这样一种逻辑数据结构,如果有order,那么就可以是线性List,层次tree(我们呆会会谈到order为何跟tree是有紧密联系的)这样的逻辑数据结构,
另外,计算机能处理的数据节点是分存不存在Key Value区别的,如果无所谓key value,那么其中每个节点都是数据实体,如果存在是key还是value的区别,那么这种逻辑数据结构中的数据可以表达为一个key,可能是一种关联式的逻辑数据结构.这就是计算机能处理的“数据‘和它能形成数据结构学这样的科学所加的二个属性,下面我们详细阐述之.
Ordered表示一个接一个,顺序不可改变,如果被改变(比如一个元素后接的元素不再是以前那个了),就不再是以前那个ordered List了,但它依然是ordered的(它的意义在于这里).所以如果一个unosorted表被sorted过了,它肯定不再是以前那个ordered List了,只是因为它当中有些元素的ordered位置换动了,所以称它是一个新的ordered且sorted的表.
不妨把Ordered严格称为循序(而不称为顺序),而把Sorted称为排序,那么我们就从字眼上对这二者进行了很好的区分.(当然你可以这么做,但为了统一起见,下文一律用顺序代替循序的说法.)
什么是key value呢?键可以是一个记录中的某个字段,或字段的组合,单字段的以这个字段值作为整个键..关键字相当于字典中的单词,,而数据项相当于这个词的词义,造句,等全部的词条信息,这样说你一定不会明白,说实话我第一次看到这样的说话也没能明白..实际上就是说,我们要查的是关于某个词的词条义,音等,,但我们是通过某个单词找到该单词的词条义,音的..在字典中单词和其音义是一同被存入字典的,都是(某记录的)数据项,但单词是作为键的数据项.

明白了以上这样我们就可以理解一种特别的数据结构了,拿典型的hash table来说吧,首先就其key value属性来说,如果存在key value的区别,就是hash set,hash map之类的东西(因为hash set,hash map是关联式的数据结构),,这跟属性中的第二点有关...第二,它的hash,是针对数据结构中的数据来说的,hash一定要是hash个数据结构出来,而hash数据结构中的数据是无所谓ordered还是不ordered的(hash table,map,set它们根本就是uniform的),而一般数据结构是非uniform的,这满足第一个属性.
研究数据结构我们目的从来不是为了得到那些底层的东西,基础的数据结构,,而是为了得到更抽象的东西,比如树,图,甚至是树图之上的,优先队列,高级优先队列,集合,多重集,区间,等.
但是抽象总是一步一步来的,在数据结构的讨论中,我们总是从最普通的情况谈到施加了各件条件和限制的情况,比如有向图是无向图的一种特殊情况(施加了有向这个条件,而无向图是一种更一般的图,因此图论中一般是谈无向图及遍历等操作,再谈有向图及其特性.最后特别是有向无环图DAG).
逻辑上,数据结构的最高境界是集合[7. 集合一不要求它的元素同型即是否typed,甚至可以重复,二不要求元素间存不存在ordered或sorted关系,即没有施加任何条件和限制,或者说对这些限制不予考虑,无所谓这些条件与限制],所以通常用集合来形式上定义其它的逻辑数据结构.数据结构包括数据元素本身和数据元素之间的关系这二方面.所以讨论时通常用数据元素构成的集合和数据元素之间的关系构成的集合为基础来定义和导出其它的逻辑数据结构.

真正的数据结构其实只有二种,表和树,因为按第一点属性来看,前者是线性order序,后者是层次order序(我认为只有这二者才是划分和形成概念的标准),如果说硬有第三种,那就是无所谓order序的,即集合,(传统中一般把逻辑数据结构分为线性表,树,图,hash)但我觉得集合才是取代图的概念,而不是图,图只是节点间的逻辑关系居先,一般谈到ordered就是前驱后继的由来,而节点间的连通关系根本不是ordered.

为什么树的ordered会成为划分树所属的逻辑派别的依据呢?比如二叉排序树它并非二叉有序树,为什么要进行这种区别呢(你可以在下一节找到答案)
###### 用ADT来表达数据结构
在讲解算法与数据结构的教科书中(特别是C++用来表达数据结构与算法),有一种语言抽象机制屡屡被谈到,这就是ADT.
<ul>
	<li>从simple data type 到abstract data type</li>
</ul>
C时代是POD类型与过程式语法，这个时候数据与代码是紧密相连的,再后来出现了模块化但是面向过程编程,这个时候,利用临时自动变量可以降低子程序间的藉合度,而当当语言支持UDT和ADT系统时,出现面向对象后,我们完全可以先定义一个预对象(什么是预呢,就是说这个类被写出来的那一瞬那,它并不像面向过程子程序一样存在某个一个rotuine执行路径中,而是作为预定义的一个程序组件,除非你定义并引用了一个该类的实例,这个以前定义的类中的代码才会进入某个执行路径),这样,模块化就做到充分了,即类,一个类是对象是预定对象变量与对象实例(注意这二个概念,变量可以是一个指针,是声明性的并不分配内存

类是真正的数据,,比类的成员数据(POD,C的plain old data,数据结构学中,我们从来不是大量需要数组,链表这样的底层ADT,而是需要更抽象的比如堆栈队列,红黑树,hash map这样的更为抽象的东西)更能代表数据的意义,我们的程序就是一个一个的数据,类是用用户的观点来表达现实生活中出现的各种各样的数据的最好方式,因此会有面向对象数据库的出现(数据库技术中,关系模式的下表达的数据给人的引象似乎是它是为专门的数值数据而建立的)
ADT就是指封装了事物属性跟作用的指代物本身,它的属性和作用是ADT之所以为ADT的意义所在.即数据类型不再是基本类型,而是结合了数据跟代码的抽象了的模型(是一种抽象数据类型)
<ul>
	<li>关于对class的理解,重要的是要分清这里面其实有一个代码抽象模式和数据抽象模式的区别.</li>
</ul>
类实际上是一种数据抽象(也是一种代码抽象),而不是一种数据结构,,因为它将代码抽象为一个一个的“数据模式”,即将C++这样的通用语言[8. 系统编程大量用到处理字段,数据结构,变量API,这些细节(因为历史上,它们既发挥系统开发的任务,其实还发挥系统实现的任务),而python这样的封装式(这也就是“脚本粘合”的意思)系统开发语言,只提倡简单的接口应用.并且,它对于win32等本地系统,是unnative的关系.]增加DSL词汇,让它成为DSL,使之可以表达Class Cat,Class Pig,阿猪阿猫阿狗诸如这样的领域词汇,所以类是一种数据抽象模式(解决编译器向计算机提供编码实现的数据模式问题,把词汇抽象为语言的一级first class数据,即UDT[9. 说到UDT,user’s data type,说明它跟compiler’s data type对应.],ADT这里面D的意义),也是代码模式(解决对于语言的代码抽象问题,计算机操作什么样的代码来影响这些逻辑和数据),而数据结构学是一种实现模式,而不是代码模式.

数据结构学与代码结构学的区别,是解决问题的问题和解决语言映射问题[10. 计算机算法能解决问题，如何实现在计算机上的问题，但编程不能解决问题，它仅能解决如何映射的问题。]的区别,两者在不同抽象层次,这就是为什么数据结构可以用任何语言可以用基本流程实现也可以C++的类来实现,因为数据结构学跟它如何用一种代码结构来抽象是没有直接关联的,前者是如何解决问题的抽象[11. 是一种脱离了语言的映射,即我在1中谈到的设计),后者是代码问题(如何面向用了类的可复用目的来进行对具体语言的映射,即我在2中谈到的实现,人类的话动中,2往往处在1的未端].



抽象类型，复合类型，以及对用户自定义类型的支持
-------------

对用户自定义类型又是一个更高级的发展. udt允许语言使用来自用户的类型(就跟使用内置类型与语义一样)

UDT是用户数据类型,新建数据类型,类,这是一切对象的基础,归根结底程序是操作和数据,,但是程序语言发展到现在,现代的程序只有一种元素那就是数据,和数据接口,(操作和数据在现在被数据和接口代替)因为面向对象已经把操作和数据都封装起来作为“一般数据类型”(这就是class,通常意义上的typename就是class)一个INT是一个数据类型(如果INT和ADT都是对象,那么就可以为ADT定义跟INT一样的支持动态bind的算术操作符,如加减,自加自减),一个vector是一个类型,一个自定义的class也是类型,甚至一个函数也是类型(因为存在函数对象的说法),过程对象等等,即,,在面向对象的技术规范里,一切皆对象数据.下面开始把数据类型说成datatype
但是,无论是简单类型还是抽象类型,编译器内置类型还是用户扩展内置类型,异或是自定义类型,只要是类型都是对数据和代码的双重抽象,即不但是对数据的抽象也是对代码的抽象,所以类型不单是对数据,它也同时是对代码的抽象数据(的产生模式,提出类型,是制造编译器的一种设计手段而已),对象变量是抽象数据,而冯氏开发是数据化模式来解决编程问题的,所以OO作为一种开发范式,优先是指面向类型化,然后才是一种data,因为类型化也可以是类型化的方式来抽象组织代码,而不是仅仅是数据,否则面向对象这个说法只说到了一面[11. 但是有些语言也把类型同时当成数据,比如this方式引用类型本身,类型也有成员.就跟一个这种类型定义出来的数据一样.它们都在内存中存在一份表示.所以也可当成数据.], 高级语言数据与代码的区别在这里有了新意义 因为类型也可以是对代码的抽象,所以动态类型语言是动态语言(能动态改变代码结构的语言)

动态类型，无类型
-------------

动态类型语言不是没有类型,而是其变量在运行时可以自由转型.范型是建立在为一个通用类型上的操作的手段.类是一种定义类型的手段UDT...因此除了简单类型之外,还有自定义类型..否则仅仅靠建立在基础类型之上的复合类型还是不够(C++提供Class这种UDT并导致了基于对象和面向对象,这是C++区别于其它语言最尤为可以拿来类比的特征). 动态语言是指语言的运行时,其运行环境是动态的,,新的函数可以被引进,,等等 动态类型语言,是指类型可以运行期被改变的语言,,一般来说,类型系统是一个语言的特征之一,如果它都可以是在运行期是动态的,那么该语言就是在运行期动态的 弱类型语言,,,语言有类型,,但是类型之间的转换并非严格,,,字符串指定可以转型后用作数值型 无类型,,,无类型是指类型是不需要显式在写代码时声明给它一个类型的语言,,在运行时视给它的值确定类型,而且还可以再变动,即所谓的duking type,,,因为没有类型,,所以就没有变量(因为变量就是类型的代表撒),...没有变量只有值,,,值决定一切,,给它一个鸭子走的动作,,如果它像(而不是去查它在生物上的族谱),,那么它就是一只duck

类型相容与推导法则 编译原理告诉我们,类型机制是编译期的一切,编译器只认类型,编译器的本质就是一种类型识别与处理系统,所以说它具备不具备图灵特性,因为它首先是一种类型识别,这在编译时的三个阶段(语法,词法都是识别)都体现出来了,这是由编译器的图灵本质决定的. Todo:这里有问题

统一的数据结构与代码结构：类型
-------------

从这里开始,编程的意义发生了一个质的变化.

第一章中我们谈到,编程的字面意义就是预编好(计算机运行用的)步骤,步骤化,也就是程式化,指令就是计算机步骤,只是这个步骤可以被不断高级化,最终脱离指令和编程的层面,分别变成语法和语义,甚至能映射应用逻辑

对于代码这个词,我们把它解释为:在程序中组织数据和代码的方式(递归定义的).语法,即面向使用这门语言的程序员提出如何构造代码的形式,它的背后是语义.一个源程序本质上是一些语法形式上体现的语义.程序员写的是语法但本质上是基于语法对应的语义. 对于语句，编译器的二大出发点在于“构造语法”和“建立对于逻辑的表达形式”,语法即组成代码的形式,

然而这二者是活性的，以上二者是交互发生作用的，栈内数据和栈式代码不分彼此，它们都属于栈式内容，当从数据的眼光看时，栈式数据和栈式代码都是栈式静态内容(它们是数据)，当从代码的眼光来看时，栈式数据和栈式代码都是栈式活动内容(它们是代码)。而高级运行平台上的高级语言中的类型和语句，在编译器实中和程序写作上,这二者被统一表达成了类型。

而在高级语言编译器实现和高级语言编程中，类型和语句也是不分彼此的。

>构造逻辑的表达形式,编译原理级，一切代码结构都要参与“表达式处理”，其中就有对函数，一般表达式，语句的处理。编译器一般用类型来表示(数据是程序层面表达逻辑的形式),类型定义了逻辑以什么表达形式存在,第一类型就是编译器直接认识的逻辑,类型本身没有语义(定义它的声明语法形式,和赋值语法,才有语义).

在语言级构造逻辑时，对语法的运用往往运用到使用类型逻辑或数据逻辑,类型往往封装了代码,而代码必然基于某种语法及语义.代表一个逻辑上的抽象.

所以，类型是一种活性的逻辑表达器，它其实是一种同时作为抽象了的数据结构和抽象了的语句的“统一体”。
**于是，类型不只是数据或代码，我们不妨把所有这些称为数据结构和代码结构。**

冯氏上的开发，根本要回到“数据驱动”和类型设计上，“数据结构”是第一位的，“代码结构”是第二位的；


大多一门语言都提供了流程控制,,形成了各自的语言关于流程语句的语法要素(更高级的跳转机制有异常,等),,

设计无所在不在,即使在C那样的紧实现的语言中也存在设计.. 一种设计是代码抽象,代码结构,也是设计的一种.

>设计即逻辑的逻辑,而且是面向人的控制逻辑的抽象即设计的第四种意思是让抽象以人.需要的方式进行组织,即人影响抽象的能力, 实际上设计无所不在,从你写第一行控制流程代码开始,你就在设计了,只不过是隐式的,机器并不会流程控制,是语言赋于你能以人类看得明白的流程设计逻辑向机器发令的.如果说流程控制设计是细小的,那么OO是一种显式化的设计,当你用OO来写代码时你就在设计,虽然你写的是实现,设计与实现间无明显分界,,,你照样是在设计,因为你用到了OO的三重思想,继承,泛化,封装,,这就是控制逻辑的逻辑,,是设计因素.
