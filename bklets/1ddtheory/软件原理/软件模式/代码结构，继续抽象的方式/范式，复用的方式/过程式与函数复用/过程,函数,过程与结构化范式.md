/*!

\page 过程,函数,过程范式与结构化.html

============= 过程,函数,过程范式与结构化

除了语句外，在过程式语言中，另外一种代码结构，就是函数。它是过程式语言最重要的结构之一，因为它为过程式的结构化提供了最重要的设施支持







------------- 从顺序确定的指令式到结构化的语法式


从此，顺序式的执行结构和选择式的会编编程方式被语法式的函数串联式和过程式的语法编程方式给取代的，程序员要做的，就是让自己在这种平台上习惯起来。比如，c例程,是系统运行时中的最小代码结构,也是过程程序员直接接确到的代码单元.

过程开发范式是由模块化设计的要求来的,这个层次的过程式是对平铺程序的一种子化,形成子过程. 我们要摒弃顺序化的观念,进入过程式或OO式的非顺序式观念.因为这是模块化的要求.要习惯OO而不是过程,是指:你最少得用C++写C系程序.最起码用C++的OO,而且任何规模的程序,无论巨细都要写成class.(这样做,主要是为了复用和重构时,能以OO为前提).

>指代编程风格的范式,其实是由计算机处理数据的方法和内部逻辑所决定的,机器级的执行路径逻辑决定了它以什么样的方式操纵其内的代码与数据.,比如函数语言就是由lamda演算得来的,函数语言可以用一种其它范式的语言不能用的eavl()过程
计算的原理是一种图灵机的离散形式,,,因此是命令式的,,,只需一个入口,和一堆要处理的数据,就能串行得到另一个结果(这就是串行形式算法,计算机的功能就是状态的改变,未来出现的并行计算和多核会导致编程出现并行范式),这个结果可以被另一个串行处理作为中间结果,,,计算机(堆栈机)或虚拟机(JVM的软件机器)是构建在这上面的另一层抽象,在这种开发方式下,要注意很多算法,,,离散的算法,和数学的算法,拿递归跟迭代来说,迭代就是计算机处理的方式,,,是行动导向的,而递归偏重于目标,,偏重于人的思维,,比如函数语言中,,就用迭代比较好, 而OOP中的语言中,,就用递归比较好因为计算机离散形式处理迭代好,迭代需要一个循环变量而递归不需要

------------- 过程范式与模块化


模块化的思想有什么好处呢?模块化的思想,就不是以整个设计作为书写这个源块的依据,而是想到一个功能,就做成一个模块.**所有形式的模块化的本质,都首先是为了分块设计,然后再是其它什么目的**.只要定义好未来的接口就可以了,这样,设计就成了分离的.那种整合式的设计,是不必要的.



[^1]: 这里的程序指步骤

*/


组件与扩展

用户编程与扩展支持



title: 如何更好地解决可复用问题及其它问题
prev_title: C与系统编程的局限
prev_url: C与系统编程的局限.html
next_title: 高级平台与映射-虚拟机,抽象运行时,面向程序员的封装式,抽象式编程
next_url: 高级平台与映射-虚拟机,抽象运行时,面向程序员的封装式,抽象式编程.html





如何更好地解决可复用问题及其它问题
=============

在本丛书的第一部分即将结束的时候,我们将谈一点对本丛书第二部分承前启后的东西.

从本书讲解至今,编程实际上一步步在解决计算机与语言的关系,它很少(即使有,也是有限地)涉及到对于人和计算机开发之间的关系并解决它们,这样的编程称为实现编程,因为它是一种功能性编程,它首先解决的是承载起编程的那些基础实现部分,只有这些问题都解决了,才能着手解决开发跟人的关系,这也就是本书第二部分要谈的事.当编程广泛地加入了人的设计(对系统的抽象,对语言和语言机制的抽象)之后,这样的编程不再是初级实现编程了,而是抽象了的编程.
问题的第一步永远是解决抽象问题（稍后会不断提到这个问题）其次是解决复用问题，这是个无比实际的解决关于人的问题，无论是在个人手工作坊时代,还是多人共工的软工时代,(源码的)复用[^1]都是一个大问题.

移殖的全称是"对运行移殖".因为程序运行不外乎二个东西,一个执行时,一个运行时,所以程序移殖跟机器和OS同时相关. 是个综合问题。
过程式范式就是这样的解决方法中的一种，它允许人以高级的手段描述系统逻辑,它是一子例程抽象,如果说存在数据抽象和数据结构,那么函数就是代码抽象了,以它的各种变体建立起来的语言内机制,比如闭包,协程,递归等,就是代码结构.而过程式范式





可移殖与可复用
-------------

在相关书籍中,存在很多相似但其实有很大区别的概念,比如可移殖与可复用,接口与实现,接口与抽象,下面试区别之.

C解决复用问题跟其它语言解决复用问题自然当分开而论,因为C不是一门强复用支持语言,而其它语言,有显式的设计支持,和复用支持.因此,对这二种开发体系基于复用的要求,应分别对待并进行讨论.而且,它们面对的平台基础也不一样.


平台，库,语言与可复用
-------------

###### 架构

接口是实现的原型,,一般谈到实现,就是一个复杂系统中的终极未端逻辑,意指其不必为复用留有余地(因为复用就是利用接口作进一步的抽象,复用跟接口密切相关,所以实现也指不必为接口设计作余地),一般谈到接口,意指为下一步的抽象提供统一的原型和形式,即为如何复用提供设计,

什么是上下关系呢?就是说谁更靠近应用谁就是上,平等关系就是它们作为中间逻辑靠近应用的程度是一样的(这主要是因为它们为共同一个库提供逻辑,而那个库更接近应用,比如这里的B,C对A的关系) 如果开发中存在造轮子的工作,那么很多逻辑都在这里面,,就拿开发游戏引擎来说吧,引擎部分总是要考虑进很多逻辑,有时是复用别人的库,有时是很多预考虑的逻辑,有时是设计模式方面的逻辑,考虑OGRE就知道了.
我们在这里反复提到架构与实现,那么到底什么是架构呢,广义的架构就是中间逻辑互饰以构成最终应用的过程中,出现的一切中间逻辑间的关系(无论这些中间逻辑有没有被封装成为库)这就是架构,,,狭义的架构就是指反映设计中某种物体模型的逻辑层次(比如我提到的GameGeneric由表现和世界逻辑组成云云) 比如上图中,中间逻辑的有穷互饰就会形成最终应用逻辑,但是中间逻辑这个说法永远都是相对(于最终应用逻辑)说法,越靠近最终应用的中间逻辑越是高级逻辑
要知道,,抽象达成到最终应用中,,需要设计的接口(这里主要指函数级的)精度和量度都是巨大的(可以用单逻辑的类文件,也可用库来集成一些逻辑作为二进制的中间逻辑,但是如果是使用别人的库,,那么往往需要作对它的引入逻辑,也即对这个库的使用逻辑,,也即你自己的接口才是你的应用主体,别人的只是拿来用的(并形成你的应用的接口),,比如Yake对其它的库的引入逻辑),为了未来的更好复用性考虑,越远离应用逻辑的接口,,对它的设计应尽量考虑接口上的放大化 GameGeneric向你透露面向游戏和脚本级开发者的那些接口(包括它自己的一些逻辑,和一些对库B,C的封装逻辑也即入接口逻辑,库A向用户封装了B,C的细节而提供一个大接口给用户使用,当然库A可能也有它自己的逻辑和架构),这些接口是直接面向高阶应用和开发的需要而创立的,既然GameGeneric建立在B,C之上,那么在引用A的时候(利用A进行编码实现或在其上面架构更高层逻辑的时候),B,C是不是变得无可访问呢?不是,我们其实还是可以在这个步骤中访问到库B,与C的内节的(库的组合逻辑绝非一方屏蔽一方而是一方对一方的归纳简化和扩展导出).
这是为什么呢?因为大架构是供你使用架构下的细节的(这后半句话才是重点),,大架构只是逻辑归约以更好面向程序员,它是逻辑简化而非逻辑替换,,而程序员最终要引用的逻辑是架构下的细节逻辑..
**从抽象的眼光看,程序就是逻辑堆栈,编程就是抽象堆叠.并慢慢接近应用的过程**
我们知道,程序都是逻辑上的堆栈,这就有了直接开发与间接开发,我们可以在os sdk这人中间层次上直接写自己的应用,也可自己发明中间逻辑,轮子,,也可直接应用别人发明好的轮子(这就在接口上受制于人),因为轮子往往是库,而那附带着设计. 以一种不太严格的说法来说,所谓程序,就是逻辑的不断变形,在不同的维度层面上变换,把一件事转来转去,最终叠加到的那个层面,就是真正的应用,,,是的,,明白这些有什么用呢??但是反过来想一想,,如果连这都不懂,,,那么那才是你的损失之处呢^^(这本书的使命也就在此)

###### 语言

不幸的是,语言机制也会造成不可复用,一份具体的语言源码,一份具体的代码,总是综合着,写这份代码对问题的描述,和对设计的代码上的直接展示,比如模块就没有函数来得可复用性强,然而复用从来都是相对的,存在一个比较时所采用的最小考虑单元,仅在C++语言内部而言,模块是可复用性很高的,在所有语言面前,函数接口和过程式开发无疑是复用性最大的..这就是linux之父跟别人争吵的源头所在.这也就是说,C++的抽象性能反而带来了不好的地方,越抽象的东西越会阻碍可复用性.

一个c的高手可能不懂(可能是只倾向于使用一种范式也可能是懒得管源码复用方面的东西)。这时。他写的东西中可能由罗列了单一的大量数据定义和散乱语句构成的函数的方式构成。

模块化也是一个重要方面,设计中的抽象过程固然要求模块化,但这决不是抽象的终点,,因为有时虽然模块化了,但是模块之间却偶合了.所以,科学的对于问题的抽象应该是模块化加松偶合的过程.

###### 移殖问题

**可复用不是指修改而用[^2],而是倾向于不用修改也可以用[^3],重构就是这样.**

有编程就有复用,扩展设计接口和扩展实现接口都是复用,即使是在自己的源码里工作复用都是一样的.复用的言下之意就是:(主动)预留接口地编程,为以后更好扩展埋下好的伏笔
可复用问题的由来一是实现的不能可复用 - 比如平台的不可移殖 (而移殖,潜台词,就是能不能被更好复用,还记得在C语言中写上大量的预处理代理来实现跨平台逻辑吗?),二是架构逻辑的不可复用,,,,实现指的就是跟计算机离散相关的平台逻辑,,架构就是人为为程序的可扩展性加上的设计逻辑,,大多数是OO之后的东西,,我觉得提出二门语言,一门C,一门类RUBY的脚本语言来进行程序的编写,,,,在底层用C,在高层用OO脚本,这样的办法很好...因为你在低层不需要架构,,而只要在高层考虑架构问题.,,这样一来,可复用性就是二个阶段的事,前一阶段只管实现,不考虑设计,,这种过程是承接性的,只要先实现了,才能被设计得架构上更科学.

一般谈到某程序或库的跨平台特性时,总是会同时提到某种CPU架构和OS,比如“在P4加Windows Xp下编译通过”,所以软件移殖问题最初源于硬架构的CPU,然后才源于软架构的OS,这也就是说,移殖问题(也即解决运行问题的问题,而程序的运行是一种执行时中套运行时的机制.)所以同时跟硬架构CPU和软架构OS相关[^4].

在一个大型软件系统中,抽象是分层次的,,粗略地来说,有的抽象是系统平台相关的抽象,有的是对于目标问题领域的抽象.**所以,移殖,标准的说法是“分层移殖”,只有谈到具体某一层,移殖这个词才有意义**.注意这个区别只是粗略的绝不是精确的(所以也可说是无层次的).
设计中经常将实现和抽象分开并各自集中,如果抽象中过多地混入了细节考虑(即有硬编码和实现出入的地方),那么它必将在以后的扩展过程中产生麻烦,因为对于一个庞大的软件,其内部逻辑复杂,牵一发而动全身,语言给于实现和抽象形式上的划分方法只有头文件和CPP文件这样的初级方法.实现和抽象的分离从来都高度掌握在源程序的作者手中,我们知道,抽象不全是为目标领域作抽象,有一部分抽象是为接口作抽象,也就是为可复用的有效形式作抽象,即接口是抽象的一个部分,是抽象的简单形态,,其目的是为了给使用它的客户提供一个复用(或实现)的原型和规范,比如库,函数API,这里的客户是程序员用户用户.(但是像虚函数那样的语言内接口,又不完全是为了面向人的复用,而是为了面向程序内逻辑客户的实现.这个客户跟据这个接口产生出一个关于这个接口的model),如果不是库,则不需要提供接口设计,而实现是未端抽象(这就要求设计者具有良好的对系统的可复用考虑的设计能力).更多的关于接口与实现的区别在文尾有述.

>Todo:这里着重写下 为了移殖而设置的迂回逻辑是一种抽象.比如把界面做到逻辑的最上层,那么它就不会跟核心相连,程序只用console,那么它就首先跟语言脱钩.

在一个复杂的软件系统中,可移殖逻辑主要集中在那些与系统编程相关的逻辑中,而不是对于问题的领域设计逻辑(虽然如果对问题的领域设计,,抽象得不得体的话,这样同样会导致不可复用问题,但决不会产生不可移殖问题).比如对某语言密切有关的字串逻辑的依赖,对某平台密切有关的某个socket..鉴于对不可移殖问题的考虑,,我们往往将它与领域逻辑分开.所以可移殖问题只是可复用问题的一部分,二者绝不是同一意思.

所以,应该怎么样做呢?这样才能同时达到可复用,又最大程度地可移殖.(当然,只能是最大程度地这样.)



[^1]: 当然也有lanuage indenpent的复用,那就是COM

[^2]: 比如,因为django是DP设计的,所以利于重构

[^3]: 比如使用django这样的高度利用了DP的框架进行编程

[^4]: 这是很容易理解的,移殖是为了运行撒,就目前我们讨论进度来说,运行平台不外乎CPU加OS,后来才会涉及到VM
