/*!

\page Pure OOA与OOD.html

============= Pure OOA与OOD

实际上,用一门语言进行设计,这样的说法是很广泛的,具体每种语言都有不同的设计支持(它们往往属于高阶手法,跟实现有着明显的区别, 第二部分介绍C的部分是基本的实现手法,整个第三部分写的是抽象的实现手法,我们把),本书虽然在这里名为讲述设计,但其实设计在第三部分,甚至第二部分都对语言的设计能力有所涉及,如果说第三部分的抽象实现手法带有一点设计意味的话(这一部分的OO实际上侧重于讲class而不是OO),那么这第四部分就是讲大的设计手段,比如OO(这里才侧重指OOA和OOD,OOAOOD比Class更能代表OO[^1])啊,模板啊.

**故，理解OO的时候要把它跟CLASS,OOA,OOD分开,其实,CLASS是OO的抽象**,即它是一种类,是对代码,数据,接口的体现,是抽象事物为一个语言端实体的工具,**而OOA,OOD是OO的设计**,它处理OO对于应用端的事,比如,如何用OO分析的方法,形成一个一个的类.

>当OOA与OOD与语言结合时，就成了OOP。

OOP不仅仅再是指单纯的继承啊,多态啊(这样面向对象的机制本身),还指一些公用的OO程序设计手段idioms,,比如句柄,function object,接口,容器(用来盛放对象),迭代器(用来遍历对象),适配器(统一对象的接口)也即OOP包括面向对象和Generic programe技术在一个常见的C++编译器中,总是会带一个精心安排的简化程序设计的公用库,比如MFC,VCL等等,MFC显得有点过时了而且它的实现比较繁复,C++标准把STL加进来了编译标准,一般C++编译器都支持STL,





------------- OO设计


用OO来表达世界的观点,,,物体可以组成世界(所有其它的东西,比如物体之间的关系也是另一种意义的物件),,,因此编程抽象了OO,那么编程就可以用来用计算机模拟世界,这种思想是成立的.(物体可以组成世界,,用OO作手段，可以表达组成一个世界大的抽象体系，，只要将抽象表达为对象完成对应用世界的建模过程，对象容易让我们错觉地以为一切抽象都是实物具名抽象，但逻辑抽象也可以是这种对象)

什么是用OO来进行设计呢?什么是系统?系统是关于一个事物的逻辑上的有机组成部分,因此系统分析师的工作就是用面向对象去表达系统(划分对象), 对象之间是分配了责任的,如何把这些责任更好地分配呢?(即对象内逻辑和对象间的交互逻辑,UML中的对象消息)这就是OO用来进行设计的意思.

“在原语空间内进行设计”前应该是现实世界问题域,在“产生最终类文件”后应该是编程域的OO解(或其它范型解),即设计的FrontEnd面向的是用户,设计的BackEnd面向的最终是计算机,这中间的“原语空间设计”,“多范型表达设计”,“ROSE工具实作范型”都是“设计演化”,即设计是一种从用户到机器的抽象过程(它包括前面提到的三个主要过程,原语设计是从上到下,泛型设计是从下到上,明白这个道理有什么用呢?这至少可以解释为什么好的架构可以扩展出足够丰富的未端实现,因为从架构设计到功能实现是互通的,这二者不是矛盾的相反是统一的,明白这个道理还有什么用呢,这也可以解释为什么Yake的 BaseGeneric不是包含架构逻辑的Generic,而是一组与平台native本地有关的DLL引入逻辑,数学函数,Logging机制什么的, 这是因为需要先提供这样一些实现,才能独立平台,而这是Yake首先要解决的问题,因此只能把这层逻辑放到最低层再慢慢发展其它抽象,另外,YAKE使用的库中,比如OGRE和ODE就用到了数学函数(并非所有的问题都能靠提供架构和中间抽象来达成并解决,因为有些问题不是要不要封装和不封装的问题,而是能不能实现的问题(能不能用OO来表达跟能不能在算法等级实现是二个不同领域的问题,一个是软件的设计,一个是算法,前面提到了这二者之间的区别),比如一种算法,什么是架构什么是实现,这里是一个很好的区分例子),底层必须先解决并提供这些抽象,以我来看,Yake真正的主体不是 BaseGeneric,它是基础而不是主体,它的主体是对其它库的引入逻辑,这才是Yake的架构逻辑,因此说,架构逻辑有时仅仅是被体现,而没有并封装成DLL,也即,架构是否被体现与它是不是要被封装成为一个库是没有必然关系的,哪些没有表现为库的中间逻辑也可以是架构逻辑,明白这个还有什么用呢? 原语设计是不受限的面向用户的设计,然而当进入多范型设计时慢慢转入用计算机的观点来看待设计,因此像Yake这种与平台息息相关的表现逻辑必须在底层就解决平台抽象和数学抽象,而LogicGeneric就根本不用考虑这些,因此多范型设计相比原语设计来说,它是从下到上的),而实现是一种从机器到用户的过程(实际上我在这过多强调设计与实现的差别是不对的,因为这二者无法精确定界,然而如果所有中间逻辑都被封装为库,这二者差别就很明显, 库作为中间逻辑可以参与进来以缩小这二个过程差距,把应用架构称为设计,把中间逻辑封装为库(架构也可以表现为库),实际上在这里,中间逻辑与最终实现才是对立的说法的二方,设计与编码才是另外二个对立物(设计就是原语设计而编码就是多范型设计),

设计演化(从问题到类),,实现演化(从类到问题),,前者是从人到机器,后者是从机器到人,设计本质上是处理需求到语言再到程序的关系.

逻辑互饰构成的逻辑的巨集组合,就是一个越来越接近应用总逻辑的大逻辑,(上下互饰就是谁更接近应用逻辑的道理,至于最终应用逻辑前面的逻辑,都可称为相对的中间逻辑) 然而设计与中间逻辑不是没有关系,把库外的未端逻辑称为实现,在这种说法下,基于库之上的实现跟设计共享同一些中间逻辑,库使这二者有机结合不产生缝隙,当然作为泛义的库是缩小任何二个架构之间差距的机制),其实在“ROSE工具实作范型”之后还存在一个“设计载体与设计方法”,即UML图,或卡片啊(设计载体),设计方法主要是“找事物的共同点与不同点(就是多范型设计那本书的作者提到的)”,还有就是UML教学中出现的“给出一个句子,找出主语谓语等” (其实这些方法归纳开来就是做列举题和判断题,列举出一些细节,再判断它应属于那个接口中,这在第四部分“确定GameGeneric应提供什么样的高阶接口”那一节有清析的讲解) 实际上我的思想和说法比他们还要超前和规范一点,原语设计三种思想(抽象,原语,组合)就包括上述的说法(找事物的不变点就是指抽象出事物的本质,这是设计过程中一个很重要的能力) 在设计模式那一章节,我们将讲到基于OO之上的进一步抽象,即对应用问题本身的高阶OO抽象. 设计模式不致于使我们声明对象的过程变为硬编码,,,这样就使得整个软件的对象生成是动态的,这个过程就如同动态分配内存,寻求一种好的方式来组织类的过程称为设计模式或策略

>抽象能力和程序员能力模型设计能力第一个是结合了数据抽象和代码抽象以及语言映射能力到现实问题的解法的能力,第二个是构架架构的能力(提出一种规范一种抽象模型,就像Java规范和七层模型一样,相比第一种设计能力来说,这是高级的能力).

设计还有一个方面是面向复用的工程设计.就是开发库的设计意义所在, 理解设计对理解C++新思维那样书里的观点有效. 冯氏模型的局限和优点同时体现在数据结构和设计模式上,它使人无论如何都要最小在这二种子抽象上工作,,优点是,统一了开发抽象,,这也使软件逻辑变得统一.这对软工是尤为重要的.

------------- form a objectsytem

首先，OO把软件抽象设想为一个对象系统，对象是一种高级的变量（它的类型意义已经在前面说了，它是UDT，ADT，而且是加了访问控制的UDT，ADT，OO首先是CO,class oriented，冯氏用类型来设计类型从而完成设计，,然后是oo,object oriented，它可以从逻辑上反应一个具体的对象系统组成的业务逻辑），，那么它是怎么做到的呢？这就是继承，前面说的访问控制远没有接下来谈到的继承的意义重大。

2，，在具体OO体系中，继承把逻辑一级一级下放到下一级值上（每个值都有一个UDT，ADT，要记得OO首先是CLASS，因为它必须完成语言级的对应工作）,OO用一套值系统来描述这个业务逻辑。。继承指出了复用的根本需求，那就是，软件往往是一个从已有系统派生新的尾端逻辑形成领域独特逻辑，这个过程是一级一级的。树形或网状结构。

3，，在一个从零开始（不以其它外部OO系统可复用件的OO作基础的OO，比如，一个OO库的搭建中）的OO业务逻辑搭建中，它有一个OO root（强烈建议你把CO和OO分清，作为类和对象的OO，在OOP中代表不同角色起着不同意义）,通常提供引用计数（CPP本身不提供引用计数，所以必须自己提供，做到root中,这就涉及到深浅复制的问题。）。而且，它往往提供可查询下一级对象或父对象（用父类型指针所指的某一对象，注意这里不是说父类型本身）。。

4，如果复用了一个OO库，那么复用了它的程序，，其逻辑被与这个OO库一起做进了一个树形的逻辑体系中。在运行时，内存中会存在一个大动态Object系统。当某些对象被析构时，，逻辑从树或网的某个端点掉落，自动析构掉它不再引入的其它对象（引用计算会保证这个工作的完成）


OO甚至为组件化(如何导出组织api,及规范如何使用api的方式)提供了一个核心,比如,基于OO的二进制接口规范com,,将api独立出源码要隐藏的核心,将api wrappe成特定的方式(比如,由一个接口到另一个接口,而不是全开放的,这样可以引导使用api的程序员更好了解api及更好隐藏核心逻辑).


------------- 找对象的方法


往往是实体类

如何才能用OO进行科学的设计呢?这要求有很好地用类来表达抽象或实体的能力,一个分配得好的对象组合(兼顾了当前使用和未来扩展能力)往往不是现实生活一个具体的模型,而且有些时候你一点现实生活中的对应物影子都找不到,而往往是一个思想模型  ，当然，可以有多种思想模型，每一种模型都是一种方案，这些在设计一部分有详述。


[^1]: Class是oo中的抽象,对应第三部分,ooa,ood才是oo中的设计所指,对应本书第四部分

*/