/*!

\page 使用Advance OO技术的方式.html




============= 使用Advance OO技术的方式


**面向接口,基于原型,面向切口,不过是OO的具体应用形式**. 对于基于OO的设计层次,有二种,第一种是基于原始的OO的设计层次,设计模式就是(Pure OO based Design Patterns),第二种是基于抽象了的OO的设计层次,这就把设计层次从OO上面上提了一层,比如基于OO的接口设计,可以称为“OO based interface Deisgn System”(它们属于某种语义OO),还比如基于概念的C++ Template,可以称为“OO based concept Deisgn System”,还比如切面,接口,模板,切面,都是设计而不是语言的实现手段,切面可以称为“OO based (concepts’) Aspect Deisgn System”.所以,设计都是分层次的.
这其中,有一些是基于源码级class上的抽象条件.是OO的具体变形.然而,如上所说,它与OO的最大不同,是它们超越了类型编程.超出了程序员的工作范畴之内.使得这些工作可以由其它人员,比如用户或设计师来进行.

\page 使用语言层的Interface dispatch-初阶组件.html

============= 使用语言层的Interface dispatch-初阶组件

------------- 接口


对接口编程就是对函数编程,,定义行为集代表的逻辑层之间的关系,而数据分派在子类中作为实现

我们应该不要在接口中包含数据成员(像VC++的.h文件中就允许这种形式,这导致C++的头文件并非一个良好的接口)

接口往往是函数阵列,而且往往接口本身也是一个对象,包含这些函数阵列作为它的成员,虚函数的意义就在于它不必定义它的实现,,正是因为没有实现,所以它可以被override而形成新的接口供以后的继承类来实现它
接口就是把我们所需要的对象部分封装起来提供给我们,而把我们压根不需要知道的关于对象的细节隐藏,,,也就是说,,接口是关于一个对象如何能被使用的形式的封装者(一个对象可以有多种形式被使用,因此可以一个对象提供多个接口),是真正的对象(实现)和外界复用的包装器和桥梁,也称适配器(即接口就是直接面向使用的中间件,或封装了给二个不同架构提供适配作用使它们能协作运转的中间逻辑)

对接口编程即,将需要维持不变的东西,即设计,维护在接口层,即变化的东西,实现,维持在接口层以外的地方.

###### 接口与抽象

接口可以用引用类型来设计. 多范型开发让你在高于面向对象的范畴里看待软件工程,所以真正的编程学习过程是要明白设计在先,这是基础的思想,然后去学习编码,,(以上二点都是方案领域)然后再去研究编程领域对现实问题的解法(这就是应用领域)

而且如果你知道可复用和可扩展对于软件工业来说是多么重要的一件事情,,,你就会知道面向对象是多么好的一种机制了(面向对象和面向构件,面向构件可以不用对象的方法,,但是很明显面向对象和面向构件都有一个共同点那就是它们都提供了可扩展,而这就促进了可复用)

数据接口是另一个很重要的概念(服务导向)
如何从以上二种机制理解OO呢,,,OO为什么这么流行,,因为OO“很好很强大”..

------------- 对接口编程


在OOP中，为什么需要接口呢？为什么要提供面向接口编程呢？

首先，接口是可以是OOP中可复用中一个很重要的概念.

举个例子,在现实生活中,经理人可以卖票,,,个人可以卖票,国家也可以卖票,,在面向对象的范畴里(注意这里并非指某个具体的面向对象设计),我们一般是把国家,个人,经理人都各声明为一个对象,再为它们各自添加一个“卖票”服务,,但是事实上,我们需要的仅仅是卖票这个服务,(如果这个服务被包含在一个发布的第三方代码库中为我们所用),我们只需提取这个可用部分,,而不是要知道提供这个服务的各个提供者的细节(还好上面只是列举了三个对象提供了这个服务,,然而现实生活是复杂的,还存在成千上万个对象也可以提供这个服务),,因此,对于复用者我们来说,我们需要的仅仅是卖票这个服务,而不需要知道卖票服务这个背后的情况(而且,对于发布这个第三方代码库的第三方来说,这可以更有效地隐藏它的实现细节)
这是见于李维的某本Delphi教科书上的一段话，我仅凭记忆复写了一遍。然而李维的这个比方太过通俗，没有一定编程经验的初学者是很难知道作者到底想突出哪些意思的。
以上这段话需要看到以下几个重点： 首先，“编程复用者需要的仅仅是卖票这个服务”

>比如，卖票被实现为sellticket()的函数形式。如果是库/源码的提供者，仅需提供这个接口，如果是库/源码的使用者，仅需使用这个接口。为什么说“仅需”呢？因为大凡“实现卖票”或“使用卖票”的程序。不过都是为了实现一些供后来程序上使用的的“关于卖票的逻辑”，可能是 who.sellticket,sellticket(towhom),getmount(who.sellticket())，我们需要的是程序产生一套“tickets”接口，以供我们实现多个tickets用，编程就是接口定制。你看，从程序/使用程序的编程行为来看，一切都是围绕着“接口”而展开的。而且这个接口往往是精心设计成精简的。而程序/使用程序，实际上代表了所有的编程动作。故存在“面向接口编程”，所以“编程者仅需要一套接口”这绝不是一句空话。而是有具体所指的。注意，函数可以是接口，类也可以是一种接口。一些显式化的设施，比如语言内的抽象方法集，类集，语言外的二进制，都可以是所谓的“接口”。

其次，“编程并不需要知道这个服务的实现细节”，这实际上是抽象的

接口这个概念其实无比自然,无论是为了隐藏实现的安全考虑,还是为了更好地让这些实现为用户所用这个方面来说,接口都是必需的,
一个为未来扩展而写出的工程中[1. 接口对于可扩展性的表现就在于：通过提供越来越多类型的接口，使得未来可预测的扩展能加进来],大部分代码只是框架(抽象的思想模型,也就是为了扩展需要 --也是为了使用需要,而定义的一层又一层的抽象),真正的实现部分(调用API啊,用某个算法啊,某个完全具体工作的实体对象,或某个完成某个业务过程的会话对象)很分散,而且分散得很有规律性(因为被抽象接口经过了再组织,所以变得有规律地分散),,这样的分散机制就像把真正的实现逼到最尾端,而最高层往往是使用这些尾端要如何被使用的应用逻辑--被抽象成了一个或某些使用的统一接口形式,而且是高级逻辑,(即接口实际上是关于如何使用这些实现的隔离层,,中间层)
这样抽象也称为为客户调用(或使用)的协议定义

>所以接口的概念是无比重要的,它使第三方代码库隐藏了其实现内节,如果我们要用该库中的一个类,我们只能定义一个这个类的变量,再根据该第三方代码的文档来利用它,一般这个类仅仅提供了create接口(一个类能被实例化它就进入内存,这是最基本也是需要提供给使用者全部的接口,因为该类所有其它的接口都是该类protected的,都可以通过你变例化得到的这个类的对象来引用得出,比如一个成员函数或变量),,但是在文档中描述了使用该库的很多信息,,,这成为你获得该库信息并使用它的唯一途径,所以需要反工程法超越文档,或者在根本就没有提供文档的情况下反工程更为重要,,因为这个类的源码永远是不可得的,只要从比特流级别去弄清它的一些逻辑,正如我前面所说的,如果你是一个反工程高手,你甚至都能重构出它的一种工程化的逻辑

###### Interface是对服务导向编程的抽象

为了使用某样东西而设立使用者把使用对象之间的抽象,,称为对接口编程 Interface首先是一种设计,即规范与实现之间 的设计,具体到C++这样的有声明类型的语言中,对实现是一个天然要素正如对象的索引才是真正的对象一样(C++中提倡使用引用优于指针),对接口编程才是真正的编程工作,一个程序员大部分情况下只是一个接口粘合者(因为我们不需要重新发明轮子,发明轮子-中间逻辑的工作才是真正的对实现进行编程),发布时我们也是发布接口库和其说明文档,大多数情况下,我们都是利用第三方代码库编程(这是语言之外的接口,程序员也在语言内部编制函数等接口) 接口设计是一个编程工作中常常要考虑到的问题,要考虑提供这个接口的实现会在什么地方会用到(因此它跟需求分析密切相关),以此来设计接口的参数信息,一个接口不单单是一个函数,虽然函数的声明部分在大部分意义下作为接口的意义,,,, 所以delphi的单元中有实现和接口这二个字,,,接口的集大成者是COM,所以borland以它的IDE很好地支持接口而著名这是语言之外的, 设计一个面向需求(从需求到程序)程序设计语言永远是不可行的,需要永远是可变的,程序设计语言只能遵守一个固有模式而提出,有固有模式去表达和创立新东西(面向对象就很不错),编程是人的动作,人力对工程(一个大软件就是一个工程)的控制应该尽量简化,

###### 意义

>不存在一个“对接口编程”的真实过程(虽然这是一种过程定义),我们只是说,要为”实现”定义一系列使用它的接口(这样实现才能更好地被使用和被修改),,这种行为才是对接口编程行为,而接口本身是什么还是没有说哈哈

OO的作用在于透露接口,于是开发,就被维持在对接口的理解上,比如对于数据库的开发,面向对象数据库db4o的出现,使我们开发的重心不再集中在如何存储和声明数据本身,转而将注意力集中在这些业已创建的对象的逻辑上,如果说UML建模工具可以用来规划这个过程,那么DB4o就是实际产生和持久存储了这些对象,
接口几乎改变了现今我们开发软件的方式,对于用户来说,如果某套interface某个interface要抛弃了,就整个地只是简单的抛弃,重新发明一套新的接口体系.这就将复用整个地提到了接口层.而且做到了对于用户来说,改变的只是接口.

这就是面向服务的编程

(接口跟面向服务的编程有一点相似性,当然,这二者指的都是设计,而不是实现,只要接口和服务被显式地提供出来,这就像java有interface关键字一样,所以对它的接口是可以在复用级就进行的,高阶程序员就可以堂里皇堂地“对接口进行组合设计”以“编程”.)这难道不是改变了软件的和软件开发的传统观念了吗?(接口之前的是代码和数据,接口编程就是接口组合)


基于语言层面抽象方法集技术实现的interface dispatch，可以实现简单的组件机制，为rad ide这样的环境发展可视化拖拉支持，支持某种语言在设计期就针对某个组件指定运行期的动作，<b>不光是参数，甚至是方法，比如回调</b>。

回调就是支持方法欠入的，，，signal,event就是这样的机制

###### 如何设计接口

应该如何设计接口呢,OO=抽象+接口,,那么其体现又是怎么样的??只有深克地分析了应用和计算机本身,你才能分析出通用和最精简的接口机制,而OO正是这样一种机制..因为类=数据加函数,,数据加函数既对应计算机世界,又是解释现实事物的一种机制...当然.OO不单是这种理念,还要学习它的运行期多态,继承等(语言语义)..
一个接口应尽量简单,提供它自己应提供的逻辑,其它多的都是多余),这些逻辑都是基本的,比如一个socket库只需提供诸如 transport(int),transport(float)这样的接口,,那么所有的逻辑都可以建立在它上面了(比如发送大件数据的后来逻辑只需建立在transport()这样的函数基础上就行了),

###### 学习曲线

deepest concept,lowest interface = min learning

编程领域的接口从来都不是泛义的,而是特指的,但一开始要获得一种泛识,才能更好地学习细节和实践
学高级语言应不仅学它语法,而且要学它语义..因为被翻译后的代码才是代码最初被产生的地方,是最应该被研究的.. 接口应尽量窄,提供尽可能少的东西,,但在概念上一定要广,,以备后来的扩展需要.这样的接口,对于复用来说,也是可以花最少的精力来学习的.什么是抽象呢,,,就是抽取对于人来说象的部分....把多种特征的东西在概念上整合为一个认识,,,抽象出接口就是这个意思...其实,抽象正是为了简单,,而不是复杂化(它只是极力把复杂化的低层细节隐藏,透露给人们一个通用的,可认识的抽象概念,即接口) ，但它会在另外一个层面上导致问题

*/