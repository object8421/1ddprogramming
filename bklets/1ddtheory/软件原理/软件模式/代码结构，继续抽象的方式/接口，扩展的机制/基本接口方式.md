静态语言系统的设计与运行期分离机制,api与runtime分离，头文件规范与实现分离



c语言级的接口

其实，回调是一种接口，全称是回调接口，是函数级的接口，，它将OO interface做入了最基本的那个函数例程，而不是类数据结构封装级，qt的槽就是一种受qtcpp语言支持的函数接口。

===================


语言的api复用与二进制扩展系统：UDT系统与组件系统

对用户代码的支持促成了语言系统api扩展和UDT
语言如何接上平台与开发应用

接口与扩展,引擎与plugin

/*!



接口，，就是将实现抽象发生的时光推迟到以后，，先就这个契约的东西发展上流的抽象，，下流的实现以后再发展吧，，是沿迟抽象的典型例子

机制，策略就是接口和接口编程，，预留接口，作延迟抽象的语言机制和应用方案。。


接口就是那些作为api（引擎，将要隐藏掉实现的主引擎部分隔离，为api如何被使用准备一个专门的引擎）部分的（抽象）基类集，如果用专门的二进制组件接口来做，这个过程会更抽象。

这样，就道出了接口的历史由来，原来他是改了门面的api库，是传统api 基类库向专门的引擎方式迈进的表现形式，目的是为了隐藏主逻辑引擎库，向用户提供更规范的使用方式，组件甚至能获得跨平台语言，跨分布架构的功效。

经过组织的api，，由一个接口到另一个接口，的方式，有什么好处，，可以为api独立准备一个引擎，，叫api的api?
提倡api非库，，api是使用库的方式


前面我们说到, 设计上的东西 , 无论是系统编程 , 还是高级编程 , 都是共同的(程序脱离了函数级,在架构级都要考虑一样的问题) ，c的设计,跟C++以后的高级设计,其实大都有相通之外,因为在整个程序的层面,都是抽象和设计,接口.

前面我们说到架构就是抽象间的关系，比如，层次向下的抽象，称为接口

接口是软件抽象级的概念，它的全称是‘具体软件抽象中的接口抽象’，所以它是语言无关的，用什么语言都能完成


**接口即是属于语言级的可扩展设施，它往往作为一种架构的一部分而存在。为什么会有interface，因为这是对抽象的按排太过于侧重它的封装抽象而不是领域逻辑的结果**


任何开发都是一种三级过程，库与扩展，即引擎和基于引擎的用户扩展，直到对最终产品配置级的支持，比如图形工具支持下的艺术和设计工作，业界通常用plugin+脚本语言来完成这个引擎扩展过程，其中脚本系统也可用于对艺术设计用户的支持，

a compent is a interface implents,,both in src lvl and bin lvl,,interface is metainfos ,,about its typeinfo deepin src and outterward bin

扩展是对引擎的apis应用,配置逻辑是对产品的应用

任何一个程序和它的扩展组成了mods体系，在传统无VM无动态组件的情况下，，先提供一个xxxinterface.dll，再提供各种具体实现的xxximplents.dll
但一般不将engine中的xxxinterface.dll独立出来，而是将它保留在engine.dll中

这实际上就是构件编程，因为它使用一个中间层，xxxinterface.dll，分开了主体engine.dll和可选的以后实现部分xxximplents.dll，跟源码级的扩展（抽象接口等）是一个道理

编程即应用，开发即组件配置。。发布程序即发布库的组合。。这也是linux一向的作风。

组件还可以提供可视化和程序组件的组合，从而去掉mvc这种复杂的程序框架，而采用可视模型,它就可以将基于引擎的扩展弄为引擎小件，shouldbe，基于引擎扩展和基于产品的配置。弄为小件




>代码库,设计模式中某个角色逻辑,类库,COM组件,一般组件,一个能在二个逻辑之间发挥承接作用的类文件形式的逻辑,都是接口,这些条条框框就是＂细节,就是实践维度的认识＂,而只有在同时了解了接口的本质,和这些实践维度上的认知之后,你才能说你是彻底了解(仅仅是)编程领域适合的这个特指的＂接口＂

这就说明,存在接口的地方就存在设计(因为可供再被可复用,而设计的一个意思就是为二层用户提供复用逻辑考虑的过程,比如接口,我们在比较大的层次举个例子吧,比如用C实现的工具库和抽象库).我们应该严格在源程序中标志出哪些接口是作为最终工具使用的接口,哪些是能再供抽象使用的接口.
接口是一类抽象上的程序.接口实际上就是将要用的部分作为某个接口提取抽象出来(就是定制要使用的实现的某个子集而已),而所有实现就是接口下的所有代码,即数据本身,故其实数据与数据接口是分离的，只要是在语言级表达设计，无论是什么语言,一门语言写出的程序总是程序=抽象+接口, 只要是接口。你都分不清是实现而来的(是不是一开始就包含在实现中)。还是专门透过特定的接口机制而来的。但是只要是接口。不管它是函数api。还是构件。还是类库或框架。它都是作为原子而存在的（接口的客户以组合这样原子为对象形成开发逻辑）

在OOP中，我们有足够的设施来表达这些共同的东西了。这种东西之一，就是接口。对接口编程可以成为一种advanced oop。

>在 DP圣经中，四人帮提倡对象组合和面向接口编程，不要小看了这里的对象组合它实际上是对接口编程的小化说法,,要弄清接口开发中的实现，，在OO中，应派生类表达的是与基类的纯粹关系(组合关系可以不混进实现)，而不是继承关系（比如，混进了实现，数据成员或非虚拟的函数成员）

<b>继承关系比组合关系更容易带来实现上的侵入</b>,虽然严格的继承关系可以实现纯粹接口上的类与对象之间，类与类之间的概念关系

我们知道接口是C++里重要的一种语法机制.接口与设计模式,是密切相关的,C++提供了接口这种语言机制,在C++中提到设计模式你就要把它跟接口这样的语言机制联系起来。

###### 处理硬编码与运行时可选部分的动态载入---plugin/plugin out system

c 级分开抽象的语言级支持，好像只能避免数据的硬编码化，比如用define，再者就是函数体为一个源码单元来区分逻辑到不同函数，运行期也是函数的栈的隔离作用。本地数据不能逃出函数体，CPP比它聪明，用了虚拟函数以支持抽象的显式分离。这就是源码级的接口，而且它还有plugin可支持运行期接口


plugin其实仅在接口处缝合就够了,达到这个契约就行了,,接口后面的东西(plugin中除继承接口以后的东西)是什么,,怎么发展,可以随意
plugin api是一种将一套源码体系的api部分，中的那些特定部分(比如对于一个gamengine，有graphicsystem api------------- 一般一套plugin对应某抽象方向)做成plugin apis，plugin runtime即是plugin api的不同实现。
plugins 即是plugin api的不同runtime实现
刚开始将游戏的定制保持在引擎级(plugins system)，后来，保持在mod级(scripts级居多)
plugin源于将需要扩展的地方用运行期可代替的东西不同实现来完，组件和虚拟机也可以做到。前者是最初的语言级对构件架构的支持。后者是更高级层面的。
plugin机制分开了engine part和non enginecenter part，首先是源码的分开源码需要提供plugin/plugout interface，是抽象的分离，，并将它结合到运行期分开，以构件化，，更是一种分离。