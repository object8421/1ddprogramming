通用算法与数据结构-加进了对离散化了的问题解法的编程
=============

除掉应用本身,和关于人的那些东西,冯氏上的编程不过三个东西:数据模式,代码模式,与数据结构

algo和DS其实并没有任何必然的联系，只是历史上它们往往被放放在一起谈，一个是组织内存数据的方案(一定数量的)，一个是解决问题的方案（多样的），也许是在“解决问题的方案往往涉及到组织内存中的数据”这个意义上被联系了起来 

编程由这些组成，基建（平台与语言），问题（范式，数据结构算法），人（基建和问题，算法和数据结构，设计的综合） 

数据结构应称为类型范式 
算法是问题范式，过程是代码范式
数据结构是解决问题时组织数据的范式，类型变量是进行语言映射时组织数据的范式，算法，是解决问题时组织代码的范式，过程式，是进行语言映射时组织代码时的范式，两套概念处在不同层，设计模式则出现在设计面向人的那层 
算法与组织过程范式，数据结构与组织类型的范式，这样的命名害死人 


从前面我们看到,高级语言的发明,OS的实现,都涉及到算法与数据结构.

**算法与数据结构实际上就是计算机编程界将应用问题离散化建模(使之能被计算机识别和处理)的方案,这样,就可以将应用问题转化为软件上可用的抽象,而所有一切软件上的问题,不过都是抽象.**
>其实，严格来说，算法与数据结构实现为计算机上可用的图灵逻辑，还要经过一层编译原理层，所以，可以这么说，算法数据结构加编译原理，将应用问题转化为软件上可用的抽象。



函数增长与算法复杂性分析
=============


从这一节开始,我们就慢慢进入算法了,,为什么把算法放在这里而不是放在数据结构那一章呢,, 因为算法是属于数学和计算机的,,跟它们的结合要更前于数据结构(虽然也严重与数据结构有关,但是数据结构是进入到计算机以后的抽象,算法是它以前的概念) 我们在这里必须谈点关于数学的东西 对一种数据结构的讨论常常不但要明白它们的工作原理,还要明白它们的操作,如查找,排序等,数据结构存储结构和这些操作就构成了ADT（ADT是语言和语言类型的观点，跟数学和计算机算法没有关系，必须把这个层面分清）,所以一种数据结构总是跟算法同时被讨论的. ,,先讲讲什么是算法,,它的分类与有关证明 递归算法,,,分支定界,,二分法,,贪婪法,等都是用来描述算法的(它们本身不是算法,,,只是用来设计算法的方法) 程序正确性

算法的有效性包含二部分,算法的正确性和算法的复杂性,,这里讨论算法的正确性,,复杂性在前面2.2节函数增长部分讨论过了

对算法的正确性的研究用到逻辑规则,证明技术(如数学归纳法),算法

不考虑语法等其它因素,,,除非测试了所有可能的输入,,程序都给出正确的答案,这就是程序正确性的概念

如何把以上概念分解为形式定义使它具有可操作性呢?

在有输入的情况下,只要第一部分证明:若程序终止,则获得正确的答案,,第二部分证明:程序总是终止,就可以断言这个程序是正确的(二者之一成立是部分正确)

第三章讨论算法的正确性,这里讨论算法的复杂性 在假定输入值一样的条件下,,求算法的空间或时间复杂性 由于空间复杂性跟数据结构有关而本书不涉及太多的数据结构 因此在这里主要讨论算法的时间复杂性,,即步数 幂级数提供了一种模拟给指数函数求值的近似方法 运算次数的单位是整数加法,减法,,等基本运算

相比线性表O(n)的复杂度来说(输入的元素个数是最主要的影响因子),对二叉树的各种操作(插入,查找删除)效益直接受制于高度,即h = O(logN),即树提供了O(logN)的复杂度,其中N是节点数,(二叉树中)我们并不直接把N作为影响操作效益的因素,h才是,因此需要对height进行balancing才能控制操作效益.

BST的构造是严格取决于待输入系列的,当待输入系列本身就是一个sorted的系列时,那么当这些序列被用来构造BST时,它就是会退化成对应的“链表”.在操作上会失去树的优势.

算法的设计模式 : 算法设计方法
=============

摊还分析不仅是解释数据结构性能的工具,而且也是设计时要考虑的因素.就跟NP完全一样(逊于图灵不可计算机的停机问题).如果复杂度超过了10的确良8次方这个计算机的数量级就没有意义了.
存在很多类型的问题,比如最优化问题,,找点问题,理解诸如贪婪算法的前提是理解这些问题在先,比如最优化问题可以很好地解释什么是贪婪设计..
迭代是方程求根的一种方法,并且它也体现了一种算法设计方法.
递归体现了分治的算法设计思想,但它提出的子问题一定要跟原问题接口一致.. 递归的终结条件是不需要递归也可直接求解的条件,,因此是终止条件,,当以从下到上的眼光来看时,它是超始条件(直到问题规模n)
其实并不是只有所有明显递归性质的问题才可以用递归来解答,而是只有能把原问题分解为子问题并能制造一个接口的情况下就可以利用递归来求解它.
递归是从上而下,所以有时要求用辅助栈来保存中间结果,而递推只有一个函数,并不发生欠套的函数调用,并没有出入栈的时空开销.复杂的递归结构转化成递推时,需要回SU处理,二个概念仅一字之差,一个归,是向下,一个推是向上,

