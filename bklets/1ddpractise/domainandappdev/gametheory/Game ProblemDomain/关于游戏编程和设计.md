关于游戏的设计
=============

gamelogic,gameplay与游戏的设计
----------------------------

上面列了几大流行游戏的各大子系统，下面概而言之讨论游戏的设计。

对于“桌面游戏”，程序上要写什么东西，是可以被“归纳为标准的”，因为业界方案域已经对它们进行过大量有效的实现可供参考归纳,一般地，把一个游戏总体分为五层: generic system programming compents(db,network,scripting engine……) generic game.graphic,generic game.logic engine 具体游戏封装1，2的抽象层面，（比如假设这个具体游戏是notwar3,我们将在下一章设计并实现的一个混合风格面向教学的游戏）则称为notwar3.systems,notwar3.graphic,notwar3.logic 然后就是notwar3.game了，这实际就是notwar3.exe本身了(所以，其实根本就没有一个必要的game级)。在这层，处理gamemain和gameeditor。 notwar3.extending system

说实话，严格按照这个构架建造的游戏一般不存在，人们经常把具体游戏.logic(第三层)分散在第四层，或整个地替代作为第四层（原则上，任何层面都不是绝然分离的，但在逻辑上可分，而又是互相穿插的），但是为什么notwar3.logic分散在game级不好呢，因为我们完成可以更抽象一点，使得三，四层分离。这样做的好处是，“一步一步来解决问题，以求得教学上最大的详细性”，“虽然实际上并不经常要求那么做”。

因为人们经常这样制作game,先完成“泛义上的game”最重要的程序部分(graphic,logic)，那么在这一部分，然后再完成game其它部分，而不是它的图形，和逻辑部分那些已经解决了并很好抽象了的问题领域。

游戏开发业界往往用图形表现的物理效果，如粒子等来表现游戏物理，用old ai来表现游戏虚拟社会，而不是科学物理或人工智能科学

所以对于游戏的设计,我们仅研究游戏设计中的图形部分和ai部分就能基本看到它的全貌了.

请记住，任何好的设计，其主抽象，必定是个内在抽象，揭示事物本质的抽象。

>game ai 与game system programing(如network)谁更重要?

前面说了，业界的做法，对于游戏引擎，，往往是对网络等模块的组合，形成一种”graphic+network based expressed game”，这样，游戏机制，等跟游戏逻辑密切相关的模块，反而被放到了最后。这是最不科学的。(难道ai不比network等desktop complents更代表游戏吗?)

对于任何设计，包括游戏的设计，最最重要的事，就是找出最主要的抽象，业界总是一上来就直接把游戏设计归纳抽象为对图形，网络，人工智能，物理，界面，声音，输入，文件装载，脚本系统等的抽象（或许有少许的游戏逻辑game logic,world logic），但其实，这所有的当中，只有Game Logic才是游戏最主要的领头抽象。这其中，world logic在game logic中又是占主要地位的，至于ai，我们可以用game logic based ai,而不是人工智能界常用的ai的方法。



游戏软件开发工程
-------------

游戏设计制作首先是个工程问题。（这跟前面讲到的基础建设软件工程和CG软件工程是一个道理，因为任何软件问题，最终都将上升到工程角度，而游戏相关的软件工程，就是解决产出一个游戏的人类分工问题的问题）

这其中包括程序部分，非程序部分。这个过程是这样的：

程序员决定写出游戏引擎，游戏引擎是由一个单纯的图形游戏引擎组成的，还是一开始就将游戏的综合问题考虑进来，形成一个“游戏引擎”，甚至在这个引擎中包括了直到app级的所有那些逻辑 如果游戏引擎完工。程序员的引擎如何支持level designer和脚本扩展者，美术艺术家 对于玩家，如何设计

>作为本书的最终目的，编程和游戏编程教育，如果游戏程序还面向学习游戏的开发者的话，或许还要加上二个额外的条项：如何让源码组织最清楚化以便于教学。
2。
上面说了，对于游戏的编程，大都是软件上的抽象问题，故。游戏程序是一个重设计的过程。因为设计的不一，导致的方案和游戏多种多样。

>一般地，人们不使用专门的游戏引擎，因为游戏如果作为“一次程序过程”，来考虑其中所有的算法和抽象问题，这其中要抽象的问题太多了。故人们往往不使用集成化的游戏引擎，而自由地从以一个图形引擎加其它定制组件的方式进行。（这些在接下来的游戏设计中将会谈到）



需不需要一个“游戏引擎”的东西
-------------

上面说到，程序上的“游戏”可以是任何东西，它一定要包括作为图形程序的那些抽象，故人们总是在图形上直接写游戏，对专门的游戏引擎的需求不明显。

对于业界已经很好抽象了的领域，比如game.grpahic,game,logic部分，我们已经在整个第二部分完成了对其的讲解，包括了理论和编程实践部分，对于graphic，理论是modeling加rendering，编程是scenegraphic作抽象， 那么对于一个game，还存在哪些部分没有完成呢？甚至还没有完成解决问题的呢？或者一个领域？没有了，对于游戏，也许只有抽象方面的事没有完成了，比如，关于游戏的系统编程方面的事了。

为什么会有那么多的源码，有的用引擎，有的不用，不同的源码组织（设计）是同一种问题和算法下的不同策略(比如选取用不同引擎)而已

>图形领域需要引擎，游戏也需要吗？ 它的编程不跟图形领域一样，因为游戏本身很接近产品级，故不存一个“游戏引擎”的东西，虽然游戏是一次程序，但这里把游戏当作APP，程序的最终层次，即，它并非“强烈面向可复用的”，因此不必跟wildmagic和fear一样形成一个框架或库，在编程上经过一次设计。 我们把game当作一个app(“作为最终程序的游戏”),即不需要再涉入到未作抽象的领域(需要抽象的领域全抽象殆尽了)，于是不必再作任何架构上的抽象，因此在设计上很简单。

综上，人们往往不承认存在一个明显的“game”中间层，game跟具体的游戏没有间隔。软件设计的一个原则是不要建立太多的中间层，业界仅提倡把图形，物理和AI作为可复用的中间层面作为引擎，不要把事情复杂化，简单就好。 但是我们这里是基于教学的目的，因此要把“解决需要解决的问题”和“展现最大最全最清的程序技术”同时做到最好。

**设计的第一步是对被设计的东西有一个清楚的程序上能“表达完”的界定**，比如一个游戏，如果要做一个大而全的游戏引擎，那么就需要确定是MMRPG的gamelib还是某种单机，比如策略游戏的MMRPG，这里的图形学引擎irrlicht，包含普通功能的偏game的图形引擎。

如果把游戏当作“一次程序”，并为之写一个引擎的话，那么，不应只是像yake一样的纯封装就自称是游戏引擎，游戏没有游戏自己的事（并没有解决所谓游戏领域的问题），就像CG和AI一样，不应全是软件上的抽象，否则，这样的可复用引擎只会固化以后的编程工作。

我们将企图概括全部的游戏程序技术，并加入一个“一次程序”设计过程中。而不是假设GRAPHIC与AI是游戏已解决和已抽象的问题，我们将在这个“一次程序中”统一实现和设计它们，把它们也集进设计。
>我们面对的游戏一般是“generic rts + rpg”系列的游戏，其实，这二种游戏，从脚本的眼光来看，很类似，都需要世界物体逻辑(怪物，角色，NPC)，世界逻辑（做任务，等等），等等，所以完成可以在设计的前端做一个“generic rts rpg”游戏。虽然这个所谓的“游戏”并不能代表所有的游戏种类，但是，经过脚本的变形，它可以在产品设计级形成各种各样的游戏。
对于图形部分:
>图形程序的原型和游戏程序的原型 有一个“标准核心”，虽然游戏程序都或多或少地加进或精简了一些东西，但这些东西一定要或多或少有的：

Graphic上要封装render, Io上要提供scenefile loader Game logic上要提供path finding,ai,等等 WM5与yake等的对比。

>比如对于graphic和整个game的关系处理： 在开始gamelib design的时候，要明白graphicengine跟game engine是分开设计的(这就是说，不必把game lib建立在使用graphic engine之上,而是对graphic engine未知)，然后其它的逻辑可以在这平等的二者之上建立起来了(当然也存在整合这二者的设计 - 从上而下的设计)，故不需要在game engine design的时候考虑任何有关graphic design的事，这就是从下而上的模块化设计，排除了复杂性做得最好的地方。 xx 扩展的内容是无限的，甚至可以为本书增加后续几大部分都不止。比如: 还可以把网络，DB，一开始集成设计做成引擎，而不是在设计的后来作为引擎的抽象，作为设计的高层。


集成图形引擎的设计
-------------


在前面我们曾讲到，引擎在游戏业界其实不但是作为程序上的可复用库存在的。而且是作为游戏产品体系之一的意义存在的。比如游戏产品还有player.对战平台。游戏本身。编辑器等等，对于引擎部分，一般包括实时渲染技术(对DX的支持等)和shader的引入。

###### Shading language

对于一个CG引擎，OGRE的MATH为什么和WM的MATH不同呢，这要看引擎支持什么样的图形学算法，其底层的数学需要也就不同，像WM还提供了细分

着色器本来可以跟cuda一样工作在汇编级，但在现代图形编程中，它是与DX混合被架构的，也即，仅工作在DX固定流水线的最后二级（虽然是最重要的二级），是作为DX的平台部件的，不是独立的平台（如CUDA，DIRECT COMPUTER就是独立的平台）

骨骼本质是坐标空间的变换，关节是原点

###### dx库

故从设计上,“设计一个图形引擎”这八个字眼可以解读为,(我们尽可能列出一切可能) 根据当前需求的功能要求,如果仅需渲染一般的的简单3D事物,那么待设计的引擎甚至都可以不用支持骨骼动画(动画也同时涉及到建模和渲染)等 根据当前实际情况,和业界流行做法,一般在设计图形引擎时,建立在DX,OGL这样的“实时渲染引擎”(注意渲染二字与图形引擎的图形二字的区别)上,这样的图形引擎称为“基于实时渲染引擎的图形引擎”,当然,如果根据某种需求,(比如扩展需求,需同时支持DX和一个软件渲染引擎),这种方案也存在(但一般引擎设计仅支持DX或OGL的实时情况较流行),但软件引擎速度没有实时引擎快,仅编程时涉及到重新发明轮子. 根据当前实际情况,如果引擎需支持最新硬件,或特定显卡,那么从功能上,引擎应能支持DX的shader,或OGL的shader,或扩展DX这方面的逻辑(即它在设计上可能会有一个shader支持框架),以支持特定硬件由用户指定的高级渲染逻辑. 在程序的眼光看来,图形学界的开发,集中表现为一个“数据驱动”的典范,比如,专业的游戏引擎开发,都是要拥有自己的模型格式,即,先产生要渲染或回放的3d事物(我们把这个产生过程统称为建模),然后就是渲染或回放(我们把这个过程统称为渲染),一般地,我们不需要独立发明一个编辑器,因为类3dmax这样的专业工具很多,但是如果真的需要自己的格式,就可以发明基于3dmax的二次编辑器,或向3dmax 写插件作导入转换.但是一般地,专业的游戏图形引擎制作者都选择发明自己的model scene editor.

归纳以上，通常的引擎基于上有二个方向，即，1，基于DX，2，借助向3dmax写plugin的方式求得modeling支持。引擎不必内置类3dmax顶点级造型的建模支持。

从1-4都是设计引擎在功能层上应考虑的事,对于设计,一个有限和具体的设计来说,应在功能上(这涉及到前面介绍的对3D图形学的理解)包含什么是最首先要确定下来的 – 比如我们做的“偏游戏的图形学引擎”应在核心功能级(为用户)最少实现“ActorScene Editing”,“StageScene Editing”,“EffectScene Editing”,因为所谓游戏,表现在图形学上,我们能看到,能归纳到的,不管具体游戏的类型(它是RPG,还是FPS,MMRPG),虽然程序上的抽象可以有很多很多,比如,还有shader,render,app model,rending tech,math,甚至scene graph,但一般地,在面向用户的方面,都可将其框定在这三个方面,(然后才能考虑设计中的抽象,扩展等其它事情)至于如何做,如何做得更好,可以不断完善(**这点是贯彻这章始终的,请十分注意**)因为我们的这个功能设计也是从编程者程序员的角度来说,我们假定待实现的引擎产品只是被用来编程的,而不考虑其面向其它人的要求,比中最终用户,而提供一个脚本系统,这样,我们的设计就可以做到最小而具体. 我们的引擎在功能设计上不打算引基于物理的方法(比如根据当前需求,我们仅需设计一个最普通的引擎),故在设计的抽象和接口,扩展级,不必引入物理有关的其它复杂[1. 如果要在引擎中集成一个物理子模块,那么这个子模块的规模和大小就可足与整个引擎相当了.].这就是我们所说的一般引擎和有限设计的意思所在. 概据我们的实际情况,我们是在写书和受教育,因此我们的需求是虚拟的,为了展现一般引擎的设计细节而不涉及到商用引擎的复杂性(因此我们采用DX,而不用D3D的扩展) 当然,还有很多很多可以细化,比如,决定在引擎中包含一个骨骼动画系统,那么,骨骼系统应是基于动力的还是基于约束的,然后又该如何如何. 假如这里是从8到99条. 还比如,我们的现实情况是,在windows上进行开发,用C++和DX而不用D3D扩展, 们的原型应是功能是最必要的先实现,不考虑的非功能设计部分,根据前面99条,我们的最初原型,应是一个,(编程部分)归纳如下: 我们的引擎是一个不求通用的具体源码，在这个意义上，它组成了一个引擎(而非在设计上一开始就以大而全作为目标的设计)，是一个动态原型。 用户制作模型(非编程部分),为用户提供三个方面的基本编辑器(editor or creater)，并且，一些不必做入编辑器的部分做成3dmax等的插件，直接利用3dmax的某些功能。 我们的引擎应能在DX下在Windows下读取模型并显示它. 因此,这样的原型,（如果它是一个具体的程序[2. 实际上，它也可以仅是一个库，只要源码都可以]）可能之一,就是一个scene viewer性质的模型读取器[3. 一般初学者的第一个产品就是一个简单的模型读取器].


关于通用游戏引擎
=============

怎么样才算是一个足够通用的游戏库，或者说可以从程序上实现，，从产品上配置成任何一种类型，风格或架构，的游戏，，RTS算不算，改良过的呢

游戏程序的架构由图形平台的软硬架构，一次图形程序设计前面临的需求问题（设计和需求，都存在单独一次，，和作为整个程序开发过程中的“一次，某次”的说法）的需要决定，而不是具体的图形算法，或增加新图形效果的需求 

网络游戏抽象体系中，网络与图形模块的可变性往往非常稳定，游戏风格是那些称为经常可变的一类因素，要发明一个oneforall涵盖所有抽象的游戏引擎，图形和网络基础只需抽象到常见那些桌面抽象该有的抽象就行了，当然，不排除对那种极端追求新图形效果的游戏进行考虑 

一般需求的设计的游戏往往只要求桌面程序通用的那些网络，图形抽象，而多变的，多需求，多方面的游戏，它往往需要更多的算法抽象和非算法的抽象被集成。 
通用游戏引擎，与单用的游戏引擎相比(demo或原型)，它在设计的第一次迭代过程中便将自己定位于包含尽可能多的算法抽象的，开发上所用的库，而且，它提倡用框架抽象的非算法抽象体系来组织它们。 

游戏风格（多游戏风格支持是一种产品需求，产品需求是一次设计的需求定位，当然，你也可以虚拟一个足够通用的程序，那也是一次设计）的东西，，同时关乎程序上图形（效果），，网络（连通），智能（智能是程序上影响游戏可玩性，和风格最重要的因素），， 

其中，通用图形和通用网络游戏程序抽象的事情比较固定，通用智能，通用可玩性的程序抽象可以随所谓的游戏风格各各不同，无尽发挥。游戏在这最后一个方面可以呈现出各种不同的风帽。 

多风格，意味它是一种较其它游戏程序（开发库）在产品特征上最大的不同，，如果它是游戏产品要解决的最大矛盾，，那么，游戏程序的开发，以后仅使到这个多风格游戏的库就足够了。 


问题被归结为：多典范游戏关注于游戏风格（任何一次设计都是整个设计时间，软件生命周期的一次步进，一段设计迭代，，而且，每段设计迭代只关注于一个切面，，无论设计多大，都可以进行这样的周期和切面的细分） 

存在什么样的架构组织那些游戏在程序上的算法抽象 

这种考虑往往基于提供好的框架，以接入越来越多变的图形算法，但是，框架（为了抽象而抽象）往往是相对稳定的，而算法抽象往往是多变的 

比如,fear 中，animator这样的由body,ability组成的抽象组，组成的大抽象，显然也是一种架构

product supports
=============

the topmost of a game shouldbe visual world（game graphics and ai） and real world（game network），of which units （visual）and player（rea） is the easseay

gamemod．scripting from native module 往往只有两块：game．visual and game networking 

gamemod．scripting其实就是game．logic写成的scripting 

game．mod就是mod．gameplay和mod．gamelogic 

map is gamelogic corrspandings to stage.tile

地图编辑器在3dmax和最终的图形世界网格的中间，充当了一个中间角色，它将一部分工作留给3dmax,而由编辑器完成大局的拖拉工作，这个意义上，可以在在地图编辑器中集成网格编辑器，也可以在3dmax中写插件组合网格内容为场景(但往往没有后者获得的功能强大) 

地图编辑器强调关卡设计适用，拖拉组合是必要的，3dmax是通用创作工具，强调从网格开始，除非插件提供这方面的支持转移或增强这种工作，网格地形和非网格地形，前者是制作的，后者是生成的

虽然3dmax可以完成地图编辑器的所有工作

小总结：there is no “recommended,one time – monlicth””must-use”-game engine designing
=============

那么游戏在程序上是不是就没有一个通用的框架呢？[6. 没有一个通用game,即使以后在脚本层可以定制各种各样类型的游戏(比如 war3 mods)，但在引擎层，编译型语言要写大量代码才能达到这个效果，故war3 就在引擎层只实现了一个world,world logic。而将那些强烈需要定制的程序逻辑留到脚本引擎之后，同时也是为了留给用户编程的需要。]

editor并不属于notwar3.extending system中的东西，因为它是notwar3.game级必要的东西（gamemain和gameditor构成notwar3.game）。 故我们发展的是四合一的game demo

为了获得通用game教学的效用。我们将着眼市面上最典型的代表最大范围游戏的那些游戏的程序技术和工程过程，以综合论述“什么是游戏”，什么是游戏编程，如何进行游戏编程。以求得“游戏在程序上存不存不一个通用框架”这个答案。

本书最后提供了not xx series,是经调试流行游戏技术而来后仿设计编程的，故体现了流行的游戏编程技术。这个针对not xx系列的综合demo集成了这些游戏的所有特征，揭示了这些游戏的关键设计技术（我们将做相关游戏的官方源码或第三方源码的hacking,以及游戏数据的hacking,后仿设计写出这个demo，这也就是调试的反工程的目的，即调试-设计-编程的循环，模仿是人类的本能，**源码hacking和模拟设计，将极大地加强你实际编程的能力**）
