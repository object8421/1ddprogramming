计算图形学,AI及对应vr/game graphic,sr/game logic,game programming(solutions and their implents in programming)
=============

———————— 一般性问题举例之CG·3D,VR/Game·Graphic,Logic,game

game programming problems 一般归结为cg问题，CG问题一般归结于animation和cd，更多的问题属于高级主题（如物理表现的game因素，AI表现的game因素），但是我们在这里按modeling部分和rendering部分来组织它们。

modeling,then,shading,,而不是modeling,then,rendering,,render=model,shader


scenegraphi is just about mixly rendering a scene and viewing a scene
rendering and viewing a scene 是game graphic programming的主线抽象
so ,,,scengraphic is game graphic framework,,like qt widget cavas view framework







modeling (1) - 3D中的数据准备-预生成为顶点的模型:空间与物体几何形状属性，物理行为属性表现
=============

modeling[1. 在整个引擎的层面上,从程序上来说,MODEL 实际上可以是 Skin model (shape model ),bone model,Pysical ,effort model ,terrain model ( 我们把包含顶点信息,最终以顶点形式进入GPU的一切 3D 元素,称为 MODEL,这是从GPU角度来说的), 所以实际上, model 就是 sence 场景] (1) - 3D中的数据准备-预生成为顶点的模型:空间与物体几何形状属性，物理行为属性表现

所谓预生成为顶点,就是指:3D中的数据准备(1)预生成为顶点的模型: 空间与物体表现,这是指用户动作,不管是混合DX和GPU的混合式rendering,还是基于纯GPU或纯DX的rendering,用户数据的准备,可以是第一步的,但不是必要的(纯DX可以过程化产生,纯GPU可以即时产生,而不导入建好的模型,这就是“实时”二字的来历).

>本节的安排依据

假设你只是要全程利用gpu作rendering,在这个阶段,dx流水线都是不可见的(需要你自己写变换),因为你在low-level而不是使用DX内置的流水线进行rendering,当然,你也可以混合使用它们.因此,你既得到了高级的流水线,又得到了适时将自己写的变换放到low level,形成自己的流水线的机会(当然,流水线是一个例子,你还可以定制除变换之外的其它算法) 我们现在基于dx 和GPU的编程,就是一种高低层混合使用硬件和软件能力的过程.

空间，直角坐标系，朝向与方位，空间变换（50p）
-------------

坐标与空间，空间与snece区别是什么

欧式几何空间，是一种正规的空间及其中的点元素，线段元素，首先，我们应脱离利用坐标（尤其是笛卡尔坐标体系）来解读它的观点，应用纯数学，线性代数的观点来解读它，这就是说，虽然欧氏空间的元素，比如点集构成的欧氏空间，的确可以被解析为坐标的东西（因而具有带有坐标痕迹的度量），但欧氏空间，最初是作为综合几何出现的(是纯数学意义上的几何空间，此时并没有坐标出现)，有一套脱离坐标就在代数上就可以很完备地自我描述的数学体系（甚至是度量，也可以脱离坐标而被实数的某种代数式被表示），这个体系较之套上了坐标的欧氏几何更原味，比如用多元组表示平面或空间点，用线性变换表示点被平移，等等，因为被纯代数描述，所以它也更广泛。因为代数手段，往往比单纯的解析几何更广泛，我们可以从代数上发现欧氏几何更多的性质。

坐标系仅是一种解析手段，它没有描述出一个诸如欧氏空间的几何上的空间。所以，坐标系并不是一个空间。数学上的向量，矩阵，线性变换等等，仅仅是数学，当它与坐标法结合的时候，可以表示一个“用向量来刻画的坐标点(向量其实是一种代数量，此时，若不用到解析法，它就不只解释为一个坐标点，它也可以表示一种方向，或其它任何可以解析向量这个代数的其它领域的东西”“用坐标刻画的欧氏几何空间”，及“变换表示的坐标空间的坐标变换”

这其实也就是克来因的思想，变换是一种代数思想，线性代数所描述的变换，是一种独特的变换，

线性代数及
**欧式空间 **

空间剖分技术包括,space剖分和模型空间剖分

**笛式空间 **Xx x轴方向由Z轴和Y轴向量的叉积确定，这是不是跟旋转原理有关？

**向量空间 **

在几何上并没有一个向量空间,只有向量.我们是在用量模拟空间.这是因为粗略地讲,3维向量空间就是3d空间,但其实,人们是在利用数学的手段来解决3d空间中的坐标问题.

>这是一种向量空间.向量空间对应于3d空间(或任意d空间),因为在数学上,向量空间与线性空间同质,向量就是三个分量相互联系的代数系统,因此我们可以借助数学的手段.来处理空间上的3d问题(当这样的空间是位置信息的时候). 比如对于直线的方程表示.对于球的表示.都可以用x,y,z来的方程来表示

xx
空间的引入,就为在几何上表示物体的确切位置,用数学方法来解决物体的动态表现(比如移动)提供了可能.这些都属于建模和模型表示的内容,因为此时,我们并没有必要处理物体的实际运行.

>vector和点，它们的数学表示相近（用三个分量表示），但其实概念不同，(在图形表示上)向量是一条线，它同时具备大小和方向。而顶点只是一个定点，任何向量可表示为原点到向量所在点（它的数学表示）的一条有方向的线。同时，向量间的图形三角形法则可以很好地用于表示向量间的加减。 将一个向量标准化，就是将其大小弄为1，这样，它的方向就突出来了，因此一个向量的标准化，它的几何意义往往是该向量法线。向量间相乘，有点和叉乘，点乘在数学上的形象表示就是用一点相连二个向量，得到的是一个标量，它表示二个向量的大小和它们之间夹角余弦的最终乘积，它的几何意义就是二个向量的相似程度，如果这个标量大，那么这二个向量方向和大小都相似(夹角小并且方向一致且大小都大)。向量间的叉乘，形象表示就是用一个叉号相连二个向量，得到的结果是一个向量，它垂直于这二个向量。 vector有多少个分量就有多少个维。依之称为三维向量，四维向量等，矩阵的称法依据它是几行几列，称为几乘几维矩阵，行列式是矩阵的一种特殊形式（一般矩阵用[]括起来，而行列式用双竖线）。 vector有matrix间的关系可谓千丝万缕，矩阵是向量的数组，任何一个矩阵都可以分为几行几列的向量，单一的一个vector自身就是一个矩阵，它是3x1矩阵，或几x1矩阵，到现在为止我们提到的向量都是行向量，所以如果将它看成是一个矩阵的部件（矩阵是向量的数组），那么其实还可以产生一种列向量。在将向量与一个矩阵相乘时，向量的行列属性就会起作用（不允许一个矩阵右乘一个列向量）。 矩阵的运算有多种，如果一个矩阵的对角上全为1，其它全为0称为标准矩阵，它是矩阵乘法的标准元，它与任何矩阵作相乘都会得到该矩阵自身，矩阵的转置表示将对角线上下的元素互换，它得到另外一个矩阵，一般地，如果原矩阵是4x3,那么转置矩阵会是3x4。 一般矩阵间的乘法运算很玄妙，乘数与被乘数位置不能改变，一般意义上的矩阵乘法可描述为：产生的最终矩阵的Cij是乘数矩阵的i行向量与被乘数矩阵的j列向量的标量点乘积。

xxxx xxxx
**在空间里表达图元，顶点 **

空间里的物体,都是用顶点来描述的,所以对物体在空间中的表示和变动表示,研究顶点就够了(在某种空间里,物体中的一个参考点,和除参考点以外的任何点,都是相对的,将这种相对位置表达到空间其它位置,或其它空间中,就是“transform”,也会保持相对关系).

为了使一些效率敏感的事物能在CG中被快速处理，经常用简单几何体来代替复杂事物，这时，就涉及到关于这些图元的数学表达，一般地，用几何上的参数方程来表示一个图形，但是要知道，参数方程只是表示数学上的抽象和参数，并不关乎实际的绘制，并不能得到一个图形，我们只是用这种数学归纳，来表示几何事物，以处理关于它们的碰撞，消隐等等
**空间间的朝向与变换路径表示 **

欧式空间的坐标和笛氏空间的坐标,都能很好地指明位置,然而不能直接地表达物体的其它一些属性(比如朝向,必须计算得到).这就需要其它空间.当原物体是用这二种空间表达的时候,只要变换到这种“其它空间”,就到在其中得到一个显式的朝向信息.这种“其它空间”之一,就是易耳空间.

“变换”一般指物体在二个坐标系间相对变换，一般是“方位”的变换，所谓“方位”，其实是指“有位置，有朝向”的物体，其变换到另外一个空间后，二个空间坐标系相对位置和朝向的变化。

**3D中的2D：平面，定位 **

2d image world 就相当于3d poly world，如果最终被渲染出来的效果被看做“某种图像的话” 在3d中,与之对应的是3d image.即用多边形或其它数学知识表达的模型 当3D的东西,比如顶点定位逻辑,运用于2D事物时,比如一张贴图,比如使一张贴图旋转,形成“公告板效果”,这就是一种2D中的事物被利用于3D(借助某种3D手段)的现象.

我们上面说到,渲染不带纹理映射的逻辑的单调图元.实际上,你也可以加入表面处理(实际上,对于渲染器来说,只要用图元逻辑和变换逻辑就够了,加入表面处理,是为了极大地增加3D的可视性和真实性,比如,粒子这样的东西,也不是d3d的必要core部分,由程序员自己提供解决方案),即surface model的处理.(在游戏开发,有一类特殊的surface model,这就是地形,水面,等等,.当然,地形上面的植被不算surface model)

D3d所涉及到的内容中,一般都分为三个层次.1是硬件支持的.纹理映射方式的基础,是需要硬件提供直接支持的,比如硬件支持什么纹理格式.2,是d3d中有对应的,3哪些是它被用户扩展的,软件抽象的.模型,其实不是d3d的内容,几何体才是.X文件中.在了解direct3d关于它各种渲染技术的时候,至关重要的,是明白哪些技术是d3d内含的,哪些是它被用户扩展的(比如粒子系统,billboard,d3d中本身没有对粒子的直接支持,还比如lod和mipmaping,mipmaping是处理用于mapping的贴图本身的,lod处理surface model的)

这样我们就可以做到lmtpractise.

**对surface model的处理,实际上可用于一系列更高级的过程(比如,多边形模型的贴图,就是对其每个三角形surface model进行一次贴图).因为表面,实际上就是一种特殊的3D立体,即,用多边形模型和用表面模型,是解决模型问题的二种常见手段(比如,billboard这样的东西,往往是一张表面模型)**
然后,就是讲解颜色数据对于图元的“坐标映射”了.我们这里谈到只是2d图元的坐标映射,关于3d映射技术,有一系列高级的方式,比如uv, 环境贴图,等等

贴图,是一些颜色数据,比如一张图片.而纹理,综合描述了图元表面(以此达到一种给pure三维物体增加真实视感的效果)的各种情况,比 如,什么贴图的颜色数据,甚至什么光照,什么粗糙度.

纹理映射,贴图,mipmapping, direct 3d中的x,dds文件. Light与texture结合产生环境贴图等.烘焙贴图等

纹理,与材质是什么关系呢?纹理上贴材质吗?虽然有些程序在抽象上提出一个“纹理层”,但其实,d3d的眼中,只有纹理与材质,及映射. 没有纹理层(d3d不直接支持,可以用户程序扩展)

**易耳空间 **

用四元线表达的变换，最终要还原成矩阵进入图形管道，它是写给人看的

只有满足正交条件的矩阵才能用于表示旋转，旋转矩阵可用于表示变换，表示算子，还可用以表示方位，然而，表示方位时并不合适

**直接用向量表达的变换 **

有了空间表示,物体表示,和物体各种可能朝向的表示,那么我们可以作任何变动了,这种变动一般分为三大类,即平移,翻转,缩放.(变动不光是位置上的改变,还是大小,朝向,和比例上的改变 – 也是位置信息的改变)
**用一种更方便的数学手段来表达的变换 : 矩阵和四元数 **

Xxx
**在空间里表达物体 **

模型一般预生成,也可以即时在渲染过程中提供顶点(及如何操作顶点的逻辑 – 可能是建模,也可能是直接变换顶点,以求得水波这样的效果).这二种动作其实只是向渲染器投放顶点时机的差别(预生成的模型只要化成顶点进入GPU被渲染).只是在DX runtime,我们可以在高于顶点的级别,比如三角形级方便地进行一些算法(这种动作是故意的),而在顶点级,我们可以利用处理顶点的方法来达到高层次不能完成的事(也是刻意的).或更好完成的事.比如那些仅通过处理顶点就能达到目的的事情.这仅仅是同一个现象对于编程者带来的控制上的差别.对于硬件,是一样的道理,它只有vetex processing和pixel processing这二个阶段.就足于处理一切.任何渲染,都可分解为这二个部分.

所以,一旦投放顶点的策略不同,算法也会不同,即解决问题的方法也会不同.

对于编程者来说,很难说这二者哪个好哪个差,哪个更高级(甚至现在的图形编程允许混合使用它们),只是层次和具体问题具体分析问题,这就是顶点和模型对于编程者带来的层次问题关系.

模型往往可由多边形构成.组成surface model或closed surface mode,即solid model.

前面几个章节对顶点的研究,使我们可以进一步研究复杂的图元(对点的支持,可以用来构造下一级复杂的模型).比如三角形的表示和变换,而模型,作为下下一级更复杂的东西,可以由更更复杂的三角形(扇,带,网)表示.

计算机图形学采用三角形[2. 当然也不乏例外的情况,比如用参数化的曲面表达模型.但我们研究的是用多边形方法解决的图形学中的一节.],是因为硬件和算法(包括我们之前讨论的种种空间,这些是算法的数学理论基础)都能很好地操作和用于三角形,也其实更是为了方便人们讨论模型(所以仅讨论多边形中的三角形,因为直觉上它是多边形中最简单的一种)

dx只给出了网格存储和渲染逻辑，没给出网格生成的算法(它们被实现在硬件中)

>网格不过一些关于多边形(在程序上)的数据结构(为了更方便所以仅研究规则的多边形形成的扇,带,网,而不是凹形的),关于如何在多边形的研究上建立网格,就是程序的事了,而不是3d的事,渲染器会负责提供”tellseation”过的多边形,一般为三角形. 图元一般取三角形.是因为硬件能很好处理它,一般的3D模型软件,将三角形作为其默认的生成格式 当表达到网时,往往接近模型了

下面我们来讨论多边形.首先要解决的问题,就是渲染器完成如何将可能不规则的多边形,进行向规则化了的三角形的转换的动作.如上所说,这称为“tellseation”

形状表示，边界表示，曲线造型，渐进化简表示[3. 一般地,人们把用多边形解决的图形学称为真正的图形学,不排除用其它方法建模渲染的其它图形学.]
-------------

**多边形 **

我们先从学科角度来研究一下多边形,再来讨论三角形这种特殊情况,这就是计算几何上的事情.

计算几何不是计算机的几何,而是用计算数学的数值分析方法来解决的nd几何问题(所以是数学的几何).它研究nd空间里多边形的学说(当然不是全部,而是特定的一部分,比如拓朴问题?相交检测问题,这些,正是3d图形学迫切需要的).

它解决如何给“多边形能模拟模型的表面[4. 多个多边形连起来的情况就是网格,mesh是多边形的另一种说法,plane是数学上的平面,grid是四边形网格],这个方法行得通吗?如果行,怎么做得更好”这个问题,提供理论上的支持.

首先,计算几何(到本书写作时)已发展为一门well documented的学科(计算几何：剖分，凡尔图，排列，〔基于terh的〕网格生成，网格细分化简。kintic〔运动路径算法〕。),它完善地解决了几大问题(这些问题证明,多边形模拟模型的时候,会碰到哪些问题,对于诸如检测这些多边形是不是相交这些实际问题,计算几何都给出了好的证明和解决手段,所以,这些都显示,它能被用于模拟模型的表面表示,可以用于计算图形学,).

哪么对于计算图形学需要的多边形,计算几何都作了哪些解释解决了哪些相关的问题呢,第一,就是对多边形拓朴的解释.

首先,n维空间里的多边形有凹凸的,组成这个多边形的n个坐标分量往往不在一个2d平面内(我们在3d空间选三角形,是因为它肯定处在某个平面内,是planr polygon).这种现象,导致了以后进行多边形的边界(多边形的边界就是它的边,然而计算几何还研究多边形组成的壳,这种复杂边界)相交讨论时的诸多不便.

>In contrast, graphics hardware uses triangular polygons as its primary geometric mitive. One set of programmable shading computations is performed at the verti- of these triangles, prior to their transformation into screen space. Then, the trian-使用三角形,是硬件的决策,使用曲面,是软件renderman的决策.

实际上多边形模型也存在贴图问题(uv贴图),但是我们这里不讲了(当然2D模型,即表面模型,也存在变换问题),我们这里只讲变换.

LOD版本，是一种程序上的过程建模方法，它生成一个渐变的动态模型，是一种从下而上的方法，跟建模的静态方法不一样

什么是多边形模型呢,就是“组成它的顶点”那种加入了z深的2D模型(有时还有第四个量,即w).于是变成了三维,因为它有三个坐标,所以它存在一个高于2D的新环境,就是三维世界.需要定义一套新的坐标系等东西.

以上,我们在讲解表面模型,即3d世界中的2d世界中,用的顶点依然是3d的,不过去掉了z,w分量.而且,除了纹理映射,其它的,都没讲.比如变换,这就是我们在这里要讲解的问题.

z深测试,与Z深混合.透明立方体,
三维世界,除了顶点,还要特别要涉及到一个矢量的概念.矢量,即一个3d世界中的位置.它不是顶点,而是(顶点间的)距离.

而矩阵,就是变换的表示.一切图元的变换,都可以归结为三种形式或者它们的综合作用,即位置上的平移(这用矢量可以直接描述),大小上的缩放(一个),变换,是以图元或称模型为主体的.模型从一个当前表示,到变换后的当前表示,中间发生的变换,可以用一系列矩阵(注意是一系列)来表示.

在变换过程中,有一个插值的概念.这就是一系列轨迹.也称关键帧.这些martix形成一个堆栈.

这些所有的概念,就导致了骨骼动画.(一个复杂的模型,往往分块制作,这是美术的要求,也是3d程序的要求,比如,只有不是那种一整块的模型,才有层次关系,才能产生骨骼等,所以就有了几何体geo的概念).

骨骼是一系列的变换集.动画,是一些时间集.

模板缓存,
**多边形拓朴与化简 **

多边形间的拓朴可以化简(而保持总体结构上的相对不变性),这意味着我们可以计算出多边形间一系列的“精或细”版本.在计算图形学的渲染中,这些技术可用于LOD(往往为了效率起见,要知道,渲染中的多边形数量可控要求,是计算图形学要解决的重大问题之一),那是后话,我们暂且不提,只要记住,基于多边形间拓朴性质的化简动作是计算几何为计算图形学解决的几大问题的其中之一.

>Lod技术如何化简面,而不改造物体的外观(组成物体的多边形网格的拓朴结构)呢 首先要明白,这是一种动态化简技术,即在渲染中化简.是摄像机依赖的实时渲染. 拓朴化简,欧拉图的出度与入度

研究多边形的拓朴学说,就是计算几何的一个重要内容 把导出问题的部分写得比例大一些,比如像计算几何导论导出图形的交问题一样 检测交,被用来进行面消隐,是这个动作的基础

**(计算几何3)物体的边界表示 **

计算图形学,不光要解决物体本身的表示,而且要在给定物体多边形模型表示的基础上,要求“计算出”一个边界,即对于物体“边界”的表示(用户可以为一个模型生成边界,也可以通过程序计算出一个最小的边界).这是计算图形学迫切需要解决的问题(前面说到,可以借助计算几何中多边形组成的最小凸壳的边界相交问题的讨论来完成).

>边界表示可用于计算图形学诸多高级问题,它是一个多面手,比如:最直接的用处就是检测相交,用于不可见面剔除,快速进行场景剔除和空间管理,用于进行碰撞和碰撞反应.用于鼠标拾取.

计算几何中讨论的convex hull是一种精确的最小“边界”,实际的计算图形中,用了大量的非多边形,比如球(它有一个曲面),正方体(它有六个多边形).所以它讨论的“边界”问题,其实只是计算几何讨论的一小部分.
**多边形相交的检测 **

同样的,是对于多边形间,和多边形组成的壳间的相交检测,也是计算几何为计算图形学解决的几大重大问题之一.
**多边形模拟网格模型 - tellestion **

拓朴的研究,为tellestion提供了基础(如何tellestion,就是整理拓朴).

而进一步的网格模型的表示,其实都是程序上的算法和数据结构上的事不是3d的事,不必多谈.我们只要记住,DX这样的software hosting runtime,往往用了表达多边形(三角形)图元的绘制手段(带,扇),外加缓冲与索引缓冲数据结构上的手段,并在这两大基础上表达网格模型.

**面的细分 **

细分〔subdivide〕与化简〔lod〕是一对互逆过程。细分是使几何体面数增多，化简是使之变少。

要分开曲面细分与曲线细分的区别，曲面细分是根据多面体进行细分来得到一个光滑的曲面（它根据的是原多面体的几何特性并由此控制最终曲面的生成），而基于样条的曲线插值得到的光滑曲面是基于数值方法的,用户需要涉入数学方面的内容。

**(计算几何2)表达空间里的曲面 **

>大约在运用到曲线概念后(多项式也即非线性的物体运行路径，速度，角度变化)，图形学中的线性代数慢慢转向为使用微分几何中的曲线论来解决问题（当然，需要CAGD来对纯粹数学的曲线改造，使之成为图形学适用的曲线论-非线性变化论）。

值得注意的是,用数学上数值分析办法来研究曲面的几个人之一的forrest在1971年使用了“计算几何”一词.一般地,现今的计算几何学科也包含曲面的知识.这是数学上的数值分析中的插值,它被用于解释曲面,就变为计算几何上的学科.这是学科渗透产生新学科最明显的例子之一.

曲线常被用于用于生成模型.也用于计算图形学的方方面面(控制路径形成动画等等).作为曲线数学基础的插值知识也是如此(被用于计算图形学的方方面面,比如纹理映射).

在如何求解方程的值上,最初发展出的数学分支是初等代数,它的主要任务之一,就是解方程(一直到解一元五次方程),再然后是线性代数(为了解方程,它抽象了代数为代数系统,用了行列式,多分量数据 – 向量,和矩阵的手段),再再然后,解方程的学说,经历了一个由前二门学科组成的以精确解方程的解到以后的“近似方程解所代表的值”的过程,此时的解方程学说不叫代数,或高高级代数,而是“仅仅对可解出的方程数值感兴趣”的解方程学说,即“数值分析”中的“插值”一支.

这些在书后的附录部分《3D图形学的数学和物理基础》中都有讲解.

曲线是一种几何和数学现象,它可以用方程来精确描述(我们以前学的是平面解析几何,并没有利用向量来解析几何直线或抛物线,因为它仅有二个分量,解析几何仅利用以前欧式几何的知识来解析平面几何,所以不需要向量及其分量所构成的方程概念[5. 其实，欧式几何也有一些3D几何的成份]).我们前面讲到了直线的方程式,它是用向量表示的方程式(向量观点来看的空间,向量空间,请注意这个概念).向量空间,就是用解方程的手段来处理对应具有几个分量的向量的代数系统(所以也是代数的手段,比如,它能用于解方程).而分量,也其实就是方程的x,y,z,当把这种方程用于解析n维空间时(对于x,y,z,当然就只是3d空间),就形成了n维解析几何,解析几何中直线,抛物线的表示,和它用向量来表示的形式是不一样的,(对于直线和曲线在向量空间的方程表示)它们称为直线,曲面的“参数形式[6. 那种用delta t表达的参数形式]”.

>实际上,我没有说“它们称为直线,曲面的参数形式”,这是因为只有3维空间才有面的概念,推广到n维空间,其实这作为一种含盖平面,3维,任意维空间的所有向量能解释的现象,称为“面”反而不合适(它们有一种更复杂的称法“叫流形”),所以还是称为3d里的“曲线”,nd里的“曲线”.这样反而更通用.

插值问题是这样产生的(它一开始并不一定是生成平滑曲线的问题而是一个通用数学问题,):需要产生一个(注意是一个)近似函数(这样的函数在数值计算上被称为样条函数,如果产生的函数是几次的,就称为几次插值函数[7. 不要因此而理解为,插了几次值],插值的意思是针对“这样的函数在几何上表现出来的曲线要准备通过的函数值”来说的,也就是说,这些预提供的“值”要做为待模拟近似函数的值[8. 在这个“值”前,我们不要加近似,近似只是指函数的近似]).或称,这个函数的几何图象会通过“插值问题提供的某些样点”.

>Interpolation versus Approximation

插值一般有线性的(对于问题中提供的样点,会产生一个一次的近似函数).

而德国人皮埃尔倍塞尔的曲线生成里面用到的插值点,样点,只是一些“控制点”,并非最终产生的样条函数要一一通过的点.它是更高层次上的“控制样点的点”.在这个层次,它永远是一次的.连结控制点的,就是一些线(一次的方程能表达的直线).

那么,如何控制控制点,使控制点动作起来,它会产生什么样的意义呢?是生成样条点的动作,然后这些样条点,才会被用于控制生成最终的样条函数.
一维catmull-rom样条插值.曲线拟合(插值：给定一组有序的数据点Pi，i=0, 1, …, n，构造一条曲线顺序通过这些数据点，称为对这些数据点进行插值，所构造的曲线称为插值曲线。常用插值方法有线性插值、抛物线插值等。 逼近：构造一条曲线使之在某种意义下最接近给定的数据点，称为对这些数据点进行逼近，所构造的曲线为逼近曲线。 拟合：插值和逼近则统称为拟合（fitting）。).

对[a,b]上定义的函数f进行插值是对该函数的一种逼近，逼近的精确意义与“二个函数之间的距离”有关。

有个法国人中译名也叫贝塞尔的,不要跟德国的这个人混淆.

>最初的曲线只是一些折线段，后来出现了用数学逼近手段制造的真实曲线。这些曲线是纯数学的，图形学不能直接渲染得到。 这样的插值是三次的.

可以外加一个插值option选项,权重0-1之间,指明这些样条点是不是要一一通过,一一通过的话,就更平滑, 所以,样条点的选择,为了平滑性起见,是要慎重选择的”(当然,样点只是抽象说法,它既可以是数值,也可以是矢量位置,对应的插值就成了value interptoring,或vector interpoting)..比如有四个点,那么该曲线就会有三条曲线段(这些会产生四个系数,这四个系数组合而成整个这个曲线的多项式).当权重指明只需要一个样点时,整个插值曲线,就是第一个点所在的导数.这样样条点,既是数,点位,也是作为平滑度的意义存在的.所以本身也是导数(即权重本身).

平滑度系数,导数,样点,这三个东西不一样

样条,是函数,或插值用(或称产生)的多项式,如果是三次多项式,说明需要四个节点,节点可以是任何东西,比如一个浮点数(这就是说,对浮点进行插值),甚至是一个具有三个坐标分量(x,y,z)的顶点(这就是说,对顶点位置进行插值).即,这些(如果是四个节点)样条函数曲线(在坐标上用解析法表示这些插值多项式时)穿过这些节点.插值就是对这些节点进行插值.

样条是指函数,不是指如上所说的取的样点,样数点数,样点或样数,只是被插的对象.实际上,一切都是切线(每个插值多项式表示的曲线的导数)在“规定”这些样点.

**用曲线面片patch来表达平滑的物体模型 **

计算机在本质上，而不是模拟的办法，能绘制出真实的曲线吗 这往往是renderman的策略

**可分解的层次物体(刚体) **

我们现在的建模是结构化建模,骨骼动画必须分块,这样才能形成整体上的动画 建模的这样的物体,往往是物理模型 那么,应怎么样才能建立起层次型的物体呢,使其各组件具有关链性呢?(当然这样做肯定是为了某个目的 – 事实上我们以后会知道那是模型动画,但现在我们只考虑如何建立模它).

>什么是层次模型和建模 我们知道，建模的复杂性，在不同的情况下涉及到的复杂度是不一样的，比如动画的建模，如果仅是对一个正方体作平移，那么仅需要手工指定其平移向量参数（正方体有自己在世界中的位置，关于它的动画，全程只是组成正方体的坐标作平移变换）。

但是如果对一个人进行动画建模呢？如果仅是靠上述的指定参数（对人物各部分作变换，指定其参数，为了使这种动画显得真实，那么协调各部分这些参数就会显得尤为困难了，而且，人物的各种动作，其面临的复杂度根本不可同日而语），故，我们将复杂度分散到各个部位，仅考虑各个部位的变换，然后再指定一个统一的，到世界坐标的变换，这些，人物整个地就能合理动画了，而且，降低复杂度的目的也达到了。

人的动力系统跟车的不一样,表示人的动力系统,用一组有层次的骨头,和IK,FK就可以解释.关键是定义正确的骨骼.

动画，是一种运动，而变换是数学上的（几何）概念，它的全称应为相对变换（比如，发生在各种抽象空间中，由一个空间变换到另一个空间的拓扑变换），虚拟的图形世界中，有套坐标系，物体在系中相对另一物体变换，自然等同于统一相对原点或轴变换。。

计算机动画学是物理（刚体动画）和数学问题（插值，解微分），3dmax内含建模生成动画的逻辑，图形程序员只负责playback而不需要掌握物理和数学，一个图形引擎中的动画件，却需要这样做（如果他要提供一套‘反向动力动画生成器’之类的东西，当然，载入动画文件然后负责播放并不需要。）。

关节是变换原点（加可变换角度constraint），两个互为父子的骨骼间往往有关节

skin mesh指出了mesh可包裹变形数据变形的方面（往往是骨骼系统），ani mesh指出了mesh可被用于受矩阵变换形成动画的方面（往往关键帧是sampled而来的，中间帧是插值而来的），这两者并不矛盾，可复合形成“蒙皮骨骼动画”
所以“蒙皮骨骼动画”中，实际发生了变形动画（发生在网格和它们相对于骨骼的权重间）和变换动画（发生在动画数据对骨骼的变换，进而带动网格的过程中）两种。注意：网格，骨骼，动画这三概念中，骨骼数据不是动画数据，动画数据也不是骨骼数据。
要分开关键帧和关键帧动画，关键帧只是（关于层次模型中某段网格在关键帧对应的那个时间）某个动画数据（比如位置信息）的一个采样（它实际代表了相对上帧的变换，所以是动态的动画数据）。骨骼只指明动画数据如何随层次变动的逻辑。
骨骼是对动画发生的层次结构和（动画所代表的变换所关于的那个）原点，以及动画如何发生的constrains的指定。骨骼还是对皮肤网格如何形变的权重影响因子的指定。

bind pose是初始变换矩阵，它是骨骼，骨骼并不是显化的几何体（它没有顶点和位置属性，它是变换和权重信息），骨骼动画系统中，几何体仅指受骨骼变换的skin（即模型本身）

骨骼动画要求层次模型，因为骨骼动画是层次变换，当然也可以变换一大块整体上的几何体做动画，不过那样又回到了顶点动画的范畴了。

比如传统的动画技术就是以一定的频率（帧率 —— 注意提到帧率就等同提到时间因素）翻书，期间每个帧的细节都要被提供，关键帧动画则强调只设置两个¨关键¨帧，可见它是一种¨在不确定的一段时间里能平滑播放生成的中间细节¨的动画体系（并不强调平滑生成）。

动画是随时间流的步进产生的三维变换（线性计算）来形成的，每秒帧率这个词同时说明了一秒播放的帧数和播放一帧所花的毫秒数，关键帧动画所定义的两个关键帧中（必然存在一段可供播放这段动画的时间，它可能是不定的）

**跳入跳出的效果需要谈入谈出的效果来消除。**

关键帧的帧间插值到底解决了什么问题？它使动画变得平滑，平滑是相对每秒帧率的平滑。比如，定义良好的两个关键帧间，其间的动画在playback时，在20和60的帧率差距下，都不会显得不平滑（动画始终能做到按定义的效果播放）

**关节是关节,骨骼是骨骼,控制是控制,不要混淆了这三个概念.**

>对于基于骨骼和皮肤网格的动画，存在二种情况。（这里以人体来作为例子，实际上这也可用于一切刚体物体） 一种就是简单的animation mesh animation，比如，将人体各个部分（头，上手，下手，等等）独立看待，每个部分都有一段骨骼和一段皮肤（即，一刚开始并没有显式的关节概念，网格段的重合处只是简单地相联，骨骼并没有相连形成关节，各关节处的网格只是简单地受它所属的骨骼影响），对应的骨骼影响对应的皮肤（这个动作在建模时会被“预计算”），动画数据作用于骨骼上，带动各骨骼所属的皮肤网格作动画。 这种动画，会在“关节处”（这只是指人体的关节，在这种动画中，并没有一个显式的关节抽象）造成破裂。 另外一种，就是将人体整个地看待，假设它有一张完整的皮肤网格，每个部分有对应的骨骼，与前一种动画不同的是，在关节处(虽然在程序上不必提出一个显式的关节，但较之前一种动画，这里的关节的确是有意义的)，各部分的骨骼除了影响对应的皮肤段，还互相配合影响二段骨骼关节处(只要在建模时预指定一张完整的skinned mesh信息就行了，关节处的网格在建模时要刻意弄得特别密，skinned 过了的人体层次模型就会“整个地”被其内部骨骼上的动画带动，加了权重的动画，就更好更平滑了)。 Skinned mesh和加权重，就是一种预处理过程，它们将骨骼对于网格，或整张skin的影响因子进行了“预计算”，这样，在回放程序中，可以迅速完成动画的显示与生成处理。 (为什么说skinned mesh是“即时生成”的呢？这是因为，虽然建模时skinning的过程是可视的，但稍后在动画时，混合，权重之类的概念就像贴图过滤机制一样，它们也经过了“数学上的计算”)

**可变形效果物体(粒集体,流体,柔体) **

变形体动画分两种，一种是纯几何的，基于隐含曲面（用它来控制多面体动画，可内含于多面体或构造一个包含多面体的曲面）的方法，另一种是基于物理的，基于质量—弹簧系统建模的多面体。
基于物理或曲面系统的可变形体可用于表达skin mesh，当它被用作一个多面体的“变形包围盒”时。

为什么需要粒子系统呢?它提代一种可以用来建模和表现其真实感的集体粒状3d体(往往是特效,特别效果),而往往这种东西（水，火焰，喷泉等自然现象和自然事物）不能用传统的建模（而往往是程序上的过程能表现的东西）再贴图表现其真实感的方式来完成,故,需要粒子系统.

这些东西可以在CPU上用DX完成，但也往往更容易直接在GPU级完成,我们把它留到GPU编程时再说吧

**分形物体 **

分形能精确地描述自然现象,只要加以一定规则下的随机,那么它就几乎就是世界现象的代言人(在分形几何的眼中,世界就是可以用规则来控制的随机,用确定的理论却能解释的随机神秘现象).这种能力令人们瞠目结舌.

Natural surfaces are highly irregular. For this reason, many natural objects cannot be represented by means of polygons or smooth curves(实际上也最终要tellsation成多边形). However, it is possible to represent some types of natural objects by means of a mathematical entity called a fractal. The word fractal was derived from fractional dimensions.

层次模型，空间划分与sorting
-------------

**空间的划分,虚拟空间与管理(程序上的)**

层次的场景结构表示它使用于递归处理，这句话同时指出了数据结构和算法方面，所以场景图和场景结构是一种CG中的实现抽象。

不要把LOD中的quadtree技术跟场景管理混淆,前者是算法问题(如何做什么事 – 这里是降低大规模网格带来的效益问题),后者是程序问题(如何把事情做得更好 – 这里是管理一个逻辑空间[9. 为什么说是如何把事情做得更好呢?因为scene manage不是每个图形程序都必要的]).

质量，力场,光，颜色
-------------

xx

modeling(2) - 4D中的数据准备1(时间,轨迹,与动力模拟)[10. 动力学研究的是物体的运动和受力之间的关系，运动学研究的是位移关系，速度关系和加速度关系，一般地数学模块跟运动学相关，物理模块跟动力学相关]
=============

3dx = 3d extended,整个一到三章,完成的,是最基础的表示和真实感,这就已经完成了一个3d render’s core（的modeling部分）,真正的3d程序,其实还有一些东西是必不可少的,比如交互处理,这就是这一章要开始讨论的内容(然而,它们以core 3d为基础)

在计算机图形学领域中,除了光的部分跟物理有关以外,关于力的部分,是另一大块也跟物理有关的部分,这主要集中在计算机图形学关于如何碰撞(我们在前面解决过边界相关检测的问题,当然,相交并不代表会有力和碰撞的产生)的算法上,而这一切(关于图形学引入的物理),都是为了使计算图形学解决的问题,显得更VR一点.以前我们是不满足于一个线框的世界,所以我们准备了打光,现在我们是不满足于一个静态,没有力的世界,所以我们提出了力.在计算图形学上依然是借助于物理学来解决的.

计算机动画有效果动画,模型动画,动力动画这样的说法,甚至还有颜色动画.

什么是静态的世界?如果一个帧可以在25ms之内完成它的渲染,那么fps至少可以达到40.当大量持续的静态帧不断由后备缓冲推到前台,我们看到了不断刷新的结果(人眼分不出这种变化,双缓冲能构成“动画”,这是利用人眼的视觉暂留,这就是说它的确是动的,然而这种动作的内容本来是静的[11. 比如，在动画没有改变的情况下，前后缓冲是同一个画面]再加上刷新过快,所以我们看不到).当一个帧在2500ms之内才能完成它的渲染,那么至少我们要每隔2秒以上,才能看到下一帧,而画面注定要不断刷新(因为前后缓冲必定在交换).所以我们看到了明显的延迟,人眼看到了动画,虽然这种动作的内容是静的.

而如果画面内容在前后缓冲刷新之间经过了变化,即使画面过频地刷新,我们依然能分辨出画面内容在动.4D就是解决驱动画面内容进行变化的计算机图形学中的问题的全称.相较前面为3D准备模型和打光贴图[12. 当然,你要说动态阴影是4D的话,那么其实它还需要加入一定的控制.比如摄像机变动,或物体变动.]的二个过程(如果不改变其中的画面内容,顶点不进行变换,那么这种动画依然是“静的”),4D是一些“物体运行动画”,“碰撞反应”这些更显得“VR”的东西.因为它加入了交互和“物体运动”(显然,动态场景的一个标志就是其中的模型会因为自身的移动,或摄像机的移动,而显得“动”).有了时间的因素.所以是time space逻辑(当然,我们处理的还是顶点 – 只是这种顶点不光代表位置，还可以代表其它信息而已,还是3d – 3个分量的量,我们称之为4d,是因为听起来好听)

一般动画(矩阵调色板动画),一般特效动画(billboard,etc..)
-------------

三种动画:

刚体动画，规定一个外形（这个外形并非几何上要绘制的外形，而是物理上的外形，作碰撞的边界用），这种基于物理的动画，是物理逻辑加调色板矩阵作用下的动画。 变形动画。建立弹簧表达物理内形，这是直接调色板矩阵完成

(由于建模如上二种动画，在最终要变成调色板变换逻辑，在回放这些动画时会产生固定的姿态效果，因此称这二种动画为playback动画，与基于物理的动画（它们会在每次回放时产生不一样的姿态）相区别。

柔体动画：可变形，间接调色板矩阵技术。是顶点技术而不是物理技术。 纯粹蒙皮动画：用矩阵插值决定变形。数值技术。
**2d动画 **

2d中的颜色变换所形成的视觉动画-调色板交换逻辑形成的动画

**摄像机动画 **

我们这里不讲摄像机动画,留到下一节讲3d rendering中再讲.

**变换动画 **这种动画是物体不受力,通过程序控制其在坐标空间里进行变换,当摄像机不动时,物体和摄像机之间产生相对运行,所以会产生动画,这种不受力的情况(plus摄像机动画)不妨称为效果动画(比如粒子效果)或程序动画.我们要讲的,是受力后形成的动画.

**一般动力动画:一维方向上的动力动画 **这种动画不是由摄像机移动而导致的,而是由物体自己移动导致的.得借助物理手段 **用曲线来表达物体的运行路径 **于是我们可以在3d空间里,表达一些曲线了.这些曲线可以作为顶点变动所代表经过的路径.于是这个顶点和它的相对顶点集构成的模型,就可以在空间里做曲线运动了.

为了控制物体的运行速度,我们也可以对速度进行插值.这就是说,曲线本身就是一些用样条点进行插值形成的数学表示,我们也可以对物体以如何速度运行(而不仅仅是对它要经过的路径)进行插值.在时间上的某些样条点,在数学上以对应次数的函数去驱动它. **层次模型的动力动画 :骨骼动画 **CG动画跟AI中的机器人运动学密切相关 骨骼是个伪概念，它不过是关节之间概念上的虚线，骨骼动画真正的称法叫关节动画 计算机图形学中的动画技术,泛指一种在图形管道中被渲染的3d元素发生变化的总称,这个所谓的元素所谓的变化,可以是单个3d物体的简单地用数值手段指定其位置,大小,比例,颜色,运动朝向,路径点,时间等性质的变化(也可以是其它某种高级手段 - 比如数学手段,用其来控制物体某性质形成一种高级变化的过程),也可以是复杂物体基于某种或多种宏观控制逻辑(这就是上面提到的高级变化,比如,层次模型加基于物理上动力[13. 比如粒子系统的重力,等,注,一般用粒子系统在游戏中产生特效,即,particle system based effert]的方法)的组合动画.

所有这些动画技术,可以仅仅最终表现为渲染时3D物体从一帧[14. 帧本质上是用时间信息联系的某段其它信息,通过查询该时间就可以得到这段时间里(多个这样的时间段组成的序列之一)的这段信息,比如骨骼的当前矩阵.]到下一帧的变换,也可以是基于设置了关键帧(这里的关键帧其实更适合被说成关键节点)的变换.(我们说,正是这些有意而为之的先行控制行为 – 换言之，经过了预计算,在最终渲染中的帧与帧之间就形成了动画效果)

其中以关键帧技术的动画最为普遍,关键帧不是指渲染中具体帧间的变换(虽然动画是在渲染中是在管线的帧中被形成的),而是上对抽象上的“节点间”(这个节点可以是如上提到的简单或复杂物体的单个性质或组合性质)进行的一次有意的使其渐变的过程.宏观意义上的动画,即是这种节点间的发生的变化(虽然微观意义上的动画是在渲染中是在管线的帧中被形成的).

如果物体被设置了动画，那么动画系统将提供一个随时间变化的变换矩阵，这个变换矩阵逐帧把物体变换到世界坐标系中

根据编辑器的眼光，动画只是在时间线上的三种变换逻辑，只是本质上的一些变换数据。 （在各种动画持久文件中的表现形式不一样）

渐变往往是从一个节点到另一个节点,这就是基于track[15. Track其实是一个形象词，它表示，“路径驱动器”，一个动画总是由一些“tracks”组成，这些tracks会不时地驱动对象，使对象产生动画。计算机图形学中的动画，基本都是“基于track”的动画](路径)的关键帧动画,这样的动画可以是简单关键帧动画,骨骼关键帧动画,顶点关键点动画,节点间的内部节点是计算出来的,关键帧动画是“生成的”,所以它不是数值指定的简单的动画,所以得涉及到数学,一般地,在解决问题的方法上,业界通常用数学上的插值(hermit或catmull,前者需要提供样曲条,注意这里我不把简单称为样条,的切线信息,后者仅需提供顶点信息 - 注意这里的顶点信息不必一定指3d物体的顶点,其实更应说成为曲线的顶点.因为表示插值的函数在数学上往往是一条参数化的曲线,所以插值,也通常称为曲线插值.),或逼近技术(Bzier或B-spline)来解决关键帧动画中的内部帧生成问题.

>sequenece是animation clips，而帧本身，其实并不是时间信息，而是那个时间的矩阵和位置信息。)

插值或逼近涉及到提供一个函数,问题中出现的样条点,控制器(数学上,得额外借助“某些辅助点的组合形成的某种控制器”才能形成通过给定节点的某条插值曲线或逼近曲线)等等.
一般的动画,都是简单的用变换驱动物体的位置,大小,比例,这样在它在渲染的每一帧,就会形成动画.用关键帧驱动的动画,跟用控制器约束器驱动(比如上面提到的数值手段)的动画技术相比,后者要更灵活一些.复杂一点的动画涉及到物体间的相互制约,比如,层次建模的物体,和基于物理原理的制约(比如,IK[16. 骨骼动画并不一定是IK的,也不一定是基于关键帧的,另外要注意的,就是关节,你可以关节编程为弹簧(利用物理手段),这样的骨骼就是具有物理属性的骨骼,跟普通的层次骨骼中用普通line和privot point表达的骨骼不一样,也可再加入关键时间上的骨骼,通过插值作过渡,这样的骨骼叫做关键帧骨骼.]-利用了IK的层次模型的骨骼动画跟普通状态下没有指定IK关系的骨骼动画相比,后者子节点的变化会影响到父节点)

骨骼动画与基于物理的ragdoll动画(布娃娃rogdoll是一种物理系统。用以动画时。能营造更为真实可靠的效果)，前者，关节是一种constraint，而后者，就更是一种显式的，更高层次的constraints了

>六个自由度的二足动物动画

在骨骼动画中,骨骼不是网格,而是矩阵数据,它联系起了这段骨骼和受它影响(往往在建模时指定,这称为蒙皮)的网格数据的一个关系(往往除了矩阵,还可以指定一个权重),利用这个关系,可以在每一帧(关键帧里保存了一个骨骼的快照,骨骼动画的术语叫,矩阵的插值,关键帧间定义的矩阵快照间进行的插值)算出层次模型内每个网格的顶点数据.

故在每一帧可以完成变换.

>反向动力学 IK或FK是一种约束器(一种算法和程序上的抽象)。 必须用时间去控控制物理模型,用路径去控制动画的走向,纯几何的模型并不能动,必然有一种“能使它运动的可能性”在建模时被确定(几何上的表示),然后在以后某个时间上,又有一种控制作能于这个表示.于是模型产生动画(反向动力或时间)

前面我们建模了骨骼.那仅仅是能让模型有一根骨头,“使之具备动的可能性”,那么这里,就是真实让它动起来的时候了.因为我们从物理上赋于它“反向动力驱动它”,从数学上赋于它“插值时间控制它”. FK和IK即是这些“统一驱动一个层次骨骼模型”的方式。

xxx

>ani mesh和skin mesh是分开的，ani mesh只指一种“随时间会发生变化的网格模型场景”,skin mesh才是指“matrix paltting mesh”,ani mesh 真正的全称应该是ani mesh model scene

xxxxxx

>骨骼和关节，往往指多个骨骼和关节组成的系统，默认情况下提到骨骼和关节，应假设它们是存在父子关系的多个骨骼和关节组合而成的树形系统（不可能变换一个单一的骨骼因为没有意义） 骨骼和关节是矩阵变换在程序上的抽象，关节是抽象化了的点，骨骼是线（为了连接关节点provit point而存在），骨骼系统就是程序上抽象出的“点和线组成的系统，关于它的变换逻辑”。之所以需要骨骼和关节抽象，是因为它能形成矩阵变换，而矩阵变换能很好地被用于形成动画，这较之直接的，传统方式的“变换顶点”有很多优势。（抽象即提出一个中间层面） 形象化的，可视化的骨骼是一条线，形象化的关节是一个点，可视化的骨骼定义，（比如在3dmax中）就是建模时指定的初始的bind pose（那时的关节所代表的点，和连接这些点形成的骨骼段，它们在世界中的位置和初始变换矩阵）,骨骼同时具有位置和矩阵信息。 （在程序表达上，骨骼往往是一个具有父子关系，位置字段/成员的结构或类，动画往往就是骨骼的矩阵信息的结构或类） bone可以独立于mesh被提出，产生动画，进行有关矩阵变换的求值，然后才被运用于不同网格,这说是说,关于骨骼形成动画的事情在先，它本质是矩阵插值，关于插值矩阵了的骨骼影响附在其中的网格数据可以是后来的事，它本质是坐标空间的转换。前者没有mesh,后者才是skinned mesh. 我们着重提出这个，是为了强调附在其上的网格往往可以是一个单一的几何体，但其内部一定是逻辑上存在层次关系的多个部分，这样才能对应多个骨头上(或关节上)，层次模型加层次骨骼形成的动画才叫骨骼网格动画(animated mesh)。
**（几何体动画和网格动画才是真正的动画全称，也即，动画以这二个东西为单位，而不是整个模型，模型动画是几何体动画和网格动画的别称） **
由于是动画，因此涉及到时间(根据时间对骨骼状态插值即形成骨骼动画 – 注意此时不是网格顶点动画)，帧即是经时间流逝后形成的数学意义上插值节点（帧是计算出来的，刻意保存的帧是关键帧），关键帧不是时间(一段动画可以在一年之内播放完也可以选择在一秒内播放，时间只是用户用来控制动画的外来参数而已)，而是帧对应的瞬时骨骼的状态，关键帧的定义，不是定义时间，而是定义瞬时骨骼状态。它本质上是一系列矩阵（状态），故骨骼状态本质上是矩阵动画matrix animation即是骨骼动画 bone animation，也就是一系列随时间变换的骨骼（状态），矩阵变换是父子骨骼相对的变换。关键帧内存储的也是当时父子骨骼相对的变换的一个快照，故它是多个矩阵值的组合。

**特效动画 **Xxx

**特效是一种特别的动画。** 一般地，FX（特效的缩写形式）包括基于公告板的特效，基于粒子的特效，还包括基于物理，基于图形变换，变形的特效，在游戏中，魔法，天空，自然景观，等等，都是特效。

粒子系统本身，就是一种最典型的物理动画。

交互式3D : 质量表示，碰撞检测,碰撞反应(刚体动画，流体粘着沉积动画，柔体变形动画)
-------------

碰撞是几何的，还是物理的？可以独立空间划分谈碰撞吗？ CD是算法上的事,至于如何反应,可以是程序上的事 遮挡跟碰撞不是一样的概念 就像特效有基于shader的特效和基于modeling的特效,和基于粒子系统的特效一样,碰撞检测可以有:基于距离的,基于几何相交的,基于对象与线条之间的,基于对象之间的相交检测.

**picking拾取 **

cd还用在基于物理的动画效果中？

cgal〔这个cg是计算几何而非计算图形〕还包括：interpolation&amp;curve,skin mesh,spatial search,texture mapping等。

skin mesh是计算几何的概念，ani mesh是线性代数的概念，这两者都可成为程序上的抽象。

坐标系仅是给了仿射空间一个中心原点，然后其它的点因而有了度量和获得了一个本地环境而已。

**模拟物体的动能 **CD一个最典型的用法就是避免碰撞后陷入，故它也属于是提高真实度一个最基础的方面

从这里开始，出现物理动画 Picking 相交. aabb

advance and apps

Fog,地形,高度图,粒子,特效,场景,角色

Fix-Line Rending与Hybrid Rendering(1) - Rending前投数据(Highlevel Rendering)
=============

利用GPU进行的图形编程，就是让用户同时管理modeling,shading,rendering,而基于fix-function管道的图形编程，程序员仅需负责feeding

fixed-function cg programming=feeding,shading programming=modeling,shading〔texturing,lighting〕,rendering,all in a diy favor.

有没有注意到呢,一直到这里为止,我们讲到的东西,都是几何的数学,而没有讲到任何图形上的数学或几何(!!!!你可能会大吃一惊,但是请记住,**建模和着色有一部分属于用户动作,渲染却大部分属于不受用户管理的runtime或hardware来操作**,计算机图形学以数学上的几何知识为理论基础,而且是一大堆理论基础,前面讲到的向量空间,曲面插值,计算几何,其实都是数学知识,或称几何),没有计算机图形上的(比如颜显系统[17. 实际上,颜色也是用几何表达(只要是vector processing unit能处理的,都可同时看成是数学上的)的.只是因为它是颜色,而不是(一个顶点的)坐标,所以,它与图形硬件有点关系了,是“图形学中的数学”,而不是“纯粹几何上的数学”而表示一个顶点的坐标,可以不要任何的与图形硬件和图形学有关的东西.所以可以称为独立于图形学的纯数学几何知识(这也是本书第一章分为pre rending用户准备数据是独立于显示逻辑的道理,然后才讲到显示流水线).对于本书讲到的物理知识,也是如此.也分为独立于图形逻辑和显示流水线的那部分.],图形管道)数学,那么从这里开始,就有图形数学,比如空间间的变换.

取景变换到屏幕
-------------

虚拟像机模拟机制可以解释所有的变换概念 在数学上，这些都只是矩阵变换的分情形应用而已。
>世界坐标系xyz也可以用笔记本电脑屏幕与主机之间的三条线来加予说明（电脑左边即是左手系。右面即是右手系）
在摄像成像时,,,模型本身的移动,缩放,翻转等变换属于模型变换 ,,这相当于调整物体位置,,,其它的不动只有物体动

如果调整像机(注意不是调焦,即不是镜头在变)的位置,,,就是视点变换,,此时镜头,物体都不变,,,只有像机本身的位置在变

调整镜头位置,,,才是投影变换,,,此时物体和像机不变,,只有镜头在变

把3D的弄成2D的就是视口变换,,,视品就是计算机屏幕

摄像机控制

右下角有Field of View,Pan,Arc Rotate等
**透视学与射影几何 **xx

**一般的流水线 **一般的流水线有四个变换.

**摄像机与漫游 **

Tranform是render的二大重要任务之一.这里集中讲解变换.渲染中的其它逻辑,比如打光.等等

流水线

视角变换,摄像机(d3d并没有摄像机这样的概念,是用户扩展视角变换的) Clip plane

>这些,都不是d3d直接支持的,而是程序扩展的.它们对于一个3d程序来说,是蛮重要的.D3d只提供核心,并不提供如下这样的东西,d3d扩展中才有可能出现.

**不可见面消除 **不可见面剔除是一个大系,可以分层次进行,在顶点级是深度缓冲,在三角形级和渲染后期是背面剔除，在更高层的程序级，比如scene manager级是场景裁剪比如quad tree.

快速剔除并不表明快速正确的碰撞发生，而是确定了不会碰撞的情况发生

Appending Reality(Fix-Line Shading&amp;Hybird Shading)预生成为像素的图形[18. 与前面建模时所提到的预生成顶点相比,这二者都是针对最终进入GPU中的元素来讲的,打光其实也跟顶点信息有关,有一部分也是关乎建模的,所以这二个过程不是截然清楚分开的,这二者进入GPU的时机不是一前一后的,而是Hybird的.]
-------------


**贴图拉伸现象 **xx

**深度处理 **有裁剪空间这个说法?其中的z值,就是Z缓冲中的东西
**shading **其实，applying reality有时也是跟modeling,rendering同级的图形学全局过程，但也可以放在rendering内，作为子过程。
颜色信息对于最终的显示有多重要,rendering后端对于渲染的重要性就有多重要.所以,贴图与打光,这些关乎着计算最终颜色的过程,其重要性是不言而喻的. 增加真实感,还可以是除了贴图,打光以外的其它过程体系(比如fog化，阴影，但是这二者是基于打光和贴图的高级过程，不可混淆),但在3D界,只承认这二种标准过程.
Modeling过后,为了增加真实感,一般有:texturing,materialing,lighting. 为物体和空间塑造真实感，有时是必要的，有些是选要的 打光和贴图,称为drawing,打光和贴图对3d的重要性不言而喻,这就像素描,划线之后,打光同样重要,而贴图,打光(特别是打光) – 贴图和打光,是受图形加速硬件或GPU直接支持的东西,是展现一个3D世界的可视性和真实感的最基础的部分(除非你满足于面对一个线框的世界).

>如果把计算机图形学和渲染过程分为“Modeling”和“给模型(可能是预先offline建造的,或在渲染过程中过程化生成的)信息增加真实性”的话,那么“打光”就属于一个很尴尬的地步,因为不知道它是属于建模还是真实性,但其实,灯光效果,可以用建模的思想(追踪光线模型)完成,也可用增加真实性(比如基于图像的阴影)的方法完成,这取决于采用的不同技术需要达到什么样的效果.

但是前二者是从模型本身着手的,后者是从环境着手的.这三者可以进行混合而已. 光强,颜色,位置,不可否认,正是我们所谓的3d的三大主体元素.如果硬要说的话,还要加上一个时间.

>D3D中的灯光

打光是必要的,因为颜色信息(这种颜色信息,是几何体原始色彩,是表示颜色的光强信息)必须借助它表现出来 any stage of the vertex pipeline (transformed, untransformed, lit, unlit).打光作为表现真实性的手段,是直接受硬件支持的[19. 只是dx会在“Render lib级”定义特定的灯光类型，比如，只有定义好相关顶点格式，确保这些格式被DX支持(顶点格式中会有相关的灯光分量)，这些顶点形成的模型才能接受“DX的灯光”（注意这个说法）的照射。](作为管道,硬件逻辑的一个部分,一谈到打光就要跟贴图,建模这样的概念并列),对于任何一个使用了灯光信息的顶点(法线,颜色),都会在顶点管道级被处理作为灯光逻辑.所以,它是必要的. 作为表现真实性的手段之二,材质上的颜色也可以被用于网格模型.或与灯光颜色进行混合产生更炫的效果. D3D中的光线到底是什么东西?,注意D3D中说到的光线(light models光照模型),跟“灯光”,或者一些别的引擎(特别是非实时光线模型引擎)用的“灯光”字眼的意义可能不同,因为D3D是一个伪实时引擎.它的光照模型道理上是实时的.以一种其实并不真实的光线效果实现的.那么它是什么呢? 当你在D3D中定义了一个灯光,其实,你只是在一个虚拟场景中(这个场景只是概念上的,因为它指示了你要对其打光的模型 – 这个模型也是概念上的说法 – 进行光照所用的场景灯).

**从(线性)代数来解释贴图空间,贴图 **
**贴图空间,贴图 **作为点采样本质的纹理映射,因为是采样,所以必定会产生走样

纹理是3d技术,它着重指纹理映射,而不是2d的一张图,那是2D技术.

纹理是一个很泛的概念，它泛指用整个cg rendering中的applying reality part,而表现出来的介质，即纹理。

Lighting打光, 纹理映射与光照极其相似,都是渲染多边形的逻辑.我们把它放这里讲解,是因为它的地位没有纹理映射重要(毕竟,不是每个3D程序,都要打光) 先讲打光,还是先讲texture?二者也可综合讲,lighting texture map,所以,texture不只是bitmap rgb数据.
**材质 **不用过程纹理的贴图怎么表达物体表面的凹凸感呢?

**映射 **纹理映射依然是第一章讲到的计算几何中空间变换的运用. 立体贴图与映射

Appending Reality(Fix-Line Shading&amp;Hybird Shading)打光
-------------

**用物理来解释灯光 **

**打光 **

灯光其本质,也是一些关于颜色的亮度数据,是对整个环境的后期的渲染处理[20. 在d3d中，灯光是本地光照的，是作为顾本自守的单一模型存在的，它对于其它物体被渲染时的影响],还是对一张贴图的.灯光是一个模型,同时是一种渲染技术.法线,只是数学抽象的东西(模型本身在引擎的动态计算下产生法线数据,或在模型的持久表示中直接指明法线 – 时间换空间策略).它指明在哪个方向接受灯照. 光,就是白颜色吗的强度吗?在表达物体的真实感时,是光放前面,还是贴图放前面?法线决定了一个面接受光线时,光线的来向,它是与面垂直,过光线与面交点的那条线,法线插值的现实解析,本质是什么?让光均匀地射在表面.
前面我们在讲曲面生成时用到了插值,那么这里,颜色计算,也要用到插值,就是后来,比如动画,也要用到插值

打光不仅是使物体看起来更有真实感的手段(在这个意义上它是选要的),更并且,它是使物体看起来“仅仅显得正确”的必要手段(在这个意义上它是必要的).换言之,一些物体,必须被光照处理,才能被正确渲染.

光和物理表面的交互,与反光,是一种物理现象.纹理是表达物体表面粗造程度的,也是一种物理.(可是,颜色本身也是一种物理现象啊,不是说黑色的东西更容易吸光吗?)

Shading语言历史上,是从renderman shading语言中借鉴而来的(不要把它跟shading models中的shading混淆)
**xxxx **

**虚拟全局灯光空间,照明与阴影 **

>打光和照明都是必要的.关于灯光的真实感的营造,第一步是给物体本身打光,然后是环境造光.这二个层次都是必要的.

本地局部打光模型是从shading层次出发,尊守跟贴图一样的过程.它基于物体表面.模拟灯光效果,以物体为发光体为基础制造打光的一个过程. 而全局环境模型,是从灯光本身出发,考虑灯光间的逻辑关系和物理情况,而制造的一个打光过程,物体表面仅仅是受光,然后形成被打光的效果. 故这二者出发点不一样.

**辐射度 **

基于辐射度的场景全局照明方案.是采用物理能量的模型来解决图形学问题的一种手段.

Shading models也称为lighting models,然而是局部光照,而且仅限于反射,最科学,最能增强可视性和真实感的,是全局照明,这就需要发展光线追踪技术和基于物理能量的辐射度技术系统,而这些,往往跟传统的解决方法产生矛盾(比如面消隐技术 – 你也可以叫它可见面侦测,或不可见面剔除) 阴影使场景受黑的原理是什么呢?阴影锥? Fog现象
Pre Drawing : 消隐与LOD(20p)
-------------

xx

Drawing,Post Fullscreen image Effect
-------------

绘制直线有直线扫描线算法，绘制曲面，，，有曲面扫描线算法，这就是绘制的任务，而不是数学表示的任务，所以，CG可以表现真正的曲面，当然，也可用直线模拟逼近。

**直线扫描绘制 **

Xxxx

**clipping **xx

**光栅化 **

Xxxx

Fix-Line Rending与Hybrid Rendering(2) - 渲染中动态投数据(lowlevel Rendering w/o DX Runtime)
=============

>(*)在顶点和像素级非常规性地综合解决建模与贴图问题

Pure software与accelerate cards的rendering我们说它们是传统渲染管线,因为它假设建模和真实感表现在先,然后才是投放到流水线中去render(注意,对表面的shading[21. 比如用shading方法做成的水波效果,它属于基于shader(表面处理)的特效,而非基于粒子系统的特效,除此之外,还有基于建模的特效.]并不算是rendering),这里面有一种例外情况,就是过程纹理或模型法. 而gpu中的渲染,往往跟建模和真实感表现混合在一起,这就是说,它其中的任何动作,都是全程化统一的的.所以,其中的任何动作,必是过程法的.

这里,我们只讲real time rendering的一部分,即关于建模与贴图的部分.故本节只是一个小节,而不打算作为一章.

注意,计算机图形硬件是一个大概念,不光是GPU,还有其它部分.GPU只是用来称呼显卡的一种方式,代表它的是vetex processing和pixel processing,但其实,这二个阶段并非计算机用来处理图形的全部.

Hardware graphics pipelines perform some programmable shading in object space (at vertices) and some programmable shading in screen space (in effect, at pixels). 仅仅是根据shading而做的二个区分?(实际上还存在光栅器和CRT这样的前端与后端)

GPU hardware与Real Time rending原理
-------------

Xx
