
web game = web + game? or web hosting game??
------------------------

webgame 一般无处乎以下几种: 

1,服务端运行在纯意义上的webserver 中,客户端利用js,xml,ajax；这种webgame 是纯粹 

意义上的webgame ； 

2,在1 的基础上，客户端加入了富网页效果，如flex,sliverlight 等，或内嵌一个3d plugin, 

如unity,但它只是让3d 运行在ie 中，作为一个流式的3d content player  而存在。 

3,在1 或2 的客户端基础上，服务端还是传统的tcp 通讯方式,有的引擎还会加入raknet 

这样的网络引擎； 

4,在1 或2 的客户端基础上，服务端加入了改良的web 协议，如保留状态的comet 技术。 

5,1-4 的杂合品。 



归纳一下：有的从服务端改造(comet...)有的从客户端改造(ria...)，也有标准化的改造之道， 

这就是html5，它同时从服务端和客户端进行改造(websockets,canves 等等)。 



    >>既然web 生定不能很好地为game 服务(主要是其协议部分)，那么不如改造客端或 

 服务端，在客户端，我们可将3d plugin for browser 部分改造成一个3d internet content 

 player。故我们要改造浏览器，让它跟传统桌面应用一样能容纳长链接的其它协议，这 

 是客户端的事情。 

    >>在服务端，如果能使网页游戏能保持状态，做成长链接就好了，web,使之变成另外 

 一种web，再在这个web 上建立game. 或不改造浏览器，为它增加另外一种协议，如 

 长链接协议。 


实际上可以看出，除了1 之外，其余的webgame 其实都是“在线端。小端或无端”网络 

游戏而已，在加一个clickonce(要做到类web 即点即玩这个是很重要的因素).而这。就是 

所谓的webgame 了，换言之，它们基本上只是瘦客户端的c/s 应用而已。。 

深刻分析下webgame ，可以看出： 

1.web 与game 是矛盾的。web 的架构与game 的结构在基础上是矛盾的，（要解决的问题 

不光是在网络方面，比如web 协议的不可长链接性） 

3.其实。富网页界面。这样的东西不是webgame 的重点。webgame 的重点是解决服务端 

的技术。 

综上，如果要追求一种纯意义的webgame(运行于websever。显示在browser 中。使用http 

或soap 交互)。那么这样的webgame 实际上反而很不常见。 

但也不是全无方法： 

比如，对应于在.net 中的web 是一种特定执行环境的综合iis。其可以总结为restful( 比如 

语义文档。语义sql。固式化的协议http∶request.respond)。还比如spring.net 是一种web 

框架，那么，如果webgame 的重点是使game 运行在web 模式下。那么这个模式不妨就 

是类web 的另外一种web。比如一个类spring.net 的game.net 框架。 


针对协议改造
--------------------------

前面一本书说了js  的ria 确属webos 的一种技术。是作为webos 的架构一部分的，如果 

将3d 也做到webos 中，那么就有网页游戏。在前一本书中我们讲到web 的原型是restful， 

其对协议，url,文本语义都进行了改造和整合。又说到用http 做game 是有天生缺陷的。 

我们可以把web 的协议改造一下，使之增加长链接成份，然后做到asp.net 中去。 

这就开始涉及到协议工程，文本的工程就是xml，那么网络协议能不能被这样的方式定 

制呢？使用xml 配置的方式来进行定制，就像web 对数据库和xml，将它们统一到一套 

URL 中一样呢？ 


Web game也可以是类asp.net的整合工程 
---------------------------------------------

msdn 提到的所有东西包括mvc 只是基础api 级别的。xna 也明显太低阶了。只管在游戏 

一词中玩它的整合。没有想到为游戏开发提供跟web 一样的一条龙的整合之道 


xna与webgame
-----------------------

关于c# vs c++在执行效率方面的差异实在不用多说。就像我们要承认c#在这方面的确要 

差一点一样。我们也要承认c++在开发难度和开发效率方面之于c#要差很多。 

ps:虽然很多高手通常能做到在c#下开发使得执行效率保持与c++相当。但。以通常的人 

的能力来说。这并不实际。 

首先是应用程序模型的支持。要知道。基于托管的代码都被分配了一个“应用程序模型”。 

这在远程执行的分布型代码环境中很重要。比如asp.net 模型。web 程序被配置成一种安 

全的可分发的程序。game 作为一种特别的程序（具有硬件直接访问能力）。.net 为其分 

配的模型就是xna 模型。而mdx 不是.net 版本的dx,.net 并没有为mdx 设置一套专门的执 

行环境。这样的例子还有很多。比如net 的windows 和wpf 是.net 的gui. 决不是win32 gui 

的.net 版本。这种模型可以保证game,gui 程序等可安全无破坏地运行，而这，对webgam e 

是必须的。（xna  框架的第一层就是应用模型层） 

xna  秉承了与asp.net.ado.net.wpf 这些。net 上的“大部头”的一惯作风。它们高度被整 

合化又高度被简化。这些微软的一惯手段既保证了应用。又降低了开发的难度。对于新 

手。还有什么比winForm.webform 更为直观的呢 

xna  整合了那些呢？首先，1，xna 整合了图形引擎（做游戏开发到底需不需要一个自定
义的引擎呢？答：如果需要刻意追求客端的效果展示，而忽略游戏软件整体的构架合理 

性，那么这个答案是肯定的，然而，由于基于DX 的游戏软件在DX10 之后，已经完全 

放弃了固定管道渲染，所以，大量的客户端效果基本是靠shading 来完成的，这就导致 

了在游戏开发中，实际上图形引擎的地位被放低，另一方面，追求开发效率和一套合理 

的构架变得尤为重要，这就是xna  给开发者带来的东西）2，xna 整合了C++plusDX 开 

发中需要涉及到的IO,GUI,PKG 等东西(在.netfx 中和xna 的内容管理系统中)，更多的东 

西实际上变得不再重要。这解放了人们将注意力放置到游戏内容，剧情，ai 等非客户端 

部分，故，对大多数需要快速开发游戏的个人或公司来说，xna 的构架是一套很合理的 

整合方案。３，xna 提供了设计支持工具，这是对游戏工程化的一种重要体现，这也促 

使人们能更好更快地开发他们的游戏而不必仅仅将大量精力放到客端效果上。 

xna “明显”的缺点之一是xna 没有好的物理引擎支持，虽然xna  还没有物理引擎支持， 

但我们应看到它广阔的前途。因为这并不是不可解决的。 

所以说。对于游戏开发。还有什么平台。框架或语言组合。会比.net 加xna 更为直观的 

呢？也难怪微软要专门为game 单独设置一套执行环境和虚拟机。这就是基于fx2.0 的xna 

>>about webgame实际上图形引擎的地位降低，但是本书为了教学(从软件上体现图形学的算法)，还是力求从软件上实现一些诸如水效果，而不使用shader scripts，当然，是使用了dx实时渲染接口的情况下，而不是纯软件算法


other webgame sechemda
-----------------------


1，o3d 是javascript 的，基于js 的rwc 客户端技术一直以来是web 的中心客户端技术,dojo 

是这方面的佼佼者； 

2，o3d 是开源的，并实现在google webos 中； 

3，o3d 支持硬件加速； 

4，o3d js api 可以与html 代码无缝整合； 

5，o3d 可以与客端的Broswer 和dojo 很好交流； 

6，o3d 提供了一个基本涵盖常用图形引擎的所有功能； 

7，在html5 canves 不能真正解决基于3d 的ria 的时候，o3d 是一个极好的替代； 

8，在html5 websocket 还未真正广泛实现的时候，因为要使用长链接，dojo websocket 

是一个极好的替代(我们不用comet 方案)； 

9，云计算下的客户端主要不是跟服务端一样的通用开发。而是领域相关的嵌入脚本编 

程，基于可视编辑器的设计和制作，所以我们使用基于js 的o3d； 

10 ，o3d  的图形封装层次刚刚够我们讲解图形开发，即o3d  能很好地与本书开发 

webgame 的宗旨衔接，这也促使我们使用js； 

PS：dxstudio,unity3d 等类似o3d 的工具和软件，只提供了一套web player 样的东西作
为回放而隐藏了其图形开发的主要部分，并不能体现图形引擎开发的技术，故我们不采 


