Natives

native算法和应用域分析之一：IO

要问IO是什么东西，，，硬件PC上有IO(BIOS处理IO请求并编址IO处理例程)，软件OS上也有IO(内核的IO处理模块处理IO请求，，IO可能来自CPU与内核间，内核与进程间，进程与进程间)，，软件是一个抽象堆栈，，在不同的层次上，，你都可以发现input,output,比如，在游戏引擎中，parsing和loading
scene formats就是一种IO。
这也就是说，IO首先来自于平台，下面细述之
在硬件上，冯氏机，就是内存加CPU组成的计算系统，IO系统是由除非CPU加内存组成的内部系统组成的那些PC外部系统。(IO由CPU代理由CPU负责，由IO硬件发中断)，，DMA的出现，使IO硬件与CPU直接通讯。
硬件上用IO位图处理IO请求的优先权，以达到实时效果。
>>这种系统就是冯氏系统的本质，即内存修改器和IO进出器。这也影响了PC下的编程，其并发问题和优先级处理过程是不可缺少的（因为要并发，所以要处理优先关系，因为进入计算中心同[来源：GameRes.com]时只有一个――-后面我们会谈到软件上的假并行），无论是用户程序对硬件功能的扩展（我们还没有谈到软件），还是平台内置的IO规程，还是它们相互之间交互，都存在这种过程。而且，无论以后在哪个层次，，都会遇到IO的并发和优先处理。

当PC强大起来的时候，它有了更强大的保护模式，可以对IO和进出CPU的计算实现保护和控制，，因此出现了软件系统，即OS。IO的种类变得尤为复杂化了。
1,,首先，程序的种类变了，有内核空间中的规程（它们是C的例程，当OS启动，常驻内存作服务性例程，，注意我们此时还没有谈到进程线程这样的概念），，用户空间的进程，，以前的硬件规程被整合作为内核空间中的规程。。。。这样，发IO的主体就多样化了，内核例程可以向内核例程发，用户空间的进程之间可以发，而且，内核和进程也发。

2.其次，OS进一步多出了很多新特权级，它扩展了CPU的特权级，比如，windows内核中的各种例程有16级之多，对应16种优先级，，于是，运行在这种OS托管上的所有程序的基本上可以分解到16种优先级的最小C程序(任何本地程序，都会在会编级转换成对应于函数和平台类型的东西)。。

3.而且，转发中断的任务成了由内核本身代理（由保护模式转换为底下的硬件逻辑比如IO位图），，原来由CPU加内存组成的计算系统，现在变成了内核本身。内核通过中断向进程提供服务。。。进程通过中断请求系统服务，这些请求，称为系统调用，它们运行状态可以是对应16级的某个优先权(native
API的原型)的某个权。
5,,从OS到硬件驱动的整个硬件接入架构中，，，硬件驱动体系往往被实现为IO堆栈。一级一级地转发IO。甚至网络协议（网络硬件是一级一级相互协作的IO过程）也被实现为IO。
可以说，highlevel natives的逻辑(桌面开发)大部分跟lowlevel
natives(系统实现与开发)的逻辑相同，而这些逻辑中，，，大部分是IO模型。
比如文件是IO，数据库是IO，内存沲是IO，网络是IO，驱动是IO，ETC。。
而在应用级。IO就更多了去了。

――――――-
IO的同步
OS下，中断变成了抽象中断，优先级变成了多级，，内存，变成了内核与用户空间，，任务，，变成了内核规程与用户进程。甚至线程（它们是进程的一种策略，本身并不代表任务）。
关于它们的同步，，也变得抽象起来。提出了内存映射，共享内存，锁，旗语等东西。

A thread-safe function can be called simultaneously from multiple threads（控制）, even when the invocations use shared data, because all references to the shared data are serialized.

当然，也存在不是线程安全的函数，但同样可以被并行调用。此时，它们被称为可重入的

native算法和应用域分析之二：内存沲

OS隐藏了物理内存，给用户空间的应用程序和应用程序开发者一个虚拟的4g视图，，一般地，我们用系统开发语言开发基于系统之上的应用。。语言的[来源：GameRes.com]后端(有一个内存分配器)或你使用的某个库（提供了内存分配方案）替你要OS讨要内存，，代为一个代理者，，当然，由于内存是用户空间的资源，语言标准库和后端也好，第三方库也好，，，其向OS讨要内存的权力，和要选择的方案都是平等的。。都可以在自己的开发层次定制。。
简单的内存并不需要分配成沲，，分配沲的内存分配方案，往往是追型动态和稳定的。

native算法和应用域分析之三：线程

先看前置知识《native算法和应用域分析之一：IO》
在os内核的眼中，处理IO请求的IO请求往往来自外部IO硬件驱动例程，往往是函数，是计算小件，它发生在发出IO请求的外部IO硬件驱动例程和处理IO请求的内核处理模块io
mgr之间，通过OS级的抽象中断系统(os内核中加了多级优先级的协调模块)沟通这二者，，这种IO形式除了被OS内核实现用来实现驱动请求之外，还被用来实现内核服务等普遍的请求(可以说OS内核把它们全视为IO请求和IO例程模式，其实，OS内核中基本上全是这种现象，这就能解释为什么windows把内核对象和概念全抽象为对象了，，因为OO也是一个对象系统，对象间也存在交互―可以想象它为中断)，，我们在前面谈到，冯氏硬件平台的本质是IO，和内存修改计算。看来在软件系统上，(虽然IO转移到了抽象硬件为软件驱动后，再将它发送给OS
的io mgr的层次)还是继承了这个特点。
在前面我们还谈到硬件利用IO位图对IO请求的协调机制，，这导致了硬件级对中断的并发处理，在OS内核中，对软件IO例程进出计算中心(os
io
mgr)的协调工作―――-软件上的io并发协调机制，也同样存在。第一段说的是作为小IO体的驱动请求，，，可是软件平台的丰富性，使它还出现了另外一种抽象IO体，，任务进程，它是在拥有了OS的计算系统中，提供给用户用的（由OS内核提供机制上的实现，，但并不直接在内核级就使用进程逻辑，否则就[来源：GameRes.com]是使用了OS的OS内核，即微内核，），它是另外一个OS要管的被计算主体，即IO体，，是大件，不可能让任务直接参与并发。对它的协调要考虑比诸如驱动请求更多的问题。
这样，就提出了线程，线程是一种函数，，它迎合了普通IO请求一般是函数小件的形式，，所以，线程的本质，，是进程作为IO体，参与os内核以进行在它里面发生的并发协调的机制。。

native算法和应用域分析之四：网络

网络是分布式计算平台，，所以，它以计算平台（可能是一台PC，或其它可以作为网络节点的智能单元）为基础，，网络作为IT技术，主要是指架设网络，调试网络的艺术（不是一种编程技术），，但是如果用PC作为这个计算节点（可以是作为路由器硬件节点等通讯子网的单位，也可以是作为逻辑节点即资源子网的单位，如soft
vm，一个p2p应用程序），那么，这里我们就涉及到了计算机网络编程技术。
计算机参与分布式系统，首先要谈谈这个分布式系统，再谈作为分布式系统主体单位的PC。
分布式系统的模型是OSI七层模型，满足这个模型的分布式系统实现都可以相互通讯，作为一种完备的网络协议，它指出了分布式系统的全部交互逻辑(协议即某种分布式主体交互使用的IO模型，，使用XX协议的网络被称为XXX网，可能是另外一个名字
―-
协议作为IO这种模型在编程上被看作是socket,这是后话)，，，而具体的分布式系统，如lan,wan这样的专用网往往只实现全功能分布式系统的某些部分，完成某些层次的交互就功成身退了（如以太网往往被用来实现局域网）。
>>lan,wan不但指出了网络的规模，它实际上也指出了该网络通常所拥有的协议（在OSI七层中的对应物。）
现今最通用的TCPIP协议（tcpip协议是一个实现了OSI某些层的协议组，TCPIP网即使用TCPIP协议进行通讯的分布式系统）是网际网协议，internet（大小写的i通常被用来区分互联网和网际网―网网互联）指网际网，即网间网，网络的网络，不要把它称为互联网，，它是泛义，学术用语，现今存在的网间网―-那个由apr形成的网间网，才称为互联网(Internet大写的I)，除了互联网它还有一个名字，即公网。可是，它没有特指的代号。这纯粹是历史问题。
Global
Internet是由不同协议的网络(它们往往是某种lan,wan)进行桥接形成的internets，这些internets大部分是wan规模的tcpip网。在这个层次上，需要使用路由方面的协议（如Internet
tcpip的IP，，注意TCP仅是应用层的，它往往与程序员有关），在具体internets内部，可能仅是一些靠近OSI下层的协议。[来源：GameRes.com]
――――――――――――――――――――C
以上这些，被作为硬件时，往往对应一部分OSI协议（被作为路由器，集线器，交换机等的东西），PC作为通用硬件（通用分布式系统参与体），，它在内核往往包括了OSI的全部实现（这样，它可以被配置成所有网络硬件），，作为软件时，往往是应用层的OSI重实现（如一个P2P中的消息系统）。关键是分清，需不需要再度路由
在编程上，网络是跨CPU的程序，网络编程的模型socket是一种IO。

P2P是一种抽象分布式系统

我常想，为什么会有P2P，它处在开发的什么位置？internet难道本身不是p2p的吗？可以不要P2P吗？
互联网立意之初，被设计成一个可处处路由，当坏了拓朴上的一条路径后，它依然能到达目的地的可靠网络。它的唯一目的，，其实不是应用(应用层协议，是它做到最后才考虑的)，，而是形成一个可通达的网络（先完成通迅子网再完成资源子网）。这导致现行的网络和网络开发，是以协议(节点交互)为中心的网络，而不是以节点为中心的，一种叫TCPIP的模型，这极大地固化了节点之间的交互，
>>可是，即便这样就够了，上面说到，TCPIP只要完成连通就可以了，这是历史给它的唯一使命，它对于资源的挑拔能力，实在不是它极善的一面。
路由协议，DNS，这些东西，，只能代表有限的节点逻辑，和节点交互逻辑(比如在IP层以下，我们就不好控制TCPIP了)。而，p2p，就是在应用协议层，，来重新提出一个“逻辑上的，基于节点的抽象分布式系[来源：GameRes.com]统”，或者说，来强化，TCPIP这方面的能力，如果这个完成，诸多协议，甚至可以被省了，与其让TCPIP和internet来做节点的OS，不如让这个抽象的分布式系统来做。

>>有真正的网络操作系统吗？只要实现了或集成了TCPIP，(或某种分布式系统协议集)，就是网络操作系统了吗？？没错，，它的确可以管理网络资源（通讯子网和资源子网），即管理网络上的单元，和对这些单元上存在的资源进行寻址。可那毕竟是初级的。，怎么说呢？由于我们的互联网和互联网开发，不允许有真正的p2p，在协议相对的双方通讯，基于UDP，或TCP，必然有一方是B另一方是S端，这不是提出新的协议能解决的(那不过是在已经成型的东西继续做固化的东西)，而是重新架构的问题
可是真正的分布式系统，其实存在于大大小小的各种系统中，比如发生在object model系统中的message based
system一样（signal/slot），它也是一种派发/接受式的分布式系统。所以tcpip仅是internet的分布式OS。
照这样看来，什么nt,novell，linux，其实都不是真正的网络操作系统。TCPIP绝对不是分布式系统的OS。P2P才是。

――――――――――――――――――――――――――C
最后，所谓P2P，到底是什么呢，，本质上，它是基于现有网络设施的，，，软件上的抽象逻辑分布式系统，，它是一种分布式OS。相当于OS和软件，之于硬件和会编指令的关系，，是一种平台的千移。

Re2P是一种抽象分布式系统

传统的TCPIP只是把节点当成了抽象文件，是一种IO设备，这方便UNIX等操作系统将它与本地的IO设备统一看待。可是，把网络节点当设备，网络交互当IO，本地操作系统当网络OS，这就固然缺少一种真正强大的OS之外的应用层的网络模型和网络开发模型，我们知道，它仅是socket，，甚至并没有一个network
manager system。p2p，就好比应用导参见dbms对于持久的管理，比如，一般的网络开发库中都有uniform udptcp的成分存在，p2p就相当于这个部件与地位。

