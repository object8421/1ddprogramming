Gui programming
=============

必须要用微软的系统准备工具，消除不同硬件在操作系统中可能引起部署失败的部分。所以这要求myoldpcs还必须考虑到做成镜像前先把系统处理一下。而这里要用到微软的工具。linux没有这个问题——因为关键的驱动就在内核


linux一体化内核，，将关键的东西都集进内核，，所以，它安装起来和发行起来，都比windows方便得多


内核模块如何实现组件化和动态加载，这其实不只跟C语言本身的组件机制有关。

最底层的图形函数，应是系统依赖的，非移殖的（即内核级的C逻辑），，再被封装为C，用户级的逻辑，才能被用于编程，，，SVGAlib

SVGAlib，，在用户进程级，，怎么做到硬件加速？？

linux下的gl也是工作在x11之上的？？mygod

既然x windows system拖linux的后腿，为什么不直接使用某些靠近graphic driver层，但低于x11层的例程？？，，总之，弃x11不用绕过它，，，如果再发明一个窗口系统就更好了，，这样也算direct hardware access了，，如SVGAlib

Wayland就是改变x11协议的cs结构，变为单一的显示结构，与窗口管理器合作，控制如何去显示的单一功能的部件。

kms,,,,,以前显卡是在 X服务器上工作,,,现在,, 内核可以设定显卡的模式。这样开机启动即可看到漂亮的显示画面，，可以使3d rendering快速化。

wayland是windows的dx

Minlearn's Techsd3drm,retail mode like thing

in wayland,there is no server,,but uniform c/s，我想，这种跨本地与internet的东西，，，一定要使用组件

Minlearn's Techs不光是uniform local far,而且特别是uniform c/s ,,,no server c/s archt

更确切的说，Wayland只是一个协议（Protocol），就像X Window当前的协议——X11一样，它只定义了如何与内核通讯、如何与Client通讯，具体的策略，依然是交给开发者自己。所以Wayland依然 是贯彻“提供机制，而非策略”的Unix程序。







OS级的界面抽象(以及它们在编程中的被抽象)
-------------

附带参见6.2节《应用与抽象》

IO和界面都是程序的本质,一切程序的现实模型. 最初的软件和逻辑都是没有GUI接口的而都只是CUI[1. 图形界面的出现源于苹果电脑的商业尝试],历史上,类Unix下一切逻辑都是Console的,**C这样的系统编程语言建立在Posix字符设备上的输出语句就是命令行的,C没有作为标准存在的GUI库,另外,用它开发出的Unix也一定不需要一个GUI[2. 为什么说一定呢?我们知道,有一些应用必须是CUI的,GUI涉及到复杂的界面刷新,有时导致的线程问题是可以产生破坏性的,但Windows显然没有这么做.],所有计算机逻辑的起点是命令行的,命令行是计算机逻辑发源的真实世界**,当然,类Unix系统也有它的GUI,对于GUI,Unix和Linux是从设计上一开始就将其与底层逻辑分开的. 而其实这跟一般稍微中等应用程序的设计(特别是涉及到移殖)是一样的,,因为应用程序总有它的关于运行的平台逻辑(CPU+OS),,而不总是那些建立在业务领域的高层逻辑,,在完成这些底层逻辑的过程时,也要涉及到界面,,涉及到线程,,涉及到图形,,涉及到SOCKET,,内存模式的数据结构,等,因为这就是PC的逻辑,除非你不是对PC开发(所以说有时高阶语言的开发也跟系统编程有一些相同的领域,而系统编程语言本身跟平台结合导致的一系列底层逻辑也大量出现在开发语言本身的机制和细节中,,也出现在开发语言开发出的可复用库中),, Linux GUI上的GUI逻辑(从X11到Qt,KDE,从X11到GTK,Gnome),都是独立内核的,,如果称内核为操作系统(实际上只是OS的核心一部分)运行在系统的内核空间,那么,X11协议的实作品,桌面环境,窗口管理器,该桌面上的APP,,,都是作为应用程序来运行在内核之上的用户空间的,而不是像Windows一样直接在内核就集成了GUI[3. 附带参见《选读》部分Windows的抽象硬件层,窗口的消息机制,以及DX硬件直访层架构这样的课题],苹果OS在内核集成了X,因此图形效果很好(LINXU桌面没有WINDOWS快),,,,我们平常所谓的UBUNTU所用的桌面环境也只是APP集(在内核上面一点点的逻辑),,,这就是为什么移殖了UBUNTU却不等于移殖了它上面能进行的一切APP一样,因为UNBUT逻辑并不是这些逻辑的直接泛化源而是KDE这样的东西,它与其它APP是地位一样的,处于基本内核之外的用户空间.

至关重要的是要分清desktop afc(这是一种lang sdk - app foudation class)和desktop domain logic framework(这是一种应用抽象),,如j2se之于swt的实现

>移殖这个说法从来都是有条件的,一个程序,跟OS兼容,这个意义是很泛的,是在OS支持的硬件上被支持,可以移殖吗?还是在OS的某个层面上,比如GDI层面,,还是system call层面呢?


qt与mfc的比较，前者采用开源库如sqlite,freetype等，qtgui是类wxwidget之类的东西，后者全是平台sdk封装

>Qt是一个跨平台图形库,在unix,linux下,以x11为基础,当然在windows下,它不一定,它可能以gdi为基础.在欠入式环境下,往往又以framebuffer为基础. X windows,是一种终端协议,就跟基于TCP/IP的协议工程(http,ftp等)一样,它也建立在tcp/ip之上,分字符终端和图形终端.Linux,unix把桌面环境建立在x windows上(而它是一种C/S的网络协议,比如termate://) 比如,x server就是一些拥有“服务器资源”的主机(比如它拥有鼠标,键盘),客户机访问它(通过发送信息给主机,提供点击位置,等参数,要求获取使用鼠标的效果,在主机端制造一个点击效果),通过x windows协议,多台终端可以跟一台主机进程基于终端相连性质的网络交互(unix,linux自始以来,就是多用户的分时系统). X11的内容,不仅仅是一种终端,而且,它还跟显卡驱动相连,所以某种意义上是“图形设备接口” 然而,因为作为“图形设备接口”的x11处在外核级,不受内核调度[4. Linux中,内核进线程跟用户级进线程使用不同的调度机制,二者是独立的.]的有效影响,所以,这造成了它的运行速度大受影响.

历史上地,Sun公司一直在操作系统方面力图占据桌面(比如它的一个失败项目Sun Desktop Sssytem),,它的Open Look 后来败给了Meirf, Unix系统下,MIT X Windows是桌面的CORE,桌面最著名的模型,就是B/C消息模型,用类C++写的桌面系统才有CLASS,用C写的比如GNOME没有窗口类名这样的概念存在,有的只是关于窗口的指针,句柄(这些逻辑可由QT,GTK这样的来产生,也可由编程语言来产生,比如GTK,在库内就实现了＂对象＂这样的逻辑,因此它的窗口也有Class Name这样的逻辑)等. 为什么GUI的设计问题如此重要呢?不给内枋任何更多的运行负担,,因为没有平台相关的逻辑存在,这样OS的内核就不会越做越大. 从C语言的观点来说明桌面,从C 语言的观点可以说明一切逻辑,因为计算机逻辑都是由C开发的,而C本身也最接近计算机的处理逻辑,C抽象了汇编中的一些机器困素,但是它幸好没有做到全部抽象,比如指针,实际上直接跟内存这个部件相关,因此C语言可用来解释很多计算机的东西,,,这是C语言作为教学语方的一个很好的地方. 现在流行的开发一般都分为桌面开发和Ria的WEB开发,但是桌面和WEB应该是被整合的,GOOGLE DESKTOP SEARCH,GNOME的名字中,就有NETWORK,甚至于OS内核中就有网络支持,在GNOME中也有BELGEL这样的桌面搜索,,因此网络跟桌面本来就该在一起,只是WEB和HTTP协议这特定的一块的逻辑得到了长足发展(因为跟企业应用紧紧结合),导致了流行的WEB开发,因此,技术都是受商业驱动的..不要以为技术是很高尚的东西 因此,GNOME这样的图形平台标准,或者一个实现,,就影响了桌面应用,,以及桌面上的很多程序的移殖问题,,从浏览器、办公套件、邮件客户端、音乐/视频播放器、CD/DVD刻录工具、BT下载软件、即时通讯工具以及偏门的音频抓轨工具都一应俱全,,这本质也就是我们在前面说到的是逻辑的关联问题,,比如,浏览器所用的HTML逻辑,就被封装在GNOME中,这造成运行在它上面的WEB浏览器各不一样,因此IE核心,跟FOX核心是不一样的..corba甚至用在GNOME实现内,就像新兴的XML一样也被用在ＧＮＯＭＥ内.大型逻辑的形成,就是在某种语言下,进行系统集成的过程,大部分情况下,业界利用造好的轮子,提出通用的规范[5. 规范与实现的关系请参照《抽象与设计》中的章节.],利用大家都使用的实作品.来进行系统或应用的构建.

web ria ui.
-------------

对于UI,WEB的broswer+html+javascript的方法将UI的开发抽象到了比桌面UI更高的境界.

富网页技术 界面是应用开发中一个永远的主题,虽然不是所有的逻辑都适合被套个GUI的外衣(WINDOWS却干脆把GUI做进系统内核,使GUI不再是一个外衣,而是一件内衣),网页的界面是个近年来越来越流行的话题,在桌面,界面已经有GNOME和GDI,GTK这样的大部头,对于浏览器中能展现的世界,也有相应的界面技术,有一个统称,这就是RIA,主要有三个东西,HTML,AJAX,FLEX等等 其实桌面和浏览器界面从历史上就是在一起的,最初的INTERNET应用程序全是用文字来展现的,比如客户端水木清华的BBS TENLENT,后来BBS也可以用HTML来写,这说明基于TCP/IP的网络应用程序本身是不分桌面接口或浏览器接口的,因为这二者都基于一个OS核心(在这个OS核心内,提供有TCP/IP支持,,而且内核之上的桌面环境中,GNOME提供了渲染网页的逻辑作为APP式的外挂,而WINDOWS则把GDI做进系统内核),,而浏览器端有HTML能更好地为这种应用造出界面而已 浏览器所使用的核心基于桌面环境中封装的一个专门逻辑,叫XHTML,因此开发浏览器的逻辑是跟目标平台上的桌面环境逻辑相关的,富网页技术专注于为WEB套上更好更科学的GUI,因此出现了AJAX,FLEX,等技术 AJAX是一种更科学的网页机制,在浏览器端,通过Javascript等客户端脚本技术,在发生一次由WEB server到broswer的pages pulling时,不必重新pull整个服务器页面,只需要拉取数据发生了改变的部分(因此只需要改变当前网页上那部分的界面逻辑,是服务端的逻辑也是浏览器端的逻辑), 而FLEX刚是ADOBE用FLASH展示的网页系统,用MXML这样的DSL语言来专门开发.比较流行.
界面as非业务逻辑
-------------

你以为GUI是什么呢? 界面GUI这个东西,不是逻辑本身(人们通常以为CUI才是,CUI中提供一些支持界面的逻辑,,然后,界面主体的本质应该是命令行功能支持下的配置描述文件,此时GUI不是逻辑,而是配置),但是界面也可当作逻辑本身来看,,此时,它就不应该是配置 **可见,所谓程序,就是不同的层完成不同的工作而已**[6. 就这层意义来说,操作系统跟一般的用大量其它逻辑组合起来的中型应用比如QT是同等的,因为QT也是由XML,WEBKIT诸多底层库构建起来的上层库],,一个是靠近PC底层的比较细点,,一个是靠近你要做的事的高层,比较抽象点,,这一切体现的精神,,就是封装和接口,,封装体现的终极精神是复用,,复用体现的终极精神是人..
这一章,我们主要用C++来实现,注意,我们在这里谈到C++的时候,假设C++只是=better C+OO,而不考虑其template.因为那是C++的特殊用处.是高高级设计手段,放在这里不合适.

我们知道,一个程序的非系统相关部分,就是它的业务逻辑,它的现实模型(即系统相关的部分)包括:任务,并发,IO,内存,界面,网络,持久,资源文件(这些都是系统用来撑起一个应用程序的手段和基础设施),这体现到开发,就表现为开发上可见的那些系统问题.要在开发上给予解决的那些问题.

其中,任务(被系统core的task running support解决),并发,IO,资源文件(被文件系统解决),全部被系统功能给抽象了.是开发可以不管的.

对于一个网络程序,必须要处理网络逻辑,但是在出现RPC之后,网络逻辑也逐渐被系统作为一种既有功能而实现,而变得开发时可以谈化.

界面,持久,是开发一个程序时,必须要亲自处理的,这就是mfc,vcl等C++库的任务(一般叫foudation framework),而C++语言本身,因为它是OO的,这种“强大的抽象系统应用逻辑的能力,和它呈现给程序员一个强大开发模型的能力”,就表现在这里(如bcb vcl可以通过OO来rad,把界面弄成“事件-驱动”,“BEP”等等).

**业务逻辑除平台逻辑等外最重要的逻辑,编程语言，语言库，框架的目的，就是尽可能把对平台逻辑系统逻辑的编程工作最小化，而专注于业务逻辑**

本章,我们就从这二大部分来解决C++的能力.