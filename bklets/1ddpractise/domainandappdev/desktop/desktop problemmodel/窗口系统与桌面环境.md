窗口系统与桌面环境
=============

Boost为什么不吸纳wxwidget作为其库呢?至少有二个方面的阻碍,1,它不是泛型的(有泛型的GUI库吗?),2,它是平台相关的.厂商的OS相关的.

gui,其实属于多媒体编程的一支,但因为它是一个现代程序的必备模型,所以它成了最不可忽略的那类系统实现与开发问题.(实际上,从GDI上构建游戏而不是程序界面,也属多媒体的一个应用.)

为什么不用3D来作桌面呢?因为3D卡是后来的技术,最初的GUI是来自2D图形卡的,而且,桌面,只需要2D这样的效果.gui是将media.2d作为标准的.

gdi这样的东西,只是工作于内核模式下的一个soft render. 在操作系统之上,能写内核程序吗,当然,rootkit和driver都是

一般情况下DX这样的"直接访问硬件"的库不宜用来作一个OS中的桌面开发,,,为什么用GDI这样的库来完成呢,(比如WINDOWS中),,这是因为GDI是高层的,可以跨平台,在开发时不需要动不动就去访问硬件,而一旦访问硬件,,这种说法一般都体现了它跟平台的相关性,而桌面开发应该属于高级应用,,不跟游戏开发一样,必须要去直接访问硬件才能体现其运行的效立．这就是什么应用适合用什么逻辑来开发的道理．．

像位图的显示,字体的矩阵显示,等等,都是计算机图形学的内容了(要是你知道为什么在画图中划一条斜线有锯齿形状就知道线是用数学矩阵模拟的),有硬件的相关性和复杂的数学基础,但一般在显示字时并不访问硬件,,而是用了高级的库

3d图形加速为什么不能做入系统内核呢,,这是因为操作系统的桌面环境和GUI机制只能是用户级的(而Windows在内核就集成了一个hal),,,因为只有在用户级,才能不出现因为崩溃而把整个操作系统弄崩的现象出现(而opengl等属于硬件直接访问的). 在Windows系统的内核级就集成了hal层,这是一个硬件抽象层,Gdi和dx作为二维图形用户界面和三维多媒体加速虽不属于Windows内核的,,但都工作在系统底层..想象一下,gdi和dx是Windows系统的系统组件..

GUI机制只需要软件加速(在没安装显驱时我们也可以看到桌面,这是因为GUI机制是硬件独立的软件上的东西,是一门OS必须要实现的,而三维加速可以放到后面发展,为了展现多媒体它可以作为硬件相关的或软件渲染,因为它毕竟不是os表现GUI必须的,一般情况下,操作系统为这二个目的开发不同的库,Windows是gdi和dx,类linux是x11和gl)

而linux系统的内核级除了驱动程序之外,完全没有集成硬件抽象集,,x11工作在应用层,,加速库只有opengl,,一般说到linux系统的opengl加速,就是指它的软件加速(opengl有三种工作模式),,linux下除非你下载到了支持显卡硬件加速的驱动时,并且在配置好了桌面环境x11的情况下(通过开启一个dri的东西),,才有可能真正开启硬件加速..一个很可惜的事实是,linux下支持硬件加速的显卡和显驱少见.而且x11工作在外核[1. 外核程序为什么效益不高?除了调度,还是因为外核程序,即用户程序,它们不是direct hardware access.]且由于linux的特定调度机制.这几个情况造成了3d游戏在linux上的不普及..





Windows的方式 : 消息
-------------

GUI,图形用户接口, Window的界面就是一种GUI,而不是一种console,(UNIX下的GTK等也是一种GUI)用在游戏中的GUI是基于DX来实现的,因此它们也参与渲染叫DXGUI

**userinferface不光指graphic interface,而且指input interface**,所以会有消息等机制来处理除了图形显示之外的对于来自用户的交互信息.

>Gdi是2D的绘图引擎(它不但是一个绘制程序图形界面的工具,而且是一个真正意义上的泛意的“绘图引擎”,它的真名是“图形设备接口”,跟“3D图形设备接口”这样的DX相对),可以用来实现界面,也可以用来实现2D游戏. (要知道,在某些要求十分实时的大型应用中,有时只能CONSOLE界面,GUI界面会成为一种瓶颈) 可是它们是DX下的GUI,虽然可用GDI来摸拟(但是这不是一个纯净的基于DX的GUI,而只是一个,比如,在GDI中绘制,然后绘到DX页中的东东)而且DX下的GUI控件有它自己的属性(比如特效啊),这些都不是一个GDI控件所能达到的

那么界面呢,这是因为现在用的都是GUI(GUI也就是表现抽象,一些时候它也跟并发性有关)了,WINDOWS用自己的OS级的GUI,类UNIX的操作系统有它的GTK等等,因此一门语言或库(语言跟库几乎是同重要的东西)也不能不考虑对某个具体平台的界面支持,那么WINDOWS的消息机制呢,这主要是因为WINDOWS是一种基于事件的异步系统(也就是等用户来触发某个消息,WINDOWS才能知道如何对它进行反映),因为又有不同的窗口(Windows就是窗口啊),这些消息(鼠标动作啊,键盘动作啊,计时器事件触发的消息啊,更新时的绘图消息啊,用户自定义消息啊)被发往不同的窗口,对于界面和消息Windows都提供了C语言级的API(因此用汇编都可以调用这些API,只要知道它们的调用方式),而如果用某个库比如MFC来封装这些API以简化对Windows平台依赖性的编程就更好了 JAVA中有它自己的一套界面机制,这就是SWING,它的原理是MVC(界面-视图-控制机制) 但是这些东东要独立处理消息,你发现一些游戏中GUI很难响应消息,这是因为信息不能及时到达(界面有它跟线程和图形相关的代价)

window frame是指一个窗口的基类,它存有这个窗口的矩区大小信息,工具栏,菜单栏的位置信息,所以它并不仅仅是一个容器,前面说了,它是一个逻辑上的基类,而不是一个物理上的容器 window base就是指edit啊,button这些组件

通常在一个基于DX(或某种其它的渲染接口)的应用(utility类APP)或游戏(Game类APP,这类APP较utility不同的时它要求实时消息密集型刷新)中时,这二者所要求的GUI机制是不一样的,这就是为什么窗口模式较之全屏模式来说,全屏模式下可以应用渲染的大部分资源assert,而窗口只能应用一部分适合用做Utility类DX APP开发

本质上你也可把gui作为场景中的static mesh对象(ogre中不可moveable对象实体)进行渲染,就跟渲染静态terrain mesh 一样,控制面板,top view常常被作为静态mesh来渲染(Render to texure技术常常把全景地图绘到一个texture上作微缩地图,因为一个texture本质上承载它的assert也是一个surface而已)

消息机制和绘图机制是微软Windows及其周边其它产品与生俱来的,是Win 系列OS作为一个操作系统进行微机内部实现的二大支柱和特征,消息系统是Windows下一切应用程序间,包括Windows自身,进行交互和通讯的渠道(有些程序并不理会消息,因为它不是标准的Win32程序),是Windows实现对运行在其下的所有应用程序进行控制及应用程序对Windows进行响应的解决手段,因此对Windows的编程,无论是在哪种 语言规范和IDE 下,都不可避免地要涉及到消息处理,虽然有些编程语言如 VB 用事件驱动编程机制在很大程度上封装了消息的复杂性,但若要深入Win32编程,就必须学习Windows的消息系统,正如游戏编程要掌握Win的绘图机制一样,而只要你一旦深韵了这二大支柱和基本,你就掌握了Win32编程的根本.. 消息的产生来源于系统事情(包括计时器事件)和用户事情,Windows用消息来调入和关闭(还有其它处理,如绘制一个窗口等)应用程序,一个典型表现是在关机操作中,Windows发一个关机的消息给所有正在运行的应用程序,告知它们退出内存,此时,应用程序用回应消息的方法来响应OS,因此,消息是应用程序与WinOS交互的手段.. 消息的主体是应用程序之间和应用程序与 OS 之间,(这是通俗的说法,其实在一个应用程序的内部,各“窗口”组件之间也存在着消息的流动,窗口组件与它们的父窗口和上层窗口之间当然也有消息的传递过程(如"命令传递",后面在跟踪一个消息的路径中将会详谈),Windows内部即时流动的消息数量是如此的宠大,程序实现之外的手工分析是一种很自不量力的事情)消息的最终主体却是窗口与窗口之间,窗口与OS之间 - 因为在MFC的技术规范里,只有窗口进程才能发送和接收一个消息并处理它,当然一些非界面窗口类如文档类也能处理一个消息,消息的最终归宿是某个窗口类的成员函数,也就是进入消息处理函数被处理,或被某个非界面类也就是内部处理类如文档类处理,系统中默认的窗口类和用户注册的窗口类都有进程,都能在内存中创建实在的窗口对象,窗口对象和窗口类接收和处理(千万注意:接收一个消息和处理一个消息是相差甚大的二个过程,后面将在讨论重定向一个消息技术时将谈到)发往它或由它主动发往别的窗口进程或OS的消息,修改窗口进程干涉窗口进程对消息的处理过程(而不是接收过程,这个区别的详细解释请参见后面从"注意消息泵并不是一个.."起的文字)是可能的(窗口进程只是一段函数),但是如果这个窗口进程属于别人,如系统的窗口类,你将没有源程序进行修改,但却可以用消息重定的技术加以干涉,比如用户自定义的窗口类,用户完全可以自定义它的窗口进程,编写自己的消息泵,实现对消息的重定向,编写用户自己的消息泵属于Win32编程中重定向一个消息的七大技术之一. MFC中有七种技术可以用来重定向一个消息,它们是:1,子分类2,超分类3,OnCmdMsg(),4,SetCapture5,编写自己的消息泵,6,SetWindowsHookEx(),人们常说的钩子函数,便是其中之一. 在谈完消息泵的概念后,我们将一步一步追踪一个消息在系统中的路径,然后才能讨论对它的重定向. 消息泵并不是一个窗口类的窗口进程,虽然它们都是函数,同样都对注入到这个窗口进程的消息进行工作,而并不最终处理消息本身(上面已经说到原因),消息泵是一个通俗的说法,它只与消息被发往窗口进程后的接收工作有关而不与处理过程有关(上面也已经说到消息的接收和处理是二不同过程),而窗口进程恰恰相反它只与处理有关不与接收有关下面开始详述.. 消息泵被包含在 CWinApp 的成员函数Run()中..........写得太累了,,,未完待续.

实际上在UML的规范里,消息是一切对象发生联系形成系统的手段.

入队消息与非入队消息 走出Windows