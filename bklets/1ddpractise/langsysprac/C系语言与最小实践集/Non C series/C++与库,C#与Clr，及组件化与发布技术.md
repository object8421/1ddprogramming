/*!

\page C++与库,c#与clr.html

============= C++与库,c#与clr

对于库，CPP没有真正拿来就用的标准，而JAVA和.net有，，这种batteryincluded的强封装特性，，才是真正现代OOP语言，才是程序员的语言(every programming has their own codebase，可以是第三方库，可以是自发明的库，可以是仅依赖语言官方提供的标准)而不是C那种没有任何完善库的工程师专用语言。

>>没有装备类minqw的CPP语言不算好的OOP语言，，stl,boost使现今的CPP成为好的泛型语言，，却不是好的OOP语言。


框架往往是多个设计之上的总设计（形成一个框架），这样的设计如果被体现为一个开发库，往往从一个点进行复用，，比如dfk,domain framework与afc,,appfoudationclass


>>在随语言附送的开发包中，，应该提供三个层次的可复用单元，第一个是foundationclasses(这里放置general,,domain spefied basic and lowlevel reuseable elements),第二个是frameworks(比如一个game framework lib),第三个是products(比如一个game enine),,再加上一个辅助层次xpassits(test,docs)，，，bookaddsrc就是这样安排的


作为整体使用的，该整体设计，比如一个AFC，做为散体使用的，该设计为散体，比如Foundation class as langstdlib

所以框架，一般都是自下而上的，它是一次设计中强调预设计的典型

------------- 语言与库


当平台不够强大时，比如cpp这样的语言写出的库中（由于其标准库和面向平台不够抽象---比如相对于.net和clr）那么，这些库一般在其内进 
行了扩展语言与平台的动作，这个意义，任何编程都是平台支持加平台扩展的系统编程 

语言和平台一体化(这二者本来都是软件，往往是同源的只不过前者生成软件后者运行软件)的倾向表现在，.net这样的类库有编译器逻辑，平台与语言，语言比较强大点 

由于语言本身就是软件抽象，所以可用编程来解决语言本身提供的设施不足的问题（强化语言本身的设施）或强化OO手段，而不依赖于库或外来设施。

在一个库的源码中，假设它被组件化成dll，那么全局变量和他们所在的头文件，往往作为SDK API和SDK头。 

有的库会设置一些指针stub（Ptr Pass）来隐藏内部实现，而将全局变量（往往是类级概念的变量）传递为某些特定类COM的引用。无论哪种方式，都并不提倡成员函数



库即应用，编程即应用调用形成新应用 


>库跟语言的关系是什么呢,,语言可以通过库来扩展,,《C++沉思录》中说“库就是语言”,“语言就是库”,,比如数组是语言内含类型,但是基于面向对象的需要,,就提供了Vector类来wrapper数组,,这就是库对语言的扩展作用..(相比来说,如果语言是一种使用规范,那么一个库是为了某个特定领域—比如OO,而精心设计的,一般要求精细的设计)
模板的初级应用是作为容器(异型或同型)来使用的,实际上它还有作为Generic programe的很多高级应用,如编译期策略 STL被称为总数据结构(因为它的元素是数值和对象都可以-异型或同型容器,而且它包含了对于一种数据结构的存储,,访问的方方面面的抽象) 这就是对数据结构的整合(stl)还有策略(可以称得上是对设计模式的整合) stl甚至都抽象了多种数据结构的使用方式,stl被作为数据类型的模板(但是它显然还有更更高级的应用,,作为container的模板只是模板的初级应用而已) 这些原语程序设计手段也作为一个库(即stl也跟mfc一样是OOP的一个重要方面,,,当然还有构件库比如ATL等等)被提供在一门语言的编译器中,但是.net就整合了这二种库,,而且它是跟本地脱钩的

**工具库与架构库**

既然有面向纯粹实现抽象的**工具库**，也就有纯粹由可复用抽象组成的**框架库**。

所以，大量可选的实现要做进一个设计时（其中有个默认的实现），也可以不置任何封装抽象，或设置一个框架在架构的最顶层，并提供每个默认实现（一个既有复用抽象，又有实际实现的抽象的库才有扩展意义），总而言之，但是也可以写一个由架构抽象和默认实现抽象组成的程序。

plugin不光是一种组件，，更多地，是一种组件架构，它是由hoster一方主动attach，plugin一方plugin来完成的，其底层是DLL的动态载入逻 
辑(导出接口)，然而，其高层是hoster的import逻辑(程序内抽象)

plugin core,plugin backend

一个xxmgr.cpp的源码逻辑基本上说明了有一套逻辑上的framework存在

cpp与库中重点说下库扩展语言与语言扩展库的优势比较，提一下c plus oop lib

gui programming放deskenv处在OS架构的第几层(它是分发层的桌面环境层，所以)，写，更多请参照CPP的库那一节


**当一个程序完成了领域抽象之后，它剩下的的所有事情就是使之“变得工程化”**，所以OGRE这样的程序库，不但是数据结构加算法的实现抽象库（ogre中的gr），而且还是面向扩展的封装抽象库（ogre中的open,engine化）

对于C++的库来说，它一般是用结构，语句，函数，类，接口，抽象类等组成的，自成逻辑的一个松散或逻辑深入到应用的有机整体（通常称一个可编译成一个dll或lib的一组函数，类，模块，抽象接口的整合为“库”），但是这里面有二种库，一种是“工具库”，即那种大部分都是函数的代码库，这种库更理应被称为应用程序，因为只有在里面提供一个main()过程，再引用库内一些逻辑，就可以形成一个程序。

我们所说的库，更多的情况下，其实是指那种强烈面向复用的“可复用库”，这种库就是有别于工具库的“抽象架构库”，它一般提供了很好的代码隐藏封装等利用被复用的因素，函数，类，，接口都是“面向复用的”，但是这三者中，只有接口，才是唯一“一定”面向复用的东西。因此，com这些东西，，，就被称为组件，组件一定是个架构库，由函数，类组成的“可复用库”不一定是“架构库”。

不仅C++如此,其他一些语言(比如:Java)也拥有众多的库.这些库在我们进行软件开发时,为我们提供了强大的支持.不过,这些库往往都只实现了它所针对领域的一些通用基础性的问题.因此,在某些特定问题上,可能无法直接地使用这些库来进行表达.此时,你就应该考虑建立一个特定于自己问题的特定库了.


boost实际上强调你去用，而不是去理解它，模板仅是提倡用来建立库。

一个桌面程序员的桌面应有限的包括仅：桌面afc sdk,语言ide,开发辅助工具，语言标准库 sdk，领域框架df sdk,以及上面提到的所有sdk的文档，就像一个web程序员仅安装一套j2se（如果它是java桌面程序员）或j2ee（如果它是java分布开发程序员）一样。


**以下来自转载**

>抽象、库和DSL C++之父Bjarne Stroustrup经常强调的“用库来扩充语言,用库来进行思考”( <a href="http://www.artima.com/intv/elegance.html%E6%9C%89%E8%BF%91%E6%9C%9F%E5%AF%B9Bjarne">http://www.artima.com/intv/elegance.html有近期对Bjarne</a> Stroustrup的采访,他再次强调了这个问题),其实就是在强调DSL以及自下向上开发的重要性.库就是DSL的一种形式,Bjarne Stroustrup所列举的科学计算库的例子就是科学计算领域的DSL.构建库的过程其实就是在朝着更加贴近问题领域抽象的方向迈进.明白了这一点,我们就不难理解Bjarne Stroustrup一直强调的泛型在构建一个优雅、高效库的方面的重要性了,因为泛型为构建这种抽象提供了一个坚实的基础.

**对于使用了OO的语言，它的标准库往往是一套对象系统**，比如典型的对象系统其基元类一般是system.object这样命名的，它一般只完成对象比较等最基本的任务，作为产生这个宠大的对象系统中其它对象的基类；

一个OO程序本质是一些类数据(jar文件包里全是class文件),类是真正意义上的数据(类型),然而在JAVA中,JAVA提供了数值类型对象的对象封装型和非对象封装型,(因为对所有的东西进行对象封装有时不符合现实而且对象机制一定程序上比面向过程慢--这就是C向C++转型中有人担心 C++其实由于它的封装技术而导致的速度问题,你可以把整型看作一个对象但是传统观念里已经把它作为数值看待,一般程序设计语言都将数据类型的数据作为 first class来看待,就是那种Java库src包内的那些对象,这些对象是高级对象,因为程序设计语言一般为他们装备了足够多的功能和运算符,可以由它们派生很多其它的数据类型)

OO编程时,在分类事物时,我们时常碰到中间抽象的分类边界,,,这就是粒度,元(元是老子提出来的词),用在JAVA,.NET库中就是名字空间,接口,MeteData等

在学习JDK,CL类库时,,实际上就是学习sun和microsoft如何对编程领域与现实世界结合点的那些事物(或称对象)的架构进行划分与整合的过程 (注意这里提到了划分与整合),,在原来的程序设计语言和系统编程中,往往这些事物(窗体,,IO,,,WEB,,DB)是分开来学习和使用在OO代码中的(想像一下在VC6的MFC中,需要使用一个库对象时跟在C井中的类包中的区别),然而,在.NET类库和JFC中对他们进行了很多重整合与重划分

想像一下Sun和Microsoft在划分和整合这些对象时的情形,选择一个好的粒度比率显然是很重要的(为这些粒度命一个好名往往更是一个很艰巨的过程, 常常采用接口+able后缀形容词的形式,如IConvertible表示可cast对象或类的集合,现在的大型类库都跟接口息息相关,因此它的低层 IConvertible是一些描述性的高抽象形容词表示的一个接口对象, ),聚合跟分离的边界划分,(如果过于强调整合就会造成装箱开销过大,,如果过于强调分离就会导致学习和使用上的不便) ,对于名字空间(Java居然用了文件夹和公司域名表达与名字空间的对应,实在是绝！这体现了WEB这个粒度越来越靠近其它的类库粒度,所有编程中出现的事物都趋于跟WEB整合,人们正在寻求所有本地事物与WEB的结合点,其它一些例子比如DCOM,XML,RMI也是这样)

多少人明白domain这个词的意义呢,如果泛化起来,会是什么意义,任何问题求本溯源就是一个世界,一个领域)其实domain这个词是在原语领域描述事物分类的,每个事物都有一个name,受某个domain类name来管理,因此,以什么粒度以什么元meta来分类事物并命名以产生一个命名机制呢,就是domain name这个词的由来,(元是老子提出来的,古人希望把世界的本质用元这个形式形式化下来)

Java的源程序文件夹也是这样,你难得找到一种命名为你的所有大大小小的逻辑命名并人为区别,所以sun找了一个domainname形式,,分类学与命名学是对软工尤为有意义的,,只有sun意识到了它

>以前的语言是运行库服从语言，现在的.net,java类语言体系有着鲜明的语言服从运行库(其实C语言的标准库也不完全是语言库,而是C语言封装了的关于平台逻辑的库,比如IO,语言是没有IO的,任何编程都首先是平台问题) 的特点

造成这种现象是因为C这样的语言不强调库而强调语言，因为它的系统编程很狭隘，解决问题的方式很统一，并不须对此进行标准化，而.net,java类语言库必须把平台问题解决掉并标准化，然后留足精力去发展基于平台上的应用问题。 这也是C++之父敦促业界快点发展C++的库将其推进与.net.java同列的目的所在。

为什么使用JAVA,,这个原因不在于JAVA是一门纯OO语言这么简单(实际上它的支持系统比JAVA本身还重要,,一般把.NET,JAVA看作真正的OO语言,因为它们提供的OO类库实在是全),而在于它的JFC满足复用,扩展,这个世界低价的,多功能的替代品很多了, 然而一个在设计上就预见了将来扩展需要的类库只有JAVA Foundation Class(JAVA的基础类,虽然JFC一般指SWT界面库但是我们这里把它作为JDK的全部库来看待),深入JAVA,深入JAVA的类库,你必须拿出系统分析师的神经质,来领略其设计上的架构,而不仅仅是依照流传的文档进行依样画胡的设计,
记得在看谭的C++第二版时时文件是流,然而会有多少人明白这是一个含义颇深的话,如果你去看JAVA的IO,,它完全把文件,数据库,网络,内存,流视为同一个东西(甚至对象也可序列化,,可序列的意思就是,,内存中的对象,,文件啊都是内存中面向流的stream flow,,,通过序列化就可以把它反持久化为结构化的对象,,一般是指XML,,,,即二进制到文本格式的转化),,这就是原语泛化学习的好处(但是在使用上起初并不令人很容易上手,但是一段时间之后,你就会收获很大),因为它们本来就是同质的东西,就像网络数据流其实跟文件十六进制码同是一样,,反工程它们也是相近的二个过程.
这就是整合与分解的体现之处,也是人们认识世界共性的一种体现(用于编程领域).
以上是IO,在一些细节和公用概念方面,JAVA类库也有它们自己的一套概念,如MVC(界面设计中的模型控制视图),设计模式等,





------------- C++的库

###### libstd++
###### stl
###### boost
C++ boost中大量与函数有关的库与组件，它们并非意在把c++发展为一个fp语言，而是把c++发展成一门跟C井一样包含有类似委托的语言机制，相比而言，boost.lambda(boost.lambda这样的库使C++成为fp.利用表达式范式进行编程，**表达式范式是异于OO的另一种编程典范**)，boost中的mpl跟函数编程有关性要强很多.
###### mfc : shipped with windows

基础类并不是domain framework,,其实，gui,net,db是desktop的domain.但qt封装它们，只是fc


Appcompent造就了desktopappfc while domainfwk造就了不同的os发行版


sdk=foundationclass(langstdlibs)＋afk 

Afc是属于os desktop的，如qt,当然common desktop dev有其app framewk,epage这样的领域库也其app framewk,它们着眼于解决产出一个app前的那些逻辑的封装，提供一个app框架，那么这二者比较起来会是怎样呢，熟大熟小呢？其实不可能比较，领域逻辑的大小是不定的。有的基于OS之上的领域逻辑并不比OS本身加OS桌面组起来的领域小。这就是说：


一个复杂的软件系统组成了一个小生态，往往这个小生态虽小，但俱全得跟发明一个os差不多，所以有时发明一个os跟发明一个具体大应用所需的人年根本无法去比




在VC++出现之后,一切在Windows下的软件编程工作似乎都变得那么自然了,VC++加MFC[1. mfc,jfc都是afl,即application framework library,实际上它们只解决极为有限的那类问题,即程序模型问题,去除建立这个固定框架中的重复劳动,这些都是被正确了解并抽象了的东西,所以可以做成框架,但其实,业务东西的东西才是广大的主体,所以说前者只解决了颇为有限的那些东西.]的解决手段使Windows下的程序员多了起来,同时也让 Windows的用户多了起来,一切尽在微软的掌握之中,VC++如愿成为Windows程序员专业的SDK[2. sdk是什么?就是开发过程用到的所有东东,所谓windows sdk,就是假设windows以C源码形式发布的一个个lib文件,它们所对应的头文件.Win32有它的SDK,被集成在VC++中,一些大中型软件也有SDK,如DX SDK,MAX SDK,等等,一般大型第三方库除了提供一个运行库之外,一般还发布一个可定制的编程集,这就是SDK,它一般是指没有封装的原始API集],一方面,VC++使用的语言规范是C++,这是最有前途和最流行的语言,另一方面,MFC提供了对C++下图形化界面编程和消息处理机制的编程实现,这曾经是 Windows下软件开发的2大技术难点,MFC虽然不是完美的,因为它在对API函数封装的过程中出现了一定的冗余,但正因为MFC是微软自己对 Windows下软件编程的解决方案,无疑它是最好的,在出现了如BCB这样的IDE后,软件界面的设计可以纯手工搭建,但是这种方式是以一定的功能要素为代价的,要深入Win32编程,深谙Windows的消息编程技术,最好使用MFC. MFC实现对界面编程的工作是通过封装API中用来进行界面开发的函数来进行的,可以想象,创建一个窗口对象所必需的参数无论是在MFC环境中,还是在API环境中,本质上都是相同的,对消息机制编程的支持, 微软是这样做到的:消息被发送到某个类的窗口进程中,让消息最终进入Windows的一个类的成员函数中(注意:不要被诸如"Windows的类"这样的概念感到不解,不要以为类的概念只出现在C++的技术规范里),让消息最终被这个类的这个成员函数处理掉,此时成员函数名通常就是"On_"+消息标识 (如WM_Paint)的样式,这显然是符合C++的封装技术的. MFC应用程序用窗口进程来接收和处理一个发往它的消息,(前面说到,接收和处理是二不同过程,又说到,消息泵和窗口进程是二个不同的概念),其它的非MFC应用程序,如用VB,Dephi开发的普通应用程序,包括非图形界面的 32位应用程序,以及其它一些运行在Win OS下的应用程序,也都存在着与其它应用程序或操作系统的消息交互,消息的有无与开发环境无关,但是消息(在程序代码中是一个大写的标识)的流转方式在 MFC环境下和API环境下是明显不一样的,根本原因在于MFC应用程序对消息进行了更复杂的回旋处理,刻意让消息的流转走了好多弯路,即不断地调用函数让消息进行流转,而这,是微软基于C++的封装技术要求考虑的,是十分合理的,这就是MFC技术之一的"消息映射","消息映射"模式无疑走了一些弯路, 带来了一点复杂性,但却又是一种需要,因为MFC是for C++的,"消息映射"就是要让MFC满足C++的类的封装技术(文完).

MFC, 微软基础类(Microsoft Foundation Classes),实际上是微软提供的,用于在C++环境下编写应用程序的一个框架和引擎,VC++是WinOS下开发人员使用的专业C++ SDK(SDK,Standard SoftWare Develop Kit,专业软件开发平台),MFC就是挂在它之上的一个输助软件开发包,MFC作为与VC++血肉相连的部分(注意C++和VC++的区别:C++是一种程序设计语言,是一种大家都承认的软件编制的通用规范,而VC++只是一个编译器,或者说是一种编译器+源程序编辑器的 IDE,WS,PlatForm,这跟Pascal和Dephi的关系一个道理,Pascal是Dephi的语言基础,Dephi使用Pascal规范来进行Win下应用程序的开发和编译,却不同于Basic语言和VB的关系,Basic语言在VB开发出来被应用的年代已经成了Basic语言的新规范,VB新加的Basic语言要素,如面对对象程序设计的要素,是一种性质上的飞跃,使VB既是一个IDE,又成长成一个新的程序设计语言),MFC同 BC++集成的VCL一样是一个非外挂式的软件包,类库,只不过MFC类是微软为VC++专配的.. MFC是Win API与C++的结合,所以MFC是C++封装实现下的Objects,API,即微软提供的WinOS下应用程序的编程语言接口,是一种软件编程的规范,但不是一种程序开发语言本身,可以允许用户使用各种各样的第三方(如我是一方,微软是一方,Borland就是第三方)的编程语言来进行对Win OS下应用程序的开发,使这些被开发出来的应用程序能在WinOS下运行,比如VB,VC++,Java,Dehpi编程语言函数本质上全部源于API, 因此用它们开发出来的应用程序都能工作在WinOS的消息机制和绘图里,遵守WinOS作为一个操作系统的内部实现,这其实也是一种必要,微软如果不提供 API,这个世上对Win编程的工作就不会存在,微软的产品就会迅速从时尚变成垃圾,上面说到MFC是微软对API函数的专用C++封装,这种结合一方面让用户使用微软的专业C++ SDK来进行Win下应用程序的开发变得容易,因为MFC是对API的封装,微软做了大量的工作,隐藏了好多内节程序开发人员在Win下用C++ &amp; MFC编制软件时的大量内节,如应用程序实现消息的处理,设备环境绘图,这种结合是以方便为目的的,必定要付出一定代价(这是微软的一向作风),因此就造成了MFC对类封装中的一定程度的的冗余和迂回,但这是可以接受的.. 最后要明白MFC不只是一个功能单纯的界面开发系统,它提供的类绝大部分用来进行界面开发,关联一个窗口的动作,但它提供的类中有好多类不与一个窗口关联,即类的作用不是一个界面类,不实现对一个窗口对象的控制(如创建,销毁),而是一些在WinOS(用MFC编写的程序绝大部分都在WinOS中运行)中实现内部处理的类,如数据库的管理类等,学习中最应花费时间的是消息和设备环境,对C++和MFC的学习中最难的部分是指针,C++面向对像程序设计的其它部分,如数据类型,流程控制都不难,建议学习数据结构C++版.. mfc的消息机制就是一种表驱动
(2)

所有在程序中用按钮窗口类创建的窗口对象都共享一个共同的按钮窗口进程,注意:类有进程,用这个类创建的对象同样也有进程,这个进程便是它所属类(类的属别关系有二种,基类和派生类即父类和子类,即逻辑结构上的类的属别关系.上层类和下层类也就是物理结构上的类的属别,如在一个 MDI 中,文档类是视图类的下层类视图类和文档类又是框架类的下层类,再比如一个普通的对话框类对话框类本身是CWnd 类的一个子类,对话框上的某个按钮是通用窗口的子类,但却是这个对话框类的下次类不能称它是该对话框类的子类)的进程,如果一个WM-PAINT消息被发送到某个窗口对象,比如一个对话框上的某个按钮,术语称:消息被发送到这个按钮的窗口进程里,而实际上:消息被发送到了通用按钮窗口类(按钮窗口作为 Windows OS 下的窗口三大类别之一的子窗口,与弹出式窗口如对话框窗口重叠式窗口如一个SDI 或MDI应用程序的主窗口并行.),其内部实现是:消息被发送到了通用按钮窗口类之后,通用按钮类窗口进程根据这个预窗口对象指定的大小和位置风格(在程序中这些参数被传递给通用按钮窗口类进程)画出确切的按钮对象即该按钮在屏幕上的物理表示,, 可见界面类往往都与一个窗口对象实际关联着,窗口对象在程序中定义并被加载时它在计算机内存中有确切的物理表示.并通常用一个指针变量来指向它的地址. 窗口进程到底是什么东西呢,(回调函数是一种异步消息)它们实际上是一段函数,(这段函数在这个类被定义时就被定义了如CWnd类的窗口进程,用户可以定义自己的窗口进程然后进行任意的修改,但操作系统的类,如CWnd的进程不能被修改,要干涉它的消息处理过程就要学到消息重定向了,消息重定向是MFC中最诱人的技术)MFC编程机制中用它来实现对消息的处理,实现Win32的消息机制,这里千万注意:窗口进程不是普通意义上的“类的消息处理函数”,它们是进入到某“类”(这一类的窗口对象都共享这个“类”的窗口进程,)窗口消息的总的管理者,这有别于作为一个类的成员函数的“类的消息处理函数”,因为这些函数才是消息的最终归宿和被最终处理的源 头.(未完待续.)

###### 第三方的解决方案

<dl><dd>QT,Wxwidget,Win32GUI,MySQL,ACE</dd></dl>第三方[3. 你,我,是二方,他是第三方,比如我用BOOST.Asio编程,boost是标准的,那么ace就是第三方.]的解决方案:QT,Wxwidget,Win32GUI,MySQL,ACE

QT其实更像是一种CPP语言，特别是它的事件控制，是对标准CPP的trick enhancement,而且，它的封装库，是对native领域的全面封装，这像极了一门脚本语言提供的封装native的那些库和扩展

**实际开发的多选择**
在开始任何中大型软件的创建时,必须分清一些现实的情况,第一个问题,也是最最基本的问题,就是考虑开发的起点问题,比如,“以哪些已有平台”为基础进行开发,如果决定将软件布署在一个OS上,是使用这个平台上的轮子(OS API),还是重造一些轮子.选用大量轮子，这是现今软工的特点。

什么是第三方呢?即标准方,非标准方与自己(开发者)的关系,在我们的开发中,处处涉及到如何处理与第三方的关系:

前面说了,我们的开发,其实都是直接或间接基于某种平台之上的开发,比如操作系统作为软件系统开发,其一定基于某种硬件架构系统,所以,基于x86的 windows一定跟基于sun的windows(假设它存在)开发不一样,对于开发者来说,在选择硬件架构系统这个点上存在块择.

另外,对于开发者,它可以选择相同硬件平台不同的OS,比如x86上都存在的linux或windows

如果说x86是windows的标准平台(实际上也是这样),那么sun PC就是第三方解决方案,第三方往往意味着它是可选的,x86和我,就是前二方.

这个概念还适用于开发的其它下面层次,比如,如果选择了在windows上进行开发,对于语言,可以选择VB和C作开发,C是软件系统开发的标准语言,那么 VB就是第三方,确定了语言之后就是选择编译器,windows上标准的C,C++编译器是vs,那么gnuC++ for windows(mingw)就是第三方解决方案,在系统开发层,数据库接口就是odbc,是windows平台上的标准,那么 mysql,db2,oracle就是第三方.我们的开发,往往在某个层次,存在可选的支系化,不一定圈死在厂商提供的解决方案中,这就导出了下一节的话题“标准库与厂商库”

**标准库与厂商库**
故,存在以下几种考虑:

将软件布署在某个平台,但不使用平台上任何东西,一切只“以语言为起点”,此时,有OS,但以语言为中心,甚至不使用语言的标准库,或极少使用语言的标准库 (它是平台不相关的),或第三方库,而不利用OS的API.

>(比如,在开发一个OS时,我们使用C语言,但往往不用C的库,因为它们是工作在用户级别的,内核级不可能把整个c runtime含入,所以,像基本的malloc这样的函数,需要用C来重实现)

“以操作系统为起点的开发“,此时,有语言,且利用“OS上的轮子“,比如ＭＦＣ(它是windows的foudation class.是厂商相关的),而不利用第三方解决方案.

在win32 sdk中,我们可以看到诸如bitmap object这样的api,它跟windows的设备环境,字体有关系,windows 借助这些实现dc,font等,而一般地,在游戏开发中,我们也会看到独立的bitmap单元,而游戏开发属于多媒体,这就是说,其实os也跟非os的部分有相重之处. (在这里我们提到的os不是os kernel),也即,既然windows也有它关于os的bitmap实现,于是,我们可以直接采用平台关于bitmap的逻辑,这也就是“以(重用) 平台(上的轮子)为中心的开发”,不要把它跟一些游戏sdk提供的bitmap单元(有时它们并不采用windows的平台相关的bitmap逻辑)混淆了.还比如windows上也有对象之说,这些对象实际上是C的对象,而我们知道C++才有对象之说,这实际上是以语言为中心的开发导致的差距.

第三种,也是最纯粹的开发, “0为起点的开发”,要从“选择或实现一种硬件平台”,“发明OS”解决软件运行平台开始,“发明一种语言”解决语言开始,再“发明这种语言的库”之类, 当一切完成之后,再实现这个软件.(这样的库和开发,无视OS的存在,是由内核程序或硬件程序发展起来的一整套开发)

这三种情况,涉及到的情形差别是很大的.另外,**开发除了分以语言为中心,复用式开发外,还分是直接面向应用式开发还是面向中间库式开发**, 这二者所需要的能力也是不一样的.后者因为考虑到要留可供复用的接口,涉及到的设计能力很多.而如果只是快速提出一个原型,那么可以开发很快(因为开发前没有预留接口,所以这样的软件不太好维护,所以极限方法论,提倡“后于原型的重构”,在这种情形下,用到的技术大都是设计模式上的,但是重构往往很容易并且可控,因为它可以很容易形成一种迭代式的过程.

**所谓标准库,是指,语言的标准库**, C和C++一样,因为是平台相关的语言,因为平台有很多种,所以,(C++,mfc和vcl这样的东西,都是平台相关的)都不可能有一个标准库,,因为标准库,不可能是厂商相关的厂商标准库(这样的第三方解决方案).. 应用逻辑没有标准,只有厂商,所以Ｃ＋＋对于应用,没有标准库,内核逻辑有posix标准,所以Ｃ有关于系统的标准库,Ｃ关于系统的标准库也是Ｃ＋＋用的(cassert,cbitset等这些以Ｃ打头的,它们也是Ｃ＋＋的标准库)

>Mfc等应用库一般会被厂商控制，而语言标准库一般掌握在语言发行者和社区手中

C++对STL的库设施,是不是一种定位错误? 是,其实,MFC,,VCL,更能代表作为C++的标准库并存在(因为C++体现在平台开发上,就是要解决对OS main api的封装).但是MFC是基于特定的平台的(win32), MFC没能成为C++的标准,是因为作为C++标准的库不可能针对一个特例平台.那么有没有对于C++标准的通用平台库呢?我们说,可以有,也可以没有.

>Stl的一个基本目的只是为了给C++的内部类型在库级进行扩充，故它不是单纯意义上的数据结构库，而是C++的“高级类型”库。

这是为什么呢?比如对于GUI库,其实完全可以有wxwidgets这样的平台无关的存在,所以C++可以不要这样的标准(它跟C 一样,提倡要标准化的地方,其实正是不需要标准化的地方,因为系统问题是一个选择性很高的地方,C,C++唯一提倡的,就是从基本类型开始).所以,一直到现在,C++也没有自己的正确的架构在better C+OO上的标准库.相反的,在基于better c+OO+template的层面上,C++却有STL和BOOST这样的标准库.

对于平台上的开发,提倡用mfc或 vcl,stl,Boost等这样的已有解决方案,而且是“标准”库,而不是寻求开源社区通用的可移殖库[4. 开源社区的东西往往不是语言的标准,或厂商标准,所以,它最不具平台依赖性,往往是移殖考虑时的好选择.但你也要知道,从来没有真正的那个跨平台存在,一切,都是权宜之计.],或其它第三方解决方案.如果不是为移殖,等等目的,用MFC或BCB的VCL中相关的“轮子”就够了(除非没有或基于特定目的,才需要重实现已有的东西),

第三方往往意味着平台独立,但其实后者的选择是以前者为基础的.所以越到层次的前面,选择的机会和可能越小. 比如绝大多数应用和开发,语言,库,都是建立在类unix和windows上面的.对于开发者来说,选择跨平台,往往是这个“跨平台”(实际上跨平台真正的意思是多平台支持),也是以一系列它前面的“既有平台”为基础的,所以,跨平台从来是个伪概念.第三方解决方案并不绝对平台独立.所以不要盲目跨平台, 它们都是工具(相比系统实现有一套标准posix,系统开发往往没有一套标准,它们是极度多选择性的),对于工具,它们的意义在于拿来就用,如果为选择工具举棋不定,太执著于它们的好用不好用,(而忽略了它们背后的主体系统问题),那反而模糊了工具的意义,所以,学习中,要弄清系统问题本身在先.

------------- Cpp的组件机制:COM

com发展了dll，。net vm又发展了com的套间等概念，二进制组件的概念越来越强大（dll到com，dcom），越来越整合化（com的东西全部集进vm） 

activex，dcom，不但是对象通讯，还是对象之间欠入，这就是说，它其实也是本地分布式。不必一定要经过网络。本地也存在一个由组件(提供的服务和接受服务的一方)组成的分布式环境

对于组件来说，，，，分布式必定是CS的，所以，必须工作在组件级，而非本地与本地开发的源码级，，，这样，我们就分清了组件技术中的主体与客体关系，，，要知道，，组件技术，，同时是语言（二进制构件）的，，和分布式的，要分清组件在这二者之间的联系与区别

jvm这样的东西，，，就是将运行时同时作为本地开发与远程开发，，靠运行时之间的网络通讯，，取代IPC与RPC，，，，这样不够uniform,,i hate this,,本地和网络IPC统一起来，使得网络对IPC而言是透明的，难道真不存在这样的架构？


云计算，，如果能将svc/cli的交互保持在进程级，，组件级，，就能保持在源码级，，，就能使本地开发与远程开发，如WEB开发，，统一化。并根本去掉svc/cli架构，，形成uniform的架构


com所代表的新组件技术，，其实就是二进级别级的动态配置，动态发布

组件的主要目的是为了解决分布式，而不是二进制复用那是他带来的第二效用(面向开发，解决开发方式问题方面的)，，或者配套产品

组件的自省化太重要了，这样，组件就是动态运行期组装的assemblys，，不必固化也不应固化，组件本来就被设计成替换静态源码指定，，但在运行期加载的DLLs.

j2ee用组件容器来解决分布式程序框架提供的做法是可笑的，因为那需要很多额外技术，，比如WEB前端技术，，组件自省技术，，组件自省是好的，，但不应作为程序框架和yun app model被使用


组件编程，，就是组件元数据在动态运行时的获取，（这就要求组件像语言内置的其它单位，---比如类，函数，等，有后端内存模型支持），比如，用反射，，就像C#一样，，QT也支持吗

jvm是跨网络平台所以其程序也是跨网络程序，这有别于非整合的corba等方案，而直接将其整合进一个jvm的东西，于是，不但跨平台而且跨网络，，还跨OS，， 所以跨网络，就是统一协议，没有用户级的消息协议， 


发行模式与组件技术为什么这样重要？企业级的开发与集成强烈用到组件和分布组件


分布与跨越互联网的分布后者必定涉及到tcpip,lpc成为rpc不应从传输对象和方法这个粒度开始否则会进入idl的俗套，只应从进程级开始
所以，跨越互联网的分布，必定要深入到分布式组件级。

分布式解决了（进程），那么如何发布呢，如果不是为这个发布单元移植整个运行时到远端作为runner，那么必须在二进制级进行，这就是组件，分布式组件的由来。

 

跨平台，与跨网络程序corba


------------- C#与clr

JAVA,C#,是一种综合了编译跟解释的合体,这得益于它的虚拟机有一个动态发布的技术，它们没有组件，一切都是class，源码组织和发布统一，库即应用，所以，可以动态加载并执行。即class既是语言上的最小编译单位又是可运行的最小组件单位。

*/