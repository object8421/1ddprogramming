/*!

\page C# and Ironpy.html

============= C# and Ironpy

------------- as 编译与解释的混合

解释其实是vm的调用过程，可能是compiler backend + os runtime支持下的执行过程。也可能是纯粹软件上的调用jit来完成的。

JIT编译器在运行时，注意这个说法，编译器在运行时，编译器已经成为了VM运行时中的一员，而不再是传统先编译再执行的那一套前后分开，相续的过程。jit是常态吗，对，它是这个技术过程的主要负责体。比如，使用了泛型接口，导致Mono需要JIT编译

由于不允许动态生成代码，不允许使用System.Reflection.Emit，不允许动态创建类型。由于不允许使用System.Reflection.Emit，无法使用DLR及基于DLR的任何语言。不要混淆了Reflection.Emit和反射，所有反射的API均可用

当然，由于VM整合了编译器和vm，，所以它既可以用传统的做法也可以用JIT来支持特定的范式，比如范型，动态类型生成。jit甚至是一种范型的根本基础建设类的东西。不再仅是语言的编译器特色。仅停在这个意义上。

---------------------------------------------

native上的脚本语言与虚拟机上的脚本语言真的有区别吗？比如，ironpy与cpython有何本质区别？只是接口和类库的完善度不同而已吗，前者有偏重平台而发展成为一个CLR的.netvm(平台承载一切，应用即库，大部分平台逻辑在ironpy端，是C#写就的CLR逻辑)， 后者偏重语言（平台不承载一切，大部分平台逻辑在它宿主的os和os runtime作为对OS的补充上，是C的逻辑）。 正如它们python前面的名缀所示的那样。 

clr平台上，C#和ironpy之类的语言都是必要的，c#是clr extending system programming language,而ironpy是programmer applicatable(具体编程者适用的语言)language

C#并非domain programming的好语言，而.net vm和languages based on .netvm是面向domain programming的 

其实，C#这样的语言是作系统编程(对.netvm)的技术来解决向clr提提供可用的开发组件的，，它是用来取代.net assembly language的，因为assembly太低级了， 

虽然net languages一开始就是面向domain programming的，dotnet平台上的domain programming语言绝不是c#，它只是clr的system extending language。net上的domain language有ironpy等 

java,dotnet是general programming(that exsits non natively),不仅是for web programming

其实，dotnet,java并不是使一切变得更复杂，而反而正是使一切变得更简单，并力求将开发的一切集成到一个体系和生态中，如果它让你感到突匆，是因为业界没能提供一套可良好过渡的方案，以致你没能了解它的简单性和统一性而已

dotnet,java make programming avaliable to the non platform user

------------- 不要迷恋C++的强大，要正确看待.net C#和java的集成方案

C类语言和本地编程带来的影响是巨大的，这是因为它们是开发平台和应用平台结合的典范，这样的平台组合可以列表如下： 

1，汇编时代的汇编语言和硬件平台； 

2，系统编程时代的C语言和OS平台； 

3，桌面编程时代的C++语言和桌面应用环境； 

4，WEB编程时代的java,net类语言和分布式环境； 

任何人都可以很清晰地记得，何时C取代了汇编，又何时C++取代了C，诚然，“取代”这样的字眼用在严格的此类语言比较评论中是极不合适的，这是因为： 

1，虽然只有4才是这个时代的主流。但1-3还存在，也并不是隐匿不现； 

2，系统开发无外乎IO,shedule,task，桌面开发无外乎sql db,graphic ui,net，系统开发，桌面应用开发的开发语言无外乎C，C++类语言及它们的标准库，开发范式无外乎OO及高级OO技术，所有这些在windows,linux,及大量第三方厂商提供的支持中已表现得淋漓尽致。 

3，于是我们只能说，“java.net并不是已取代C，C++”，而是“系统开发和桌面开发已趋于稳定”，“现今的开发焦点和应用焦点并不在系统领域和桌面领域”； 

明白了这些，为什么还不能作出一些关乎语言选择的决定呢？ 

让我来帮你总结一下吧： 

1，现今是WEB开发时代，这基本带来了二大改变，你需要同时“整合了标准库的语言”和“整合了标准库和语言的统一平台”(这二者实际上等同于分布式平台)，而这正是.net,java的解决方案所包括的：它们都具备整合的语言和平台； 

2，对于一个新手和入门者，系统编程和桌面开发未免太复杂，细节太多，在没有太多精力和领悟力投入的前提下，要熟悉这个领域是比较难的，而.net C#,java类语言和clr,jvm类平台，如上所说，是整合了的，什么是“整合了的”呢？因为这是工业的需要，.net C#,java它们给自身的定位是“工业化了的语言”------ 工业化的语言，必然要求大量人的协作，这就让语言屈从平台（任何人不必一会工作在windows上，一会又工作在linux上），而且.net C#,java 的语法是标准的OO，任何人都共享一套语言，和简化了的标准库（不信，去查java 类库和msdn .net类库，所有开发所需的一切都在那里），因为只有这样，才能让作为编程工业的编程成为“工业”，这样做的好处是，对于编程入门者，它们的门槛变得低多了，初学者不必到处去找资料了，所有一切，只需去认识一套标准（虽然这个标准很大，但至少比较C++和桌面开发来说，它们统一多了）。桌面开发时代出现了大量个人英雄式的程序员，但在WEB时代，任何人都是开发的平民，因为每个人的工作都将作为工程的一部分。 


3.net clr原来还是为了取代vb，，促成开发层加实现层之间的一个中间层，，，为了简化开发的，就是我说的，拉大系统实现与应用开发的界限，增加一层抽象，而这是linux系的最大软肋。它假设开发的架构是这样的，从c开始说吧，c是系统实现,cpp是桌面开发和实现，而c#是基于系统实现和桌面实现的桌面应用开发(基于前二者的封装成果)。---------------------------编程强调抽象。。。而软件不强调抽象，换言之这样做是为了缩小编程与软件产品的之间的沟壑


于是，，，软件设计变成了组件设计，变成了内容生成工具，这跟ps采用图层的作法是一样的，图象生成采用图层，软件生成就采用可视组件。。软件开发过程就变成了可视的，而且是可视的内容生成，普通人也可接手，当然，最下面依然是复杂的原始cpp语法加库。

将开发基于抽象的那方面，，，与软件应用(软件开发是一种特殊的软件应用)基于可视的那方面，，将这二者分开，正是windows系的作风，不像linux，，，很原始很粗糙，以为开发完成了，应用只需很浅的一层便可达成，，比如它的开发大都纯粹基于api，发布基于lib依赖的包管理，，而windows比它们走得更远。

将开发(软件开发用于作软件实现，需要向更高层开发隐藏掉其实现的开发)基于抽象的那方面

 将编程分离为原始cpp编程和基于可视组件的再开发，前者面向实现，后者面向用户开发，这种面向用户开发曾一度是基于封装cpp库的scripting脚本编程的领域，现在用可视化的组件组合开发去取代它，，，这是很好的作风。内容生成取代了脚本书写。。开发的痕迹最大化地被隐藏了



4，工业化决定了未来的应用方向，云计算正风起云涌，它强调将应用搬上WEB（注意：这个WEB绝不是狭隘的网站应用），.net C#,java类语言是这类应用唯一，唯二的方案，如果要跟上开发上的时代性，一个程序员还是要选择这类语言的好。 

一句话，net C#才代表了最复杂最整合化的方案。它才是最强大的，我们根本不需要迷恋C++的方式。

*/