/*!

\page C++的UDT语法语义系统.html

============= C++的UDT语法语义系统

CPP的类型系统是从C继承的(所以是POD的，再加上**它的OO，是建立在POD上面的，属于集成在语言级的库级的OO**，比如它的构造函数，成员函数，等，都是c语言+oop lib形成的新CPP的东西)，它的template只是类型推导系统，本身并没有给CPP带来任何类型上的东西。它与OOP LIB一样，更好地在库级工作，而不是强调给语言本身带来太多的东西。这是与CPP之父倡导的用库来思考是统一的。

---以C的类型系统和代码系统为核心，再加上自己的ooaood系统的，其实都可以称为CPP，比如业界CPP是CPP，D语言是CPP，qtcpp也是一种cpp,objc也是

OOP不但指OO，还指OO下的idioms，比如STL中的functor适配器，iter迭代器，boost中的singal访问者器,sington单件,,,cpp强大的抽象能力（较之C的指针CPP本身固有的OO）在STL的技法中始体现出来，就是迭代器，容器这样的概念






前面我不断谈到语言其实是与平台或虚拟机RUNTIME一起来完成编程的。要集成包括语法，运行期支持，组件，库，的一系列因素，，而且，新发明的语言语法，当语言机制本身选择得足够正交时，它可以在设计期直接支持一系列DP。

用get.set（）代替语言级的objects成员存取，以代替传统OO的成员保护，进行运行期成员存取，好吗

qt根本不需要CPP的RTTI，它有自己的metaobjsystem

c#全部都是精简的OO，比如代理，get().,,,set()，，，，用这些作为OOP的核心，，泛化出基于其上的clr和designing patterns,,,

c p p的多范型好是好，，可是它没有一个同qt一样可以泛发个多种其它范型的oo核心，，它支持的泛型主要针对静态期，，动态期根本就不强大

传统的cpp，太dirty，太学术化了，qtcpp才好，简装核心objectsystem，，连stdlibs都是oop的

意识到现行的CPP，CPP库，不是良好的教育用品，，与bcxszy topconcepts部分要求一一对应的条件差了去了，，唯qtcpp满足，自己不可能有那么多精力去发明一个了，所以直接选择了qtcpp


------------- cpp's udt

C++的UDT语义这部分[1. C++的UDT语法语义系统,这也是《inside c++ object model》那本书要解决的全部问题]可以跟讲解C++的模板语法语义时进行整合.

>>编译器理论主要是前端，后端，就是各种具体语言语法语义的支持,,inside cpp object model实际上是一本由讲解编译器语义实现(cpp runtime)，到CPP高级语法的书(theinsideofobject,,and aboves)

在C++的重载多态中（它们被用于实现C++方式的OO），处理名字的作用域，也是利用了跟编译器维护一张名字表一样的方式来的，只不过它是在库层的

C++的RTTI中的I是identifier,识别符,的意思,而一般把它称为information. Rtti是一种机制,是由C++的发明者提出来的,可由编译器,库,或用户应用来实现,一般这此都实现了它的一个子集.

要把RTTI跟动态联编区别来来.这二者都可用来实现多态,一般用支持动态联编(这个编是编译期就确定了的)来实现多态,RTTI实现多态一般用在比较受限的情况下(比如在不能获得基类的源码时,此时你不能修改它,因为你只有头文件,这时你就可以自基类派生一个类,并将指向这个类的一个指针向下转型为你的一个派生类,比如它还支持异常,持久等,但C++因为RTTI和异常,付出了复杂性和性能和代价,一般的编译器是关闭RTTI的),但假如,你得借助 rtti中的dynamic_cast()实现多态,那么多半是你的设计不力.

一般的C++代码,在通过编译后进入执行前,是将类型信息(RTTI中的I也是标识符的意思,我们知道,编译器的书写中,各种语法单元是有一个ID的)这些语义抛弃了的,而**一般解释语言系统,是将编译器和运行单元整合的,故语言系统在运行期也维持相当多的语义.而编译语言系统,它的后端只是一个向OS的接口 – runtime**,语言系统并不维护运行期的东西,故它的语义全部维护在编译期,而RTTI就是对此类语言,比如C++,的一种突破.因为RTTI的意思是:动态运行期获得类型信息typeid().

不要把动态联编跟RTTI混淆,

>动态联编即C++ UDT系统的虚拟函数分流机制,某个带有虚拟函数成员的基类,或继承自某个带有虚拟函数成员的基类的类(下面一律称为带有虚拟成员的类),它们的成员在连接时会不会产生一个“未决议”的错误,这是由动态联编来保证的,它呈现给程序员“通过基类指针访问特定对象”的多态效果(而多态是C++ OO的精髓),动态联编在编译器底层解决这个问题的手段是给每个带有虚拟成员的类维护(在construct里)一张vtable,在这些table里维护指向基类的指针,指向派生类的指针,指向各种成员函数的指针.它的所有一切都发生在编译期,在程序运行时就已经完成.如上所讲,依靠的是表和指针. 而RTTI,是靠类型,而且是在运行时动态决定的,

也不要把动态联编里的分流机制跟this指针这样的东西弄混.

>动态联编着重描述的是由表和指针驱动的一种“继承和多态”体系,它只是在源码层定义了这样一个“继承和多态”体系,而实际的展现,则是由this指针来实现的,在客户代码中,在对一个成员函数的调用中,隐式使用了一个this指针,来帮助获得多态所指向的那个实际对象.

------------- 构造函数



构造函数不会常常被声明为virtual,,,因为子类不一定非要实现它自己的构造函数(而往往在它的基类中就有过实现) 基本类型数值是没有构造函数的,而Java中对于数值类型的封装形式就有构造函数,这是它们二者本质的不同,像C++中用new动态声明一个对象,它一定用到了这个对象所属类的某个构造函数,可以说C与C++对待程序的“数据”的最大区别就是C++对他们统一看作为对象ADT(于是连简单类型都套上个构造函数),而C没用到(因此C压根不需要构造函数来着)

仿函数
-------------

仿函数是C++基于对象编程的典型,,,它把对象class化{也可能是template class化},使之具有copy ctor可被复制,再给它提供一个重载的小括号这样在语法上就可以跟普通函数一样写了,整个过程并不需要面向运行期(面向对象),,,所谓模板加基于对象的基于对象之说只适合发生于编译期.

STL中为什么需要仿函数呢?它为了成为算法的某种策略,,loki中的仿函数用来实现一种command的设计模式,因为仿函数可以用来封装一系列请求；

------------- 句柄


compare to pure ptr,smart pointer which exactly describle ownership semantics
数据数据，代码数据(ptr,handle,callback)，其实，都是类型

句柄一般有三种意思 1,Window的资源句柄比如文件,,操作系统普通把文件作为硬盘上的东西,,可是文件在语言的观点里根本就不是这么一回事,,,文件只是data flow,,或者一个file map(也即在内存中作引象),,,, 2,包装被指对象为其值的智能指针 3,形如type**的双层指针 4,其实通用意义上的Handle就是句柄的意思,句柄还有一种用处出现在编译原理中 5,如下如果B是A的一个子类,,,有如下代码 (A)new B 那么以上可以理解为,,,上面产生了一个对象,,这个对象指向B(指针),,,但是其句柄为A 即a handle of A pointing to a B, 也即第四种指针是用父类来操作其子类对象的一种机制 C++中的句柄类也即作为对象的指针智能指针是一个类,,,,可以由它派生对象在支持OO的编译的眼里,,,行为和数据集就是对象,,,可是对象代表的意义可以千差万别,,,这个对象可以是一个指针型的,,也可以是一个INT型的,,在这个意义上(注意这几个字,在某种意义上),,对象可以是任意类型,当然指针意义的对象也就是指针对象了上面说到的某种意义,就是某种角度,,,更专业的术语叫做某种维度,,,,维度是一种意义,,,比如三维空间,,,那么如果三维空间中的三维表时间,,,那么我再提出一个维表时间,,那么它就是一个四维(而不能说是四维空间因为这四种意义不全是作为空间的意义) 第一种说到的抽象,,,我们在进行抽象时,,,,只能得到一个维度的抽象(我们在进行设计时往往抽取一个维度就立马写代码),,,或称抽象集的一个维度,,,再如实现与逻辑分离,,这只能是一个具体维度上的可达性,,我们不能保证复用在任何方面都可以做到更好.. 智能指针也带有指针的意思,虽然它是一个对象,因为这个对象提供了-&gt;这样的类似一般指针的重载操作符,因此它在形式上下班模拟了一般指针,而且,更重要的,,这是一个智能指针这是因为一般指针只是指示器,当它指向的实体发生变化时,这个指针并不发生变化,甚至可以独立于变体发生改变(也就是对指针的重新赋值) 一句话,一般指针仅仅是作为地址意义存在的这就是所谓的左值而智能指针有值的意义,,,它维护着它所指对象的一切并把它当值value右值,当对象本身发生改变时,智能指针能够自行适应这种改革者变,而且能够自行维护这个对象的销毁等操作为编译期动态产生类的方法称为策略,,,动态期的称为RTTI

------------- C++的RTTI


RTTI是一种语言服务(比如它支持typeof和运行期类型转换).它是C++这样的静态语言提供给编程在针对程序已被运行时能用到的语言机制. 比如针对运行时如何获取名字的类型信息以达到某种编程需要(而类型信息,往往在编译完成后就被编译器抛弃了.运行期并不再存在) 这首先要说说类型转换类型转换是程序设计语言中实现多态一个很重要的因素(经常需要在一个基类对象指针和一个派生类对象指针之间Cast,,或者cast 成void),在first class cast应该是RTTI的内容,为什么需要rtti呢?因为我们需要对对象在内存中的形式进行控制(比如JAVA提供的反射对DB4O的设计就有帮助,因为DB4O需要它控控制对象的引用并存入数据库),, 有同一个基类的对象之间可以相互cast, 转型提供了多态 50页下面(1,2二句用于创建一个Tobject的子类对象,等价于用子类名.creat) try 1 aObj := TObject(TBase.NewInstance); 2 aBObj := TBase(aObj.Creat); 第1句分二步括号内是一部分,作用是 Tbase.NewInstance等价于TObject.Newinstance,由于Tbase 未改写它的父类的NewInstance(这个函数调用initinstance ,与其它一些函数构造VCL创建对象服务的模型)这步过后,内存中已有TObject,, 第1句括号外aObj :=TObject,作用是把“把创建的TBase 对象的类型转化为一个指向TObject的指针aObj” (作者原话), 这意味着,在第一句前半括号内的内容过后Tbase对象也同时被创建了, 在内存中成形了(但是还没有达到像子类名.creat这种形一样完全成功地创建一个对象的效果),只是括号外的内容过后,aObj,aBObj这二个对象变量指针所指的内存范围不一样而已,由于被定义为Tobject,aobj指向图中实线体开始,而... TObject 如何理解呢??这个过程可硬性总结为, 第一句括号部分下来,实际上只创建了一个tbase在内存中的模型而没有创建tobject的模型,毕竟没有显式地或独立地创建tobject在内存中的模型,它只是随tbase的创建而被创建了,而且即使被创建,它也不是独立存在的而是作为tbase的一部分的, 即tbase的内存模型中包含tobject的内存模型(因为tbase是由tobject派生而来的,它的内存模式比tobject通常要大,你可以形象内存中,tbase包含tobject,tobject在tbase的上面,就像书中示意的那样 ,这里我觉得tbase取名为tcommon更好),因此在说法上,我们说tobject说被创建了,当然你也可以说tbase范围的上面部分不是tobjct, 但是它确实符合tobject的内存模式,在道理上我们也可以说它是tobject,并拿它加以讨论^^ 括号外过后,把刚创建的tbase转化为一个tobject,这样它的内存模式就缩小了,要注意aobj是始终指向tbase的(因为tobject实际不存在,只是说法上说它存在于tbase的上面),,更准确地说指向tbase的全部部分还是它包含的那块tobject部分(道理上,我们也可以说tobject存在) 实际上到底有没创建呢??这是一个哲学问题,不由我们来回答,,思考的角度不同,你可以说它存在,或者不存在记住下面二句后面的就好理解了 tbase.newinstance这种语句格式永远是指.newinstance前面的那个tbase在进行newstance操作 aobj:=tobject() 这种语句格式永远是指 aobj指向括号内的那个aobj所指的Tbase(******) 为什么这二者可以相互赋值呢?tobject和tbase是兼容的,因此可以相互赋值,,,只是经过上面第一句括号外的赋值过后,aobj所指的范围就变成了tbase内的tobject部分,相对于tbase的全部来说,这是缩小了,缩小或扩大的本质就是执行框架的变小或变大,即指向的内存模式的范围大小,第二句过后,根本我上面打星号的那句话,aobj指向的tbase(别忘拉) 在完成creat的工作后变成了赋给aBobj(兼容的指针嘛),即abobj指向tbase的完整部分的开头,, 因此,aobj的执行框架在第一句后指向tbase内的tobject部分(经过第二句后无变化,除非aBObj := TBase(aObj);这表示把aboj类型转化为 tbase,,这样aobj就变得跟abobj一样,所指向范围一样),而第二句后仅仅改变了abobj,使abobj指向tbase的全部部分的开头,即aobj和abobj的执行框架比起来,前者要小现在来分析53未的例子, 001,aobj指向tbutton内上面的tcompent部分 002....... 003,aobj经过转化成为abotton,,,指向tbotton完整部分的开头,,,因此aobj相对001来说,执行范围就变大了

------------- C++多继承的二义性


###### 多继承与虚拟继承

###### 动态多型


###### 虚拟继承

*/