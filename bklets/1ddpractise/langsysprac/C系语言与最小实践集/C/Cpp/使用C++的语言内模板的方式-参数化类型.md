/*!

\page 使用C++的语言内模板的方式 : 参数化类型.html

============= 使用C++的语言内模板的方式 : 参数化类型


我们这里讲解的是C++的语言内的advanced oo技术。当然.将设计做到语言内的,还有Python的descorator和generator等.

模板技术就是把原来编译器用的东西（用来构建语言语法树）的东西下放到程序员供他们使用（直接用语法树来写应用），从而可以直接在语法树上写程序，而且无需后端便可以在OS上运行。可以看出，当使用template写程序作设计的时候（**大部分时候，我们使用template写设计**，混合cpp原来的那套POD+RTTI OO类型系统写实现，形成一种欠套了的混合语言）我们其实是在发明语言，供越来越面向Domainspefied的逻辑使用。






------------- 实例化

首先我们要弄懂实例化,它本质上是一种编译器技术.它对我们编程带来的功能就是: 编译期参数化推导.参数推导给C++带来强大语言能力的机制(泛编程和元编程),也给我们带来了不小的学习曲线. 这节先讲实例化,下一节将着重谈参数推导. 什么是实例化呢?注意这个字眼　　在OO程序设计中,由一个class定义一个对象并不实际动态分配内存,因为这还是指为运行期作规划的设计期并没有实际进入到运行期并分配了一个内存, 如果用了new关键字,还是没有分配内存(因为是在写源程序的时机没有运行),编译期永远不实际分配内存而只是在作某种分配计划,只是按照源程序所写为程序将来在运行期如何获得内存作分配上的控制而已,,这是一种针对运行期的实例化. 可是编译器不光是指运行时,还指编译器前端的转换,实例化并不一定指为运行期实际实例化(也就是说实例化并不一定就是一种“为运行而作设计”的写源程序动作,,它还可以是一种“为设计期而作设计”的写作动作,)它其实就是一种编译期的宏,只不过它有类型的判断,因此远远不是简单的文字替换性质的宏,,而是一种编译技术,模板由于有这个特性,第一,因为它是泛型,所以为C++带来泛型编程机制,第二,因为模板编译技术的图灵完备,它使C++编译器也有解释能力(只能解释那些在不使用到运行时,等运行期设施时),这也就是说,它有运行能力,这给模板给C++带来元编译技术. 这种实例化就是针对编译器本身的实例化. 所以说,实例化是多义的,针对运行时和编译器前端的实例化,只不过一个实例化用了不同的情景而已

>什么是元呢?元就是大一,古人常常把世界归为,金木水火土,企图用这些东西作为其它一切事物的“原型,元素”来描述其它事物,比如它们说“水主..金主XX”,所以,元,就是描述其它东西的那个上上层原型.

即我们通常的编程[1. 这里的编程是狭义的,写源程序]是面向运行期的,而不是面向程序如何被编译的(编译器),这就是说,我们编制的程序只会运行,编译器只管转换的事.那么如果现在我们想将设计推早到针对编译转换发生的时候呢,即如果对转换动作也在源程序级作控制呢?这在C++中同样存在,这种控制编译的手段之一便是:预处理,编译器宏设施(稍后会谈到模板的实例化也可以达到这样一种效果).

>让我们回顾一下编译原理,编译,运行,前端,后端诸如此类的概念,我们知道高级语言的过程,词法分析和语法分析构成了编译器的前端(得出一个抽象语法树),然后是语义分析,然后是中间码或目标码生成(如果有一个虚拟机,比如JVM和JAVA语言,那么这个目标码就是JVM中解释器要执行的目标, 如果是裸机器本身,那么就是一种接近二进制但不是最终二进制的表示形式,当然一般在生成最终目标码之前要先生成中间码),然后是对生成的目标码进行优化, 优化之后进行汇编形成真正的二进制. 但其实编译非运行,我们知道运行期才能申请到系统资源,才能进行计算机的所谓运算, 其实对编译期和运行期的误解一切的罪原是解释语言跟编译语言的区别(如果没有编译后端,那么运行期的目标就是中间代码即源程序初步变换了的形式而不是目标平台的程序),我们知道,在编译前端完全之后,代码就被生成了,对于解释器来说,编译后端是不必需的,此时它就是逻辑上可运行的一个整体..即设计逻辑 = 编译结果 = 最终运行逻辑..只有等编译后端是为具体平台生成代码时,,这个时间才出现第二个运行期,,要打乱设计逻辑,将语法级的编译时的设计逻辑转化为变相的平台逻辑,运行时就可以申请到系统资源了..(因为类似C++编译器它的编译部分和运行部分是他大爷的分开的),,这才是运行时的标准定义.. 而模板绝非为后一个运行期而存在,它在中间代码层次上就可以工作了,因此模板中可以不需要分配变量这些运行资源[2. 只要typedef,提供编译符号给它就可以,当然,写模板逻辑时也可以面向运行期分配变量定义实例,前者导致元编程,后者导致普通运行期的模板编程即泛型编程],它可以只是关于类型的纯语法逻辑 (这就是利用了模板的元编程,注意,要把模板实例化技术跟元编程范式分开).因此类型也可以仅仅是一个语法占位符(很难想象类型占位符也能参与运算吧). 就跟宏一样..在写模板时并不产生代码,只有模板逻辑被实际调用时才被生成代码(即编译实例化时,类型将不再是一个占位符,而是获得指明的一个具体类型, 可以进入编译了)..

看过Bjarne Stroustrup的C++简史的人都知道,模板最初是用来设计为取代宏(预编译,条件编译,#define等)的(后来才慢慢转变原来的设计初衷,把它发展为一种独立的语言机制),这说明它的地位是靠近于编译期写代码时的设计过程的,(虽然它也一直参加编译以及后来的代码生成,这就是它跟宏开始发生不一样的地方,但对于源码书写的地位,是不变的,用它们写的东西,在最终完成源程序开始运行之前,都要由编译器完成转换到运行期语法语义的动作).而且模板也是类型严格的所以也是语法的一部分,既然是语法,就是语言的一部分(而宏函数虽然被冠于函数之名,但其实他不是语句也不是函数,根本不参于编译)..

>>template meteprogramming,prepressor metaprogramming

>可是,我们只充分利用了转换过后的那些平台的运行能力,而没有充分利用编译器本身的转换能力.唯一例外的,只有上面说到的编译期宏(此时程序未进入运行) 注意,你写模板源程序的时候你其实是针对编译写的,你还不能确定你的源程序哪部分会进入编译器(比面向运行写源程序是更高的层次,面向运行写的源程序肯定只会进入运行期) 然而如果我们对编译期编程(静态编译期),这将发展出一种元编程的技术.(利用模板实例化机制于编译期执行一些计算.这种通过模板实例化而执行的编译期计算技术即被称为实例化,它至少可以导致C++的泛编程与元编程能力.) 什么是模板会产生代码呢,这个说法其实无比简单,这就是实例化,只是当我们摆出诸如“为设计而设计代码”,“编译期而非运行期多型””C++的元编程技术”这样的别称时,它就变得远离我们的理解变得面目生疏了, 一种实例化是利用了模板的产生式编程范式(比如泛型编程),一种实例化是利用了模板产生式,但面向编译器的元编程范式.产生跟元是不是一样的.

我们在这里先提简单的模板技术,仅给大家一个初步引象,在后面参数推导部分,会把高级的模板技术一步步导出来. 模板实例化是生成采用特定模板参数组合的具体类或函数(实例).例如,编译器生成一个采用 Array 的类,另外生成一个采用 Array 的类.通过用模板参数替换模板类定义中的模板参数,可以定义这些新的类.当然它跟模板特例化不一样,具体的模板技术细节请去参考其它书再说一下C++中的模板技术,一般用typedef来实现模板中的假变量定义-因为模板中不能直接定义全局变量(以下提供的例子是一个数据结构模板) template struct TypeList

{ typedef T Head; typedef U Tail; }; 显然,TypeList没有任何状态,也未定义任何操作,其作用只在于携带类型信息,它并未打算被实例化,因此,对于TypeList的任何处理都必然发生于编译期而非运行期模板是一种参数化的泛型,泛型这二个字决定了模板没有一个类型(在写模板函数,或模板类时的设计期,能难想象没有类型的空东西能够堂里皇堂的参加运算吧^- ^,只有编译器技术到家就可以),,在写出这个函数模板或类模板后经编译时它并不产生代码(机器动作时),只有在接下来实例化时(注意,这个实例化是指在设计期用户动作期,用户为这个泛型占位符指定一个具体类型并写出关于它的代码,这个实例化跟我们在OO程序设计中,由一个class定义一个对象类似,接下来,在编译期机器动作时才会在编译期实例化产生实际代码到中间目标文件中比如obj中(非飞行模式) 这样仅仅是一个软件内部的考虑,如果不在源程序的级别,你要提供你的软件为别人所用,或者是一个类或者是函数,你不可能向别人提供源程序,你就要在二进制级别上向别人提供面向对象的特性(即可复用特性),,OO的可复用能力正是体现在二进制级别.而template是源程序级别.因为它的定型在代码刚被编译时.

>承接我上面一篇文章《为设计产生代码》让我们来总结一下模板,是在编译期靠近编译前端那一部分对类型进行控制和抽象的语言机制[3. 即部分地在语法层次上直接写程序,针对编译时的实例化写程序不需等到运行期才检验结果,而且更不必专门针对运行期语意和运行期语言机制设施写程序. 比如C++运行期OO的多态],是C++建立在它的类型机制(特别是class通用类型)上的语法机制(所以不光有函数模板,结构模板,还有类模板),在这个语法机制上.C++可以做很多强大的事情(特别是设计上的,集中体现为泛型编程与元编程),,运用这种编译期的能力我们可以将C++视为另外一种语言.即编译期以模板为脚本机制的语言(而模板是主要针对处理类型的).. 如果实例化不是为运行进行设计,,而是为了为设计期产生代码这样的目的而进行的设计期的设计(很显然,它本身也是一种设计,并不面向运行实例化,这是一种静态实例化,编译期的实例化,即它向前推进了一个意义层次),而且当模板机制的编译技术实现涉及到词法处理,语法分析这样的编译原理知识时,,,那么模板就是一种地道的编译器的编译器了,是一种元编程技术.


------------- 参数推导


一个新的问题:类模板可以被继承吗?答案居然是不可以,跟直觉相背让我们把模板的头部和体部分,分别对待来看,以澄清我们对模板的一些认识. 这是因为:模板的意义不在于对模板本身意义的使用(你无法继承仅是一个不确定的叫模板的东西,因为作为源码中定义的模板此时不是类,也不是类型,它是某一族类或某一堆重载函数,它的某一个实例才是,然而,实例是obj,不可能从源码中去继承,在源码中并不可见,你能见到的,只是一个泛体),而在于对它的被实例化的过程的控制(而导致的语法语义,比如特化之类的,显式具现化,参数推导,而这些,才是学习模板的重点和主体意义所在)

>实例化和特化的区别与联系: 实例化和特化都是针对模板定义来说的. 准确的说法是:实例化由客户端对模板定义的使用而引起. 对实参的组合进行实例化一次模板,这是第一个过程(此时会产生很多实例化因为形参是泛化的,具体各个实参的组合可能有多种,在编译层中),在 include实例化模式中,程序会选择这些实例(注意这些)中的一个作为最终的实例.这是第二个过程(此时是连接层). 特化与具现体的区别与联系在哪里呢?特化体的具现体,或具现体的特化体显式实例化是指定的,一个对编译器的动作.而显式特化是对程序的一个控制. 特化分为偏特化,全特化(也称为显式特化) 特化版本,是关于模板的一个特化版本,,其结果和目标是一个模板,它不是模板参数的缺省值(它只影响实例化效果,而前者产生一个模板,不是一个实例).

实例化的本质,即编译期运算(一般来说,编译期运算仅指元编程,编译期替换,指实例化),即在调用点,得出一个“普通的函数实例”,然后,其它的事就跟一般函数无异了.

**模板技术的重点与难点,都在于“在编译期确立一套类型推导的机制”** 所以模板要求程序员保证,在这个推导过程中,总能存在确定的实参,使得模板体成立,编译时总能得到实例化并通过编译.这就是模板的坏处****

技术的重点与难点,都在于“在编译期确立一套类型推导的机制”,(**自动推导是编译器智能实例化的方式**,当然,你也可指定显式实例化,来指导这个推导过程) 当然,这个类型推导的意思是什么呢?

它只是一种关于替换的松散表征,因此,stack和stack,如果这二个stack模板体都是一样的,那么当以stack和 stack分别调用这二个模板时,产生的二个模板实例实际上就是等价的.因为模板头部分,只是一种关于替换的松散表征,起决定作用的,是模板体,和调用时的用于替换的实参.这里的替换,就是为TP1,TP2,和TP求值,此时,TP1=TP2=TP=int,注意,这里说的并非自动型别转换.而是替换.并决定这些TP1,TP2,TP是什么的意义.

模板要求程序员保证,在这个推导过程中,总能存在确定的实参,使得模板体成立,编译时总能得到实例化并通过编译.(随着后来的学习,你会知道,这叫concept的相容性)

而参数推导和实例化的关系是一种什么样的关系呢?参推,实例化,这二个过程是统一的吗?是同一个过程吗?看到一个模板的定义(而且此时没有看到调用),此时编译器到底做了什么动作,假如此时不考虑它是不是调用过?未来将被调用,或正在被调用.

参数推导在前,然后才是替换被实例化,然而,参推依赖定义的正确性,这定义的正确性,又保证了实例化正确性,

一般来说,因为模板语法语义的特殊性(编译期要给“替换”用的占位符指定一个具体类型),它至少在以下方面给C++的编译器制造(模板要跟现存的C++语法语义设施协同工作)造成了麻烦,对这些方面的澄清工作,可以保证我们从一个很好的唯度去认清C++模板的参数推导.

首先,在模板定义内,存在很多跟非模板的语言设施定义不一样的地方,比如类模板可以跟它的成员,同样是模板的函数,组合变换出一对对泛型组合 – 我们称它们为实体entity (并以这些组合作为单位进行被调用,实际上,类模板的参数,就是成员函数的参数),对类模板里这些成员的访问也就变得很微妙.如果类模板里某个模板函数最终未被引用过,它根本不参与实例化,对类模板的实例化,是以类模板的全体和那些被指定引用过的成员为单位实例化的,不是以类体中的所有各个实体为单位的 (虽然它被类模板修饰qualified),故,那些不参与实例化的实体,会被跟参与实例化的实体分别对待,即编译器可能对它们仅进行一些初步的词法检查,而不是跟实参有关的全程语义分析(不是不能,而是根本没有实参跟他结合),所以,即使用(那些被调用过) 的其它成员函数实例的实参,来填充这个没被调用过的实体,而且在这个成员实体entity里的定义有产生语义上的不符的地方,也不要紧,因为它最终不可能被调用.编译还是能通过.

源码级,模板之间的相互引用,即,相互调用,对模板的定义指定某个可能的实例,在一个源码文件中,可以用不同的实参引用不同的模板形成不同的实例情形,而这些实例情形可能跟其它的模板产生欠套的更复杂的实例情况,此时,处理名字空间,实例化时产生复杂的obj对象,编译器就要复杂,该怎么样去除那些重复了的,或者不可达,找不到的实例.

程序的逻辑单位间,比如支持C++的分离编译机制.

以上三方面,如果你能从编译器实现的角度去考虑清它们,那么,实际上,你就掌握了模板技术的核心,你学习模板才算到了家,我们先来说函数模板

>函数模板提供了一种机制 通过它我们可以保留函数定义和函数调用的语义 在一个程序位置上封装了一段代码 确保在函数调用之前实参只被计算一次 而无需像宏方案那样绕过C++的强类型检查而类模板可能要复杂一点,因为它有成员,而且成员又可以是模板,类中的每个“实体”,与这个模板类本身,当然,类模板的参数,就是成员函数的参数,这二种因素的共同作用下,产生经过修饰qualified的“类模板实例”

对于在模板体出现的各种名字,当它跟传递过去的实参有关系时,重点在于“实参依赖的类型相依并推导的语义”

形参结合时类型不是确定的一对一吗?又为什么来个“引数推导”??而且还有类型之间的转化与退化现象,这是因为形参从来都不是一个真正确定的类型,而是一个关于类型的占位符,模板起作用的唯一地方,是它们的具现体被调用的时机,准确地说,是被替换,即substantice(此时,它们获得类型,变得可用),所以,模板在这个意义上跟其它的语言设施都不一样.因为模板的定义体似乎很虚.

就让我们来重点说下实例化先吧:

实例化,的结果是产生obj文件,这个经编译后,形成的二进制的结果文件中,存在一个具现体.这是具现化的直观意义所在(此时编译器只是完成了对它的编译, 而没有进行对这些具现体进行链接,实际上,在源程序中的一个模板体,会在同一个obj文件中存在多个重复的具现体.总而言之,要记住,它发生在链接前,而且它具有不确定性,可能会造成代码膨胀).可是,这要求编译器和链接器用不同于编译普通函数或类的眼光来对待这些在源码中存在的模板体.因为这二套体系的逻辑本质是不一样的,前者是生成后者的一个模板,自然语义不一致,导致的编译和所需的链接技术也不一致[4. 普通非模板函数的编译和链接是独立的,编译时只要保证调用跟声明时的接口一致就可以了,而链接时也并不需要重新用到编译时的定义(因为被编译后,它的定义就已经到obj中了),而模板和模板函数打破了这个规则,连接和编译是相依的,连接时需要用到编译时的源程序.],如果是普通函数,虽然在定义出来被存在于源程序中的那一刻,它并不进入一个执行路径,但在C语言中,class的本质跟struct,unioin的本质一样,都是会生出新类型的那些用户类型,它们作为一个数据存在,而不是一段立刻会进入某个执行路径的代码(比如函数).

>最初引进模板技术及模板实例化技术的,自然是最早的C++语言的实现品 – cfront,它对模板的处理全部首先归纳到链接期(它不会首先正常编译带有模板的C文件,所以对模板的引用不会在编译时就出错,由于头文件可见,编译过程还是得以继续),如果在链接时发生找不到符号的错误(由于cfront编译时维持了一个仓库,它可以据此在链接报错后找到哪些是模板体没有被定义哪些是其它程序结构没有定义 – 要知道,对于模板,编译器必须在每一种情况下都把它与其它程序分别对待),那么它就会后退从源码中找寻模板声明及定义并编译.从而完成对模板的实例化.这要求程序员将一切模板声明写在.h文件中,对应的定义写在对应的C文件里,也就是说,它强制编译器使用分离编译模式.编译期并不管C文件(由于模板在这个 C文件中在编译期对编译器隐藏的),而只是h文件.带来的缺点就是编译时间过长,对某模板的每一种参数类型,都会导致重编译.任何对包含有模板声明的.h 文件进行的轻微更改,, (假设它稍后被某源文件或头文件引用,或在程序某处被多次使用需要进行编译),都会引起重编译.这是一种恶梦般的等待. 另外一种方案是borland的,它一开始并不像Cfront一样取巧,而是将所有对模板的处理同其它正常程序文件一样,首先归纳到正常的编译期, 每一个模板及定义,都统一写到.h文件里(而不是.cpp文件里),每一个引用到某模板的源文件,或头文件,都要#include那个定义有该模板的头文件(因为必须对那个模板在编译时就可见),这解决了一部分cfront的问题,而且很直观,但是产生的目标文件巨大.即使是很小的模板也是如此. 第三种方式是edg,它采取一种折中的办法,在编译时维持一个信息文件(由于要产生临时文件,所以这种步骤是平台依赖的).它第一次引用了export模板体的支持,所以对于export和非export的模板,它是分别对待的.



正是因为函数是立马进入执行路径的,而且,函数比起类来,它还要求需要有参数,比如函数模板被实例化了,它是不是就以“某个类型”作为参数了呢?不是的,只有函数才有参数,而类没有参数.模板形参,不可能出现在一个模板函数的参数中.

所以模板函数,比如部分偏序版的,跟特化版的类模板,函数的偏序与类的偏特化不一样.但很相似,函数偏序是重载,而类的偏特化是产生扩展版本.扩展版本是primary template的影子,而重载的函数模板相互之间是独立的.
所以,如果一个定义在源程序中的类,从来没被引用过,这就跟模板类定义过,却没被调用过一样.会跟它被调用时产生过产生的语义大不一样,所需的编译器动作根本不一样. 要明白这种“作为数据存在的代码”的真正意义所在.

因为模板定义和模板被同时在源文件中出现,所以它具有二个名字环境,一个是定义时的名字环境,一个是被调用处所在的环境.对于函数模板,更有声明.在被调用处,模板体内的名字用到一个叫adl,实参相依的查找的,名字解析机制.
在编译模板方面,不纯是模板的事,又受制于C++的整体分离编译模式,因为它是C++独有的源码逻辑单位,所以模板也要符合这种机制(现代的语言总要模块化吧,但不必像C++一样搞出一个头文件),这种努力的结果是使得模板编译又产生了一些新的问题.这又是怎么回事呢?因为模板类中的实体(比如member function),当它们被引用时,编译器不知道它是不是在二个不同的文件[5. 在内部不知道是不是一个处在不同的文件中,在外部也不知道是不是同一个模板体,如果是在内部,在同一个文件中产生关于对应于源码中的一个模板体在obj文件中的不同的多个具现体,那么问题并不存在.模板的默认的链接属性是基于C++的,即extern C++,而非extern c]中(此时,模板类中的实体被赋于不同的链接意义)都被实例化过(二种情况都可能会产生,由于不能预测这同时发生的二种不同情况,所以会产生矛盾,编译器不知如何将它们联系在一起),因为模板实际上是活动的,其在实例化时会根据不同的情况产生多个动态对象,比如,它由用户来在代码上指定,调用点,由程序员维护一个正确的”类型推导”[6. 这就是所谓的编译期类型推导,如果由程序来控制,就是runtime绑定了].而这,会产生很多种情况.而这些动态对象不能单独被考虑.需要作为一个整体最终最形成一份到exe体内,因为编译是死的,虽然在中间层次的obj中可以有多份.但最终的可执行文件中,只需一份.源程序只是“模板样本”.它不跟其它的语言设施一样,源程序版本跟编译时的目标存在逻辑上一对一的关系(C++作为静态语言,它的源程序级的一切东西,在编译时就被确定了,除了 runtime的绑定).

于是,为了对付这种“1多”和“多1”的情况,不同的编译器将编译模板和编译普通对象分开,比如,对于模板,cfront在编译器不对它采取任何动作,只是将其元信息保存到一个文件夹,然后在链接时(自然就会产生找不到关于模板实体的目标),找到那些对模板的引用,然后重新去源程序中找到它们,并编译,连接.而其它编译器可能就会采取不同的策略.

>显式特化,默认实参,显式模板实参,显式实例化,重载与偏序,这五者间的区别与联系是什么? 特化版本,是关于模板的一个特化版本,,其结果和目标是一个模板,它不是模板参数的缺省值(它只影响实例化效果,而前者产生一个模板,不是一个实例). 当然,关于模板技术,还有其它一些方面,比如1,默认参数,2,成员模板函数保证语法正确给了模板编译过程什么好处?对模板中与形实参相关的名字进行解析


------------- 模板与泛型编程



这对用语言来进行设计尤为有好处.因为他可以站在范类型的角度上进行脱离了运行考虑的编程(泛型,比如可以写出function type这样的语言结构,就跟纯虚函数一样,只是一个接口抽象.只不过,这是用类型集表达的抽象.即concept),
**泛型的好处在于:它以型的前提“泛”,所以兼有静态弱类型和自然语言的双重特点, C++的模板就是从强类型求得一种类Python的弱类型的动态效果,所以它不是天然的如Python,而且它是超越类型的,后面会谈到**

这说明,设计越来越靠近编译期(甚至是设计期,比如对类型进行template化的策略行为),而非运行期,等到运行期才去验证设计,,,这种用设计(而且是符合语法的设计)来制导编译和代码生成的过程就像语言中内置了一个UML一样.. 而且模板是编译期的,可以控制编译器对逻辑的生成动作(元编程,比如它可以刻意不让某些类型的模板进入编译,你写有关模板的代码时,并不算待编译的一部分,只有那些实际发生作用的类型的模板代码才被编译才被生成代码,因此是一个很好的设计时机.. 为什么写代码需要设计呢,因为代码是人写给人看的,所以对代码逻辑的控制是需要的,而这就是设计,,设计更多指一种人类活动,比如艺术设计,所以它包括测试,重构，集续集成等诸多过程组成的与编码相对的过程.设计首先是一种对问题的积极抽象过程,booch甚至说抽象是解决设计问题最有效的方法之一,当然,维护,重构也是,所以说抽象问题只是设计的一部分然而是最重要部分. 在C++中,设计首先是对类型进行设计进行抽象(泛型这个字眼本身就表明了对各种类型其功能通用,所以是一种设计抽象),有OO.有template.OO是类型化即面向对象,template是泛型化即主要用C++的基于对象机制来工作(但是模板绝不是一种型,而是一种表现形式,代码结构,或写法结构都可由它来表现,与类搭配的模板就是表现类代码,函数模板就是表现函数).
**以前是对数据的操作才是编程，现在是，对类型的设计才是设计.**
泛型编程中对型进行的抽象,有make types to be a List,有mapping type to sth,有get traits from types,尽量在编译期间将型别抽象到应用,形成设计,因为静态语言的编译期间正好提供强大的类型功能,,,而这里谈到的typeList就是一种.. 对类型作了这么多抽象之后,再提出iterate,等设计手法用于stl,提出policy用于policy based design,,**学习范型编程,始终要提醒自己把握这个精神(即一般泛型设计会分成三个层次,第一层是型别抽象,第二层在第一层的基础上提出领域相关的设计手法,第三问题本身,STL和LOKI中都是这样)..**

>那么编译期运算(就是实例化,所以它会发生代码膨胀问题)是怎么回事呢? 编译期运算,指实例化,或模板技术下的元编程,二者不是矛盾的,元编程是利用了模板实例化的,也是一种编译器运算.我们得把二者分开,一般称实例化为产生代码,而运算,是图灵运算.

------------- 泛型的抽象意义


我们知道,其实普通的类也可作为一个函数的参数,形成以“类型”为参数,但是这跟真正的泛型是有很大差别的,普通的类以类为参数,那个类是一个具体类.并且只能是函数有这样的功能而模板类,即泛型类,那个参数可以不是一个具体类,并且,可以有类模板,函数模板这样的概念. 现如今,对于类型的抽象已经越来越完善了,经历了一个从基本类型到结构类型到类类型再到泛类型的过程,这当中,只有泛型的型才是最广泛的.**那么泛字究竟指什么呢?其实是指“类型所能表达的意义”的泛** 面向对象的类类型更多地表实体概念,当然也可表抽象概念,然而它要命的地方是:无论是表实体还是抽象,它都把所有的东西都从代码上形式化为一个class,把代码看成数据加操作,而这两种行为都是具有极大局限的. 而从泛型开发中我们越来越多地看到,代码可以是函数,可以是类,可以是结构(实际上,模版是一个泛化了的代码表现模式,并不强求把所有的代码逻辑都写成类,但可以提供对类的操作),这是对第一种行为的突破. 换言之,面向对象一律把代码看成数据与操作,这很傻 , 其实还可以是更高级的抽象或机制直接成为语言元素,而不仅仅是与类型相关的那些东西,比如数据与操作,它还可以是某种超越类型之外的东西,比如一个条件,或一种约束,比如traits,比如范型导致的抽象条件. **这就是模板的本质,用抽象条件去替代冯氏的二重机制,这是对冯氏语言的第一次突破性尝试**
它第一次突破了"冯氏语言下,设计就是对类型的设计"这样的理念,而变成了"根据抽象条件"产生新的泛型抽象concept这样的理念(这跟基于OO技术之上的AOP,interface的概念concept编程一个目的) 对于第二种行为,泛型所表达的型不但可以是实体,而且可以是关于另一个类的类型,所以泛型的型中,其内部有型,而外部的型可以是任何概念,不成强求为数据与操作. 这样,在语言用它的类型表达dsl逻辑这个层面上,只有泛型的型才是这种逻辑的最好表达工具,因为对某一种逻辑来说,任何东西都不必体现为数据和操作,而可以是其他接口. 熟悉了模版你才会发现它的科学性.

------------- traits,concept,model


Traits是剥离器,是一种设计抽象(往往人们也把一组traits称为一个concept,,满足concept的实现就是它的一个 model,即concept是编译期关于类型的interface),广泛应用于stl,loki,等设计理念中(剥离器一般只用于泛型设计,因为需要从泛化了的型剥离并获得它的traits,实际上这个词更多地强调的是结果),是成就stl,loki等的支撑逻辑.

>要注意区分traits与concept的区别与联系.Traits是对一个type的属性的描述,这个type是数据类型或类,其产生的结果,即type traits是一个模板类. 而 concept是对“types构成的抽象“的描述(各种concepts构成了一个基于concepts based design的OO体系,concepts就相当于OO中的类,我们说过,concept based design是基于OO之上主体由concept组成的的设计体系).如果说前者的type是各种“类型”,而后者的concept是“多种模板类(型) 界定的接口抽象,即用多个concepts表达的一个concept集”.称呼这个集合为concept.所以,单个的模板类也可以称为一个 concept.它是单一的概念而已. 所以二者层次不一样, Model就是concept的一个实例.这就相当于OO中的对象.



因为类型有“一般type”,作为template class的迭代器,等等,所以也有相应的type traits,iterate traits.即模板的参数可以是什么,那么泛型也可泛化什么,形成相应的泛化意义(比如traits),因此泛型可以将型别泛化,可以将操作泛化,甚至可以将一大类的操作和型别泛化.更甚至,可以将“template template参数”泛化,注意我并没有多打字,现列举可能作为template所有参数的情况,并一一加以解释:

------------- Iterater


Stl中,与template相关的一个设计手法就是迭代器,迭代器成为表达各种数据结构以及跟它们有关的各种算法操作的支持概念.当然也是一种泛型手法.Idioms 其实也是一种设计模式,即迭代器模式(traits,adapter泛型设计手法可用于广泛目的,相比之下iterate好像只用于数据结构的设计手法设计模式),

既然是泛型编程,迭代器是在什么样的泛化需求下以什么样的泛化方式被提出来的呢?

我们知道数据结构都是某种区间,把数据结构视为区间这本身就体现了某种泛化(能泛即能提供通用性,可复用性,所以是一种对代码趋近于人的设计抽象),某种抽象,实际上无论是以何种结构形成的关联式(key+value=pair对)还是非关联式数据结构(),,迭代器都将提供一种游动于元素(一般来说元素只是value的说法) 或节点(一般来说node=key,value)之间并能对算法提供迭代支持.只不过迭代器作为泛型的型它也可以有多种iterate associated traits而已,有的是input,有的是单向,有的是双向,有的是const,有的是mutable而已.

------------- Adapter


配接器的说法很形象, 你可以联系现实生活中把ps/2鼠标加一个ps/2 2 usb接口,,把它转为USB接口的这样一种动作,,这种动作就是改变接口的机制使之由旧接口变成新接口,一种设计策略(改变原有代码,使之适应某种复用考虑,,所以是人控制代码的过程,,是设计抽象,,这个动作也称为重构,即不改变原有系统设计的情况下,利用设计手段修补式地改造原系统,因此跟DP相关),,往往把它归为专门的一门设计模式.

因为客户(你的电脑ps/2口坏了不能插ps/2鼠标了)只能使用某种接口的东西,所以需要对原有接口(原有代码)进行接口重新封装,使之向现呈现客户能用的接口.这是典型的设计模式应用于给代码打补丁的情形即复用的情形.(当然设计模式也可一开始用于纯设计的地方)

那么stl中的这些配接器都是些什么呢,又怎么样在stl的整个设计中发挥了作用呢??

------------- 真正的策略


template应叫做C++的“泛设计层”,“整合设计层”,**policy based design(其实更应叫做concept based design)才是template技术的主打精神！！！！**

为什么需要policy呢,,因为我们知道在应用开发中设计往往是做多选题,对应于应用域在解域和语言域中有大量可供选择的方案,所以可复用组件最好是给用户小的设计组件,用户才能借以组合它们形成更强大的设计方案(具体到每个领域,它的设计都应该如此,比如loki,的智能指针,仿函数等具体领域都是策略based的).因为设计元素只能分解而后才能复合,而不应该是一开始就复合了..如果一开始就提出一个do it all全功能型的接口,那么往往复用性从一开始就固化了(OO就是如此,单根继承往往涉及大量不必需的东西进入设计,组合才是科学的机制).这往往很不好.因为它只能向前发展不能向后发展.那么组合大量小policy形成的对某个瓴域的某套组合polices,给了我们后退的空间,我们可以组合需要的去除不需要的,这才是我们需要的,即设计中可以在此做选择题的能力和场所.. 策略为什么跟设计模式有关? 我们知道设计是高于编码的,这就是说在我们进行设计时,进行的是一种纯思想的活动(非常重要的是这里的设计二字远非设计模式中的设计那么狭隘),并不预先想到要面向编码而设计,然而我们得出的某种设计方案(比如一种架构逻辑,,设计模式)并不是不可以在技术上用一种方式来实现,因为狭隘的设计模式之说的设计不过是根据设计方案产生一堆类文件而已,设计模式高于成码跟设计模式可以用一种技术来实现并不矛盾,关键是找不找得到一种技术实现手段的问题,你可以联系ISO网络参考模型来考虑, 一种思想或协议的确可以用来实现..就凭这点,我就十分佩服策略的提出者 **策略是属于设计的而不是编码的(虽然策略也是写代码)**,,,这是本质,明白这点非常重要策略就是这样一种技术,模板技术天然就用于参数化类(这是模板的本质抽象)并产生类文件,这在设计期是一个天然的技术实现,比如一个类文件可以产生一个职责或对应设计中的一个对象,而模板可以跟据对象本身的特征(比如对象的类型)去决定产生的表示这个对象的类逻辑,,而这正是策略要解决的问题策略是多范型设计的较高境界,虽然OO也可很好地表达设计和思想,其它范型也可以,然而策略更接近设计,比如DP的Sington,Boost 的Enable If,,从这些字眼上看就直接跟思想和设计已经十分接近了.(不要忘记DP中一种是模板方法设计模式,,这更一步反映了模板与设计的深层渊源) 策略与OO是什么关系呢,(OO和OOP出现在前,,然后是DP,GP,Policy这些范型),因为模板就是一系列可运行的参数化类的逻辑,那么对这个过程也可以用OO(OO与策略并不是包含或被包含之类的关系)来实现,,因为模板也支持OO,比如STL的源码中,对容器,通用算法这些的策略大都没用到 OO而是一堆面向过程的过程模板(函数模板就是子过程模板,类模板就是用到了一点OO的模板),,(如果策略本身也是用OO范型(通常说的OO就是类文件级的OO)来实现的,那么这可以称之为二阶OO,第一阶是1,模板产生类的过程中用到了OO,2类本身也是一种OO,) 因为策略就是模板技术描述的设计思想,设计思想可以是Gof,Boost,Loki,Core J2EE Spced DPS这样的大思路,也可以是一切反映设计的小思想,,因此策略不仅仅是我们现在已经见过的上述一些实现,,,它可以是千千万万的不同思想的模板实现形式 (因为思想有千千万万嘛,抽象是无底的)

>什么是编程,什么是抽象能力,编程能力,什么是学编程(即使这样看似最最简单的问题也其实不会简单,网上的确有太多这样的争论,那么这里将会给你一个有形式描述的概念,关于我在一个维度的认识,因为我们在上面提出了诸如设计,抽象,原语之类的用词,因此接下来的描性会变得容易界定,这就跟设计模式内部的那些功能分工的说法一样,,只有给出了能形式化的中间逻辑用词,那么才能不会在争辩时连最细小的中间共识都不能达成,那么也就不可能得出一个最后的结论),比如我在第五部分会写到一个世界逻辑库,因为要在这个逻辑世界里产生很多Actor,,而Actor本身又有Type,,Ablility之分,那么我可以用模板表示,,(ectc),如果你能像我这样想,那么恭喜,你已经在非常有成效地学编程了,,,而你在看我写的代码,,那么再一次恭喜你,你已经在实践了所以什么是编程,,编程就是用各种范型来实现设计,,, 学编程就是在大范型之下学大量细节的小范型(所以说JAVA并不是一种很好的拿来作为教学语言的语言.因为它在OO方面和OO后面的事做的很好,然而在OO前面的那些范型全部被忽略了) 抽象能力就是对外来架构的理解能力,和掌握大幅中间逻辑,,以构造新逻辑的能力(计算机与人脑的区别就在这里,人脑可以主观能动地发明抽象,,而计算机只是我们用来反映抽象的工具,它本身并没有主动意识和主动构造抽象的能力).


>设计的多选择对多范型的考虑要充分考虑复用,因此必定要考虑到二个原则:找到方案领域的变化与,不变点,不变点可以做到基层(高层抽象,,,并不一定要用继承这种范型来实现,因为面向对象这种范型只是多范型的一个子集而已),而在多范型的眼里,任何领域工程都不只通过一种范型来解决 (比如的面向对象,比如某一种语言的面向对象),,因此它可称为metadesign,,注意,它是设计metaprogram是关于语言的语言,是语言之上的更高一级抽象, 分析过程往往往往找出事物的不变点与变化点这是多范型里面常常提到的二个词,这二个词反映了什么事实呢?

------------- C++中的编程层次与设计层次


>实现层次:Core C的三种流程控制,class(注意,这里提到的class是不带private,protect,public等饰词的类),union,struct(class,union,struct在C++中被称为三大class 结构),const,static,各种primitive types(int,char,float,double等)及它们的语义为什么称这些为实现层次呢,因为冯氏语言都有这一套基本语法和简单类型,它们由平台的指令而来,体现了用语言的运行逻辑来代替程序逻辑体现问题和应用的方法.所以是实现. 设计层次: Private,protect,public,overload,OOA,OOD,模板及模板内部的一系列手段特化偏特化等.Generic programming和meta programming,traits,concept,model

所以存在三种设计相关的大件(形成高级的代码抽象的大件)在C++中,OO,模板(语言级)和LOKI(库级).(也许还有一个语言级的better c)

>C++ template 将设计做在了编译期,做到了独立于运行期,做到了运行期零成本也即它是用实现语法来创始设计,用语言内的东西来设计,不像OO一样引进RTTI这样的额外支撑逻辑(模板会产生编译器overhead问题,而rtti会产生运行期overhead问题,但编译是一次,程序却要运行多次),模板中,实例化后的产生的目标,最终在运行时,不带除模板体之外的关于模板本身的之外的任何东西,那些因为设计付出的代价为 0 而C++的OO却用了rtti(run time 的东西),依赖于运行期实现其三重机制,运行期为设计付出了代价而C++的OO就是不光把设计做到了语言层,而且还是语言层的运行层,这使得《源码就是设计》在一定意义上是正确的真正的设计不应做到语言内,我们提倡一种脱离语言的设计,比如用IDL的方式,或UML的方式,template的方式,即使做到语言内,比如OO,也不应把它做到运行期.这就是C++的OO的缺点.



C++的泛型似乎跟python语言利用动态类型实现的声明性类型编程有相同之处,但其实还是有很大区别的,这是二种根本不同基础的“泛型”,我们要区别开来.

模板的能力在于抽象类型,所以设计的一种意思是类型控制和抽象能力(动态类型更侧重实现谈化设计所以它首先去掉强类型,而提供弱类型或无类型或动态类型),模板只能只做类型控制,然而LOKI可以做到控制逻辑级.这就是单纯的模板用于设计和LOKI用于设计时的区别.. 设计的唯一特征是站在高阶的泛,这就成为区别实现与设计的根本,而不是大小问题的逻辑包含互饰关系(因为这样的话,设计与实现只有模糊分界),而泛成为区别这二者清楚的界限. 为什么template仅有type as type一项就足于跟OO匹敌呢,因为类型就是语言的一切,提供关于类型的机制就是一门语言的设计能力的一切.. 动态类型语言也有类型,,不过它的类型不需要一个设计期的type来确定指定而已,,其本质也是某类型的某个value. 而动态类型没有type,所以没有对数据的泛化,也即无法抽象数据,也就无法抽象代码和控制(设计里的)逻辑,所以无法设计(设计的一种意思是类型控制和抽象能力,,动态类型语言不存在对类型的抽象,所以至少这种意思的设计在动态类型语言是不存在,因为动态类型是DSL语言不是通用语言无需考虑类型及类型抽象上的设计).它只能在线控制逻辑的运作. 所以动态类型语言是实现语言..应该称动态类型语言为在线类型语言.模板是离线类型语言. 我们知道设计是复用导向的,最终用户(领域内用户,脚本用户)和程序员用户(本语言内的复用,语言非通用的)是二级不同的面向级,前者用动态实现语言即脚本语言,而后者用静态语言为宜. 解决可复用银弹问题的根本可以改造开发模型,,也可以将设计逻辑尽量多地沿伸到实现,而且是脚本用户级.因为此时没有编程工作,只有配置工作,银弹问题根本不存在

>写在后面的话:其实C++的元编程属于十分高级的抽象能力,我们不应该把精力放在这样的语言机制上面,基础薄弱的读者和程序员只需要把精力放在学好C++的运行期OO和数据结构就行了.因为大部分公司开发中甚至都不会用到这些技术.

------------- C++中的元编程


这个可以在后面的章节中找到,它是C++使用参数化类型的另一个重要的领域.

------------- 泛型编程其实是一定程度上的自然语言编程[7. 没有绝对的自然语言,一般称Python这样的语言,就是自然语言.]


如果我说泛型编程是C++最简单的语法机制(甚至比OO要简单一百倍),你相信吗??实际上只要懂得C++的发展趋势(C++的所有库,包括标准库,BOOST,都是以模板和泛型实作的),我们就会了然于胸了.学习应该“深入浅出”,只要先下功夫明白了“模板与泛型”,那么我们在使用 STL,BOOST库时,就会猛然发现,原来学习起来复杂的东西,,其最终目的是为了带来使用上极大的简单性.

如果我们将泛型编程手法的意义再拓展一下,我们就会发现,它其实是一种最灵活的编程范式.甚至可以产生自然语言编程.一切的一切,源于类型可以只是一个空的占位符(其实,整个模板世界就相当于是一台一台的炸汁机,在本书第二部分会谈到type traits.只要向其中投进去一个具体类型,模板就会为你产生一个真实的数据逻辑,如果你只是使用模板而不是开发模板,那么你就会发现这对一门语言的优越性,这使得用模板设计的C++库在使用门槛上很低),设计的时候可以不用考虑被如何编译(当然,要求所有的模板是语法正确的而不管它是不是会被编译,这点似乎不好,新的语言应解决这个问题),我们要做的工作,就是把模板内部的那些过程式逻辑也弄成占位符(泛语法编程而不仅仅是泛型),只有先从这个角度考虑问题并解决它,其它的讨论才会开始变得有意义起来.首先来谈这个所谓的“泛型”,再谈泛语法的问题. 我们知道,模板是一种型,虽然它可以以函数,类,结构的代码结构形式被体现,但它首先是一个模板,首先是一种模板“泛”型别(这种代码结构),也就是说,它不但可表数据,在意义上还可以表其它东西比如一个动作,一个随意发挥的逻辑.因为它只是一个占位符

>占位符,你可以联系SQL语言等说明性语言中的东西来理解,它没有语法,要有,也是最为简单的语法,出现的全部是概念性的用词.只有不涉及到任何语法的概念,即让程序员脱离了对语法的考虑,那么,编程实际上就没有任何门槛了. 语言采用半解半编的意义是:它把解释放在前面,把编译放在后面,这就相当于纯编译时把汇编放在后面一样.

泛型与动态型别的区别是:动态型别模糊了程序员对型别操作的必要(变量可以不用声明其所属型别就可以拿来用),是一种进步,然而,其并非泛型,也只是具体类型而已,写源程序时是跟考虑这种型别在运行期有什么动作紧密挂钩的. 于是我们可以把泛型看成dsl中的领域词汇,自然语言中的词汇,当然这个词汇可以是一个名词,可以是一个动词,也可以是助词,也可以是某个句子结构,比如一个由助词构成的短语,英语中的不定式.但无一例外地,这些形式都是领域词汇的变形(所以,我们正是企图把自然语言编程和dsl结合起来). 如果你看到这里就以为他跟面向对象用类来表示领域逻辑一样,那么你就错了,因为模板决不是类意义上狭隘的类型.我们可以借用模板元编程的那些手段,将一个模板的形式发挥到我们想要的复用形式.而不仅是一个数据加代码的类类型形式. 这就是说,定义一个模板的时候,我们不仅定义了模板逻辑本身(即定义了领域逻辑),还声明了模板如何能被使用的形式(比如不定式to do sth,这三个词中的sth可以是领域词汇,do也可以用模板表示一个领域动作,to就表示一个领域助词,所以,模板决不仅仅是数据加操作的这层意义上的组合).这些都可以通过给模板增加多态化机制来进行.加多态可以表现为任何代码,这样每个领域词汇可以随意地组合而构成实际的意义了. 到底怎么样加多态呢,我们先在脑海上想象一下元编程把模板变成函数,重载括号后形成的泛函数形式,而我们知道,重载是多态的形式之一,就拿这个例子来说吧,对于一个to do sth不定式,不防我们把to这个模板领域助词的尖括号看成省略号的三点,表示“可变”参数类型.这个可变参数可以是源程序中的其它泛型. 这样的泛型语言,对每类应用都有一个词汇集形成的框架.所以是一种DSL语言,而且这种语言本身就是一种设计模式语言.也不必发展出一个所谓的数据结构来解决现实问题.因为我们可以在这种语言中bind C++的dll为领域词汇.这样,所有的问题都是复用问题了,稍后会详细讲解这种语言的这个方面. 最后,最重要的一点是,这种语言得改动一下 C++的模板写作时符合语法的要求(因为我们这种语言是无语法语言,当然,无语法语言是否图灵完备以构成完整的逻辑?下面我们会谈到),我们可以写出一个不符合语法的机模板,即真正泛语法版的泛型模板.这首先得解决泛语法的问题. 我们来看如何解决泛语法的问题. 因为我们想通过泛语法解决泛型的问题,所以这种泛型模板也就是一种真正的无类型了.我们不防认为泛语法也就是无语法. 本文谈到的泛语法就是这个意思,在写源程序时,语器词,拟声词等在源程序中不起作用,先假想这种语言的编译器是个预处理程序,是一个自然语言到标准c++语言的翻译器,最小的翻译单位就是这种领域词汇.所以它并不会翻译那些不是领域词汇的词,比如上面谈到的语气词,拟声词,以及不是领域词汇的动作,名词.所以这种语言的起作用的领域词汇部分跟源码注释是混合在一起的.整个源程序就是一个可读性超强的文本.自然语言形成的文章. 什么是泛动词呢,想象stl里面的通用算法就可以了,这种语言的源程序里,每一句翻译系统都会把它看成主谓宾,或谓宾这样的句子结构(当然还可以是其它的),最后翻译成c++的源程序. 而其实,这种语言也可不作为C++的前端,而作为一般的编译器,即编译为平台码,下面我们给出这种语言下开发程序的详细策略: 首先在语言内部,因为其语法上支持泛语法(无语法)和泛型,所以我们可以在设计阶段进行自由,脱离语法的编程(因为此时并无语法),只有源程序中那些领域词汇会进入到后来的严格编译过程中(此时出现了语法).这种语言唯一的语法就是领域词汇构成的那部分源程序的正确性.是否能编译通过.而由程序员来保证每个领域词汇能正确编译,由人来保证逻辑的正确性.因为这属于领域词汇是人的东西而非机器的东西(整个语言没有机器的任何因素存在,没有变量,没有类型),所以由人来保证它们逻辑上的正确性是合理的. 所以整个语言将会是这样的:I to do sth,he goes these.这样的语句我们可以把这样的语句也封装为更大一级的领域词汇. 如果这个世上有朝一天会出现这样的语言,那么我就是它的鼻祖了.

*/