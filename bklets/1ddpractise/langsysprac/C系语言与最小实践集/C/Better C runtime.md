Better C
=============

betterc vs cplusooplib,is betterc just c plus a oop lib?不，还要改善其运行时系统，或者，将这一切的变化，直接整合进一门新语言

其实也存在no vm scripting,比如ogre的脚本系统，这样就不需要作语言间的binding了，一切都是CPP的库逻辑
较no vm script lang,py重造了编译器，.net重造了平台




cpp的组件态

我们把程序逻辑处在的不同的语言组件态，称为静态编译期(往往是obj文件)和动态执行期(可重定位代码在内存中展开的形式)，，，它们在这二个态中会表现出不同的动作(称为计算过程)。

类型是c系语言(乃至任何冯氏语言)在静态最重要的特征，一套语言规范无非是关于类型(这就是我们称为数据的东西)和类型计算的计算设施(这就是我们称为代码的东西，更严格的说法叫代码结构，，当然还有除类型计算之外的其它计算设施，比如流程控制)，，C语言的语句操作函数(函数并非C的一级类型，作为LONG INT的函数指针才是，，故它可替换函数调用参与计算)，实际上，在编译时，这里面所有的关于类型的计算包括类型本身，也是被静态编译为固定地址的 -- 或称代码。），，似乎vc编译器中有一个program database就是用来保存中间信息的。

所以，CPP的程序再怎么演变，这些东西和它们之间的作用是最基本的：

一，，，，better C的简元类型，，基础的代码结构。这是C系语言runtime的最终本质。所以也是C程序，CPP程序最终分解到会编码(asm)看到的那些东西。

二，，，，class UDT，，。我们用UDT这种高级元素（对于模板来说是下级元素）来更方便地组织核心元素（简元类型，基础代码结构）。。

三，，，template as shell,,,,,,可以只靠CPP的基本UDT来进行大大小小一切的程序设计，，当然，，也可以进一步用模板。。这样，UDT基于简元类型加基础代码结构（OO范式），，，模板又基于UDT（形成GP或metaprogramming范式）。

这些最基本的东西搞清之后，接下来的讨论会尤为方便：


cpp是美的

CPP至少有如下方面的平衡。

它的静态运算和动态执行，都是效率极高的，无论把程序组件化为静态逻辑偏重的（虽然编译效率不高，但它是冯氏机空间换时间的最基本矛盾避免不了），，还是动行期逻辑偏重的。它的效率都是本地程序的效率，，中间决不会有一个SOFT VM。


(3)cpp是玄的

道生一，一生二，，CPP强调任何东西都有一个元（它的元是隐式的，不像PY一上来就在语言的来处 ------ cpython api处提出一个meta，它的元是类型加组件的双重结合体），元的好处，就是你总能找到自己的来处，世界有一套总的规则，然后分规则只是划地而冶的领域。这对学习曲线的降低作用是很大的。因为CPP的玄，正是它的简单，抽象一方面拼命集成，一方面只在现实世界露出一头极小的源头。只要你找到源头，拖它出来就是了。然后在你所在的那个世界用它。

》》比如，对于多态和抽象接口机制，，它可以有compiletime多态，runtime多态，甚至runtime动态(注意这个字眼与runtime多态的区别)，以模拟那种纯粹将类型绑定做到运行期的动态语言(any type,,ducking type)。利用concept来限定模板参数（GP编程中，那个中心类型）的某些方面（比如if assignable，，这样，装备了assignable类型参数的模板就是一个泛型接口了，编译期接口了），，，而且丝毫不会带来侵入性。（CPP进行OO的核心动作就是多态加抽象函数作为接口。多态使得一个基类拥有继承类的语义（而且保证它们同型，用基类指针可以调用到继承类成员）。这就带来了侵入性，因为继承类与基类表达了一种上下类型相关的逻辑关系，在扩展或复用时，得不到派生类源码就不好扩展，因此，DP提倡对象组合，以在复用这二个对象的新对象中不再继承其中任何一者的抽象函数接口语义，基于模板的“runtime动态”另辟新途，其在二个类间逻辑关系发生点是一个模板参数，而它是泛的，，所以，不会带入运行期的任何侵入性）

(4)CPP是乖的

模板的设计完全是策略的组合，，，在使用模板库时，又完全是策略的组合调用。模板程序库的设计者，可以将设计中出现的东西（它们要提供的，用户要用的接口），，全部细粒度地分担在模板参数的traits中。

一旦驯服CPP，，你根本不需要任何东西作补充，，虽然语言的发明不是为了互相替代而是为了互相协作，，但假如一门工具你已经能够随手拈来，弄得虎虎生风，，难道又要去经历新语言对你倒退性的brainfucking吗？






异常系统
-------------

用OO表达的异常机制，直接加入语言

更强大的与系统的接口 : 后端内存模型
-------------

ffff