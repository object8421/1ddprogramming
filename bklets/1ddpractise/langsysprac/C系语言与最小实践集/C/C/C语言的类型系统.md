/*!

\page C语言的类型系统

============= C语言的类型系统


c语言中,只有int,float,(c99支持复数类型了),连char都不是编译器的类型,因为它是一种库级类型[3. 注意,C语言的标准库,其实并不是Builtin库,这二个概念不要混用,builtin 往往指built into compiler而不是built in stand library.],即typedef出来的类型,c++开始才从语言级支持这种类型,而在c种,它是一种plain old user define type,是用户类型,而class是abstract and user define type,也不是first class type.即编译器类型. 库和语言的区别是什么呢?语言定义了语法和内置类型,即它解决了怎么写与写什么的事,库即是对语言的扩展,但不是对语言核心的扩展, 所以,C语言中是没有char类型的!!(如果说语言的语法和标准库定义了一个语言的话) 到底什么是类型呢,C++ template的type跟class有什么区别呢.. C语言中有一种void类型,,无类型指针..我们知道变量是有三个要素的,1变量的名字,2,变量的地址,3,变量的类型,其中3是最重要的,它影响了2,,这也就是说,对于一种变量来说,一谈到这种变量,它的大小就清淅了,,变量的最重要的特性是它类型影响下的大小...这是变量的本质

所以,对于变量的指针这种类型来说,,在使用它之前,一定要知道这指针是指向什么变量,,这样编译器才知道从这个地址,以多少大小的范围去操作它,否则void类型的指针是不能被解引用的,只能供调用参数用..

使用void来作为函数参数时,主要出于这种目的,比如我们想让一个函数处理多型数据,就可传递这种数据的指针,因为是多型,我们不直接定义int *,float *,这样多的类型,而代于void作参,这样处理时带来void解引用后的结果(当然,得cast成int*或float*这样实际的指针变量才能使用得到它指向的数据). 而cast是一种什么样的过程呢,C语言的隐式转换是编译器的动作,手动转换是程序员的事,但是,无论是这二转换的那一种,都不改变原指针值,它只是在内部作了一份拷贝(这个道理就像传指针也是传值,不过传的是指针值,因此另外一种意义上来说就相当于传地址,,它跟直接传值一样,也是作一份拷贝),你可以将这个拷贝值看成为C++新增的指针语法:变量别名..





------------- C语言的名字修饰


变量是程序员用来操作内存的手段而不管编译原理那门课中的东西,而变量是建立在类型机制上面的.构建在类型上的具体数据类型就抽象了计算机存储机制和它能表达的现实事物.程序员可直接用这种抽象(类型抽象下的数据抽象)来产生更深层的逻辑和解决计算机能解决的问题(类型设施本身就是语言机制之一,比如基于类型的声明语句和声明系统)

Const是一种把变量转换成变量的方法,于是,对这个量的访问永远不会导致它改变. typedef是类型替代名(typedef=type dfine嘛),在理解时可以按以下的方法进行 typedef是C语言不够丰富的类型再造类型的一种手段(是一种拙劣不直接的抽象手段). typedef是定义一种类型的子集,,,比如typedef int INT;(这意思就是说,INT是int的一个子集) 类extern的这样一种声明(也即仅仅是对类型的向外的一种再声明)[1. Extern这个关键字不但关乎名字在编译期可见或不可见的名字空间属性,而且还关乎连接期的可见或不可见属性.这是跟voliate等一样的C中一类比较特殊的关键字,],如extern int myint;(这意思就是说,作为变量的myint这里作为一种“新的类型”,而且是一种“int类型”,,,这是一种当已有类型的再声明) 也即,extern就是相对于变量,typedef就相对于类型(注意它们二者并不实际等价,也即不会有myint这个实际变量被声明出来) 注意,一般myint要大写,但是这里为了说明还是采用它的小写形式 由第二种理解方式可以导出很多,如typedef int (*myint)(),,,可理解为extern int (*myint)(),,这里的myint也是一种类型,这种类型表示“指向一个返回int类型的函数的指针类型” static

在C++中,一个结构也有它的构造函数,这个构造函数(接口类不应包含构造函数)往往作为初始化该结构的初值使用,因此一般将它们作为static来定义,这就不得不说说static到底给语言增加了什么? static的成员也不是静态的,它也可以进行自加自减这样的操作, static是在编译期发生的,因此不能在运行期改变它 在一个函数体内定义的static数据,,相对整个程序来说都是全局的(直到被销毁) 因此static提供了一种把局部自动变量转化为暂时全局性的东东,,比如对于一个在函数体内的常量来说 static也被作为类级的私有成员数据或行为(类属函数),因为类只是定义对象的规范,因此它应该没有一块内存实际存在用于调用它的成员(一般方法是具体化出它的一个对象然后调用对象在类中定义的成员),但是static提供了一种“全局静态”的概念(类级的全局),比如Java中systme名字空间的API就是全局的API(包级的全局),可以直接拿来用 函数退出这个常量就失效了,解决的方法是用static或const static的作用就在于“保值”时空限度为定义它的整个模块,,这是相对静态局部变量来说的,,还有静态全局变量 要注意,一个函数的原型和它的具体实现是分开的,你可以overroad(复写)一个基类的private的函数声明,但却不能调用它的实现 也即,只能复写声明,而不能调用定义(实现)

声明与定义 声明只是一种说明,它体现了人,对于编译器的命令,,解释性语言,就是去掉了声明[2. 很难说自动档汽车和手动档汽车哪个要好用一些.各有各的用处吧.]. (而编译性语言是编译器控制类语言,比如手动实例化,而解释性语言不提倡这一点,但是,也有策略实例化,这就是C++的多态) 类是预置的,在C++这样的语言中,第一次有了“使用程序”与“定义程序”的说法.而C中,例程一旦被写出来,它马上进行编译,没有被调用过的例程,也进行编译.但得不得到实例化,不是编译器的事情,这是运行期自己的逻辑. 在C和C++中,声明和定义是分开的,如int i=9;就是一种定义(因为连初值都赋过了这说明分配了内存),而extern int i;只是一种声明而已(向外界宣告它的存在),而Java中就没有声明跟定义的差别了.上面是对于变量来说的(特别是对动态对象—也即对象变量这种表现更加明显),,对于函数的声明和定义的区别就更加明显了. 不需要手动实例化的就是多态.为什么呢?多态由编译器智能“实例化”,而程序员只需要提供策略上的参考(程序员使用多态类的行为会促使编译器自动完成这个过程). xx

编译型语言,才需要将语义控制在编译期,所以需要声明,告诉编译器稍后将这个声明所代表的定义对应到编译后的运行期(因为运行期运行的,是经过编译转换的东西,所以,这个变量,它在写程序的时候,是固定的,静态的),而解释型语言,它有自带的运行期,它的源码语义全部正是运行语义,所以,定义就是定义.可以直接避免类型,而直接提供变量和数据.(所以,这个变量,它在写的时候就是它在运行时的状态,所以可以说是静态的,也可以说是静态的,这就是人们说的,静态编译,动态解释的本质意义.)

------------- 指针类型:可用于实现的语言因素和可用于设计的抽象语言机制


首先,指针绝非一种凭空出现的语言工具. 指针[4. PL/I高级语言最先引入了指针]的原型最初来源于汇编语言,汇编语言中也有指针,这种意义下的指针是一种底层实现的语言机制,比如 mov eax dowrd ptr [某一地址] mov edx dowrd ptr [某一地址] 这里的[]及其中的内容作为一个整体,这个整体就是指针,它是一个表内存地址的值,这里,指针仅仅是一个值而没有一个名字.Pure的汇编语言没有变量.自然就没有名字. 故，C在这个意义上（指针的意义上）是更高级的会编。 pure汇编语言实际上并不图灵完备,因为它是对指令的一种命称指代,汇编语言没有变量.因此没有编译器里面谈到的变量等符号映射为内存地址的符号化信息,它的语言机制比如sub过程都是模拟的实质上并非语法,因为汇编器毕竟不是编译器,解决问题时所面向的源语言和目标语言不一样.. 然而当指针发展到高级语言的C指针和C++引用时,,又形成了更高层的逻辑,,这种高级语言中的指针和引用,就是一种**解决指针由无义数字到有义名字的问题**,是一种由底层向人的方向抽象的过程 那么这种通过内存地址访问内存地址背后的那个东西的方法有什么用呢? 自然地,我们为某块内存中的对象设立指称它的指针[5. 指针首先是源于一种指称语义],只为能使用它,,,因此,使用指针就是关于此对象的使用抽象,中间层,,我们不必知道这个对象的具体情况就可以操作它(即使不知道它是一个什么变量的情况下),,这个指针便提供了操作它的全部接口,对这个对象的访问与修改操作都是通过这个指针而来的,,,明白这个道理有什么呢 比如有如下一个程序 int var1; int * var2 = new int; var2=&amp;var1; 为了使用变量var2,,我们当然可以直接通过var1变量(也即var1名称本身)来访问到它,但是为什么我们还需要定义使用它的中间层,这就是指向var1的指针(换言之,我们并不想通过var1变量名称本身来访问变量)

>一个对象的指针是关于这个对象到它的使用级的第一层间接,指针的指针就是二层间接,, 也即,为一个变量定义一个指针等价于计划通过这个指针去访问对象,(这个指针也可实现访问控制) 如上所示,这第一层间接和第二层间接都是通过type*的形式出来的,这样就保证了与原对象的充分脱钩 也即 int * var完全可以和原对象脱节(var2这是第一层间接的其中一个指针,因为可以为同一对象声明多指针) 

这样到底有什么好处呢? 有时我们想访问var1的同时不想改变它,这固然可以变int var1为const int var1,然而这样改变了var1的属性(也即我们需要在不改变var1的属性下实现“访问var1却能保证这个访问过程并不会改变var1”) 于是,我们可以用const修饰修饰指针指向的对象, int var1; const int * var2 = new int; //这样*var2就是const int了,因此var2指向的是一个不能改变的int值,虽然var2的值依然是var1的地址,,但我们的确实现在使用层就保证使用过程也不会改变原var1的值) var2=&amp;var1; 对于var2来说(虽然我们不知道还有多少指针会跟var2一样指向对象),,它作为一个指针出现以访问和操作它指向的对象,,,在var2的层面,我们只能通过这个指针去修改对象,,,可是,var2被定义为const int*,,,因此并不能使用它来修改指向的对象 即,除了类型之外,指针的声明可以与它指向并要操作的对象无关(比如关于操作的const,,,它就可以仅仅并施行于var2上,而并不要求它的指向对象为const,,因为var2只是关于原对象的使用逻辑而已) 

**指针是关于一个对象的间接访问层及访问控制逻辑集合点**,那么高级语言中的指针是一种变量,有一个类型,作为变量的指针又是怎么一回事呢?

int x[][]，，用int **p 可将其视为一维取值，，石破天惊

>type* 这个形式就表示一种类型,,,,如果说type本身也是一种类型的话,那么在type后加一个星号也表示一种类型,,这种类型叫“指向这种type的指针类型(重要的是最后的指针类型这四个字)”,,你可以联想C中用int再声明出char的情形. 所以你就可以这样定义东西 type* someobj; (*可向type靠近或someobj靠近,C程序员偏向于向someobj而C++程序员偏向于向type靠近,这样的话就有二种等价意义,type *someobj表示*someobj是一种type变量,type* someobj表示someobj是一个指向type的指针) someobj就是一个指针变量,它代表指向此type的的指针变量,,因此在这里type*是类型(是一种指针意义上的数据类型),someobj是这种类型的一个变量 指针有什么用呢,,指针用"指针本身"来指代"它所指的东西本身"(虽然实质不同, 一个是指针变量一个是指向的变量本身,二者除了意义上指代与被指代这层联系之外,其它方面没有任何联系,这二者是二回事,从变量的三个方面来看, 用类型的眼光解读指针 1.变量的型别,,每个指针变量都是一个指向某种型别的指针变量,它首先是变量,然后是指针变量,再然后是指向某某某型别的指针变量,第四是指向某具体变量的指针变量,被指的变量可以是其它类型,但指针变量都是一个32 int 2,变量的作用域,指针变量只为索引被指代的变量,如果被指代物被释放了,而指针本身没有被释放,就成了野指针． 3,变量的所占的空间,不用说了吧 虽然存在极大的不同,但是,但是指针的精神要求你把它们二者建立"他们是相同的"这样的认识,这是基于抽象的考虑要求的,也指针 比如 int* pointoaint;????? //pointoaint就是一个关于int类型的指代,,, 那么这种指代有什么用呢,(相比之下,引用比指代更能体验这一点,引用=它所指的对象本身,它所引用的对象本身,虽然这二个概念不等价,但指针这层抽象的意义就是让我们人脑把指针作这样的理解,) 

让我们继续回到指针的话题.C,C++这样的语言到底跟指针有什么关系呢?为什么它一直是作为类C语言的语言要素而存在? 其实,指针不单是控制底层的工具,也是C的形成语言机制或库逻辑的工具. 

###### 字串与指针

*字符串,C的字符串跟指针密切相关.C根本就是用内存来控制字符串的. 而C++的Iostream.h你去看看,,全是抽象了的模块,你根本不需要深入内存,二者根本不可同日而语,,这是因为C就是站在底层去构造字符串逻辑的,,而C++隐藏了这些,,不让程序员知道..所以C最适合当系统编程语言,而 C++控制系统的能力却没有C强,,,一个很好的例子就是可嵌入开发,C++根本不行,因为C++更多地是一种应用开发语言 数组,C的指针几乎(我说几乎)等同数组,前期的C根本不能把数组当参数传递,,后来的C标准支持了这个观点,,因为数组在C的观点里就是内存地址．因此用指针完全可以控制数组,,函数可以返回一个指针以返回一个数组,,,数组也可以用指针而不用索引来定位并操作它的元素 位操作,,就是所谓的bitwise了,,这个跟指针的关系就更不用说了 综上所述,,C是靠指针来进行设计它自身的,,,而且,C是靠指针来解决C能解决的程序问题的．．因为C不仅是一种语言手段,,更像是一种语言抽象．．． 在C语言中,指针是一种“语言机制”而不仅仅是一种“语言因素”,它导致的差别在于:如果用得一般,指针就是一种普通的工具,仅仅在给函数传地址以改变实参,数组元素的定位本质是指针,,这些课题上达到顶点,而如果C语言的指针用得好,C语言就会是另外一种语言. 那会是一种什么语言呢,那会是一种Advanced Pointer C Lanuage(增强型指针C语言,指针使C变为设计语言就跟C井高级语言一样,而不再仅是普通意义上拥有指针作为底层机制的中间语言) 因为指针是C语言唯一的"抽象语言机制",我们这里提出"抽象语言机制",说明可用于设计那些非低层问题的高级应用问题[6. 指针是C极力向应用靠近的不直接和拙劣手段,typedef再造类型手段也是如此,然而要知道, 然而它们对控制低层有用,是C的特点也是缺点],,,比如C++有"OO","范型"等等(很多书上讲解C++没有讲解指针这是对的,因为C++的语言机制中,只有OO和范型是它自己的,而指针几乎是C语言唯一的抽象语言机制)

指针被用于设计时,,它的用法有哪些?? 这就是学C的最高境界
首先,指针本身就是一种抽象.
用计算机的眼光来看是内存地址[由于引用是变量的别名,,所以,引用并不是一个地址值,而是变量名,,,,注意必须对一个即存变量进行它的一个引用声明,而不能对一个常数进行引用声明,这个道理就像,我们通常不用&变量的形式来获得指针的意义,而是用*,因为&是面向内存的,而*是面向用户的抽象.],如前所说,用人的抽象来看,它是一种为访问设立保护的间接机制.

然后,当这种抽象跟数组结合时,它可以演化出更抽象的东西,比如它可以是某种索引工作的底层实现机制..无论是顺序数组,还是链式,索引,散列,都是通过某种抽象形式(下标,,全局表,函数)来最终寻找到内存地址,而指针可以完成这个工作.

人们用索引来看待变量的方法,,这种行为自身也表明,,引用只是一种靠近人脑的抽象,,,是一种语言的抽象机制,,人们说指针是C语言的灵魂,,说的就是这个道理(当它涉及到抽象时)．．

我们拿字符串来说明这个情形.

因为字符串也是一个数组(更准确来说是可以用数组来实现的线性表,只不过它的最后一个字符是/0而已),所以形如char*的字符串也一定跟数组有关
如果一个指针指向一个new type[num]形式开辟的数组,那么经常有下面的形式出现,
数组名=指针=数组的索引1的地址=用双引号括起来的一串字符串
char* myvar = “iloveu”是用字符指针指向字符串第一个字符在内存中的位置,char[] myvar2=”iloveu2”也是成立的(字符串往往以字符指针或这种字符数组来表达).
指针加1等价于索引也加1,但是这其中发生的本质是不一样的,,指针值加了sizeof(type)的值,,而索引只是向后一个索引递进而已

Todo.这里改下
但是,指针在完成这个工作的时候,给C带来了二义性
在单维数组中,,指针跟"&数组名[索引]"或"数组名+索引"的方式有点相似,,实际上这是C语言语义的二义性,,这是为了让C语言变得灵活而保留的..而在多维数组中,&数组名[索引]"或"数组名+索引"往往并不是一回事..这一切都是因为C语言中的多维数组其本质还是单维数组,,因此用单维数组的索引或指针方式用在多维中,就会出现很多语义..

我们来分析一下,可以得出以下结论:

首先,我们知道数组名并非指针,它只是一个意义上的等同,实际上存在数组名作为指针,,但是不存在"&数组名[索引]"这样的元素,,它表示一个地址(从...开始的地址)而非表示一个元素..尤其是在多维数组中要分明白..

“同一”与“等价”的区别就在这里出现了,你是要比较它的值呢还是类型呢?

实际上数组的地址的确等于它的第一个元素的地址,,然而数组的地址并不是它的第一个元素的地址,而是这个完整数组的地址开头

而且要注意,指针只能在堆上存在,,,而不能在一个函数的栈帧上存在,alloca可在一个栈上声明

借助指针,C语言还可以完成其它更高级的东西.比如函数.

下面我们谈指针中的函数指针,因为对于指针的那些用法来说,与函数的结合是最普遍的.
C和C++都不允许一个真正的函数作为参数,,将函数作为参数传送的办法是将它用一个指针去指向这个函数,,,,
如果指针这种东西,跟数组和函数联系起来,情况那就变得还好了
指针本质上是一个32位long int,所以函数的参数是一个关于函数地址指针时,它就表示对传送了这个函数的地址,未来实参返回时,可以改变这个函数.定义一个指针时可定义void*型指针(因为指针并不一定出生时就要指向一个对象或一块内存,而引用要求有一个初始值,因为引用本质是指针的别名),因此它可以被指定为0,即空指针,也可以被重新赋值(此时它就不指向它原来指向的对象或内存了),,换言之,,多个指针可以同时指向一个对象,你可以为一个对象定义多个指向它的指针(但是它并不拥有这一内存,也就是说,当它指向的对象发生了变化,指针仅仅作为指向这个对象在内存中的位置的意义就会失效或过时,它只拥有对象的adress值而非value值),而你可以通过这些指针或引用来操作该对象
为了学习起见,我们还是一步一步来了解其复杂性
Int  (*myfun)(int arg1,int arg2);
这就表示,myfun为一“函数指针”,它所指的函数以arg1,2为参,并返回一个int.
而Int * (*myfun)(int arg1,int arg2);就表示,myfun为一函数指针,它所指的函数以arg1,2为参,并返回一个指向int的指针.
当然,这里不存在“指针函数”之说(返回指针的函数还需要说???-_-;).
但对于数组和函数的结合情况来说,就既存在“数组指针”和“指针数组”了.
Int * myarray[];就表示,myarrary为一个int *数组,即一个由int *为内容构成的数组,是“指针数组”.
Int (*myarrary)[]；就是数组指针了.Myarrary是一个指针,它指向一个int [];
是“数组指针”；
如果把二者结合起来,情况就更复杂一点
Int (*mywhat[])(int arg1,int arg2); ---与函数结合讨论的情况下,[]是不会跑到括号外的.
(这样我们就可以根据上面谈到的第一种情况开始,结合后来的三种情况来推断)这就表示,mywhat是一个函数指针,不过有多个这样的函数指针构成一个[],因此mywhat是一个函数指针的数组(所以mywhat是myarrary),其中的每一个函数指针,它指向的函数以int arg1,2为参,返回一个int.
那么
Int *(*mywhat[])(int arg1,int arg2);
呢??不用我说了吧
	而且,通过函数指针和函数模板,可以很有效地实现业务逻辑跟界面逻辑分开以及多态机制(你看,设计模式能显式解决的问题---虽然设计模式也不是表现得很好,在C里面要靠拙劣的函数指针这种本来就表函数指针的东西旁敲侧击地体现,所以,C从来都不是设计语言,而是专家和怪才的语言)
在单根继承OO语言中(就是所有的语言级的first class OO对象都是从一个Tobject这样的东东继续而来,用户定义的OO对象也需要从这个根对象定义而来一样)实现泛编程的容器中,,比如JAVA的LIST中,一般用指向ＴＯＢＪＥCＴＳ的引用再填充这个LIST,这样容器里的对象不是对象实体,而是指向他们的索引对象,,,
指针是一种语言的抽象机制,而不是仅是语言用来控制低层的手段(指针指向变量,而变量的值是内存地址)

很显然,JAVA的LIST中的对象都是索引他们的引用变量,而非对象本身,是假对象．

###### 指针与位操作

首先C语言提供位一级的操作是为了迎合汇编语言,,回忆一下CPU的指令集,,有专门的位操作指令,C只是稍稍地将它们进行了下抽象(这样的话,C有了位操作再加上指针,它就成为系统和控制语言了,抽象不但隔断不必要的细节,而且在另一层维度上,提供了对于人来说更为强大的功能,这就是抽象的二大特征),对比一下我们就知道它们的差别并不大,,CPU还有OF,和CF这二个寄存器来表示移位和运算时发生的进位和溢出现象..
我们知道,在存储位的时候(更确切地说是一个字节级的东西),Intel的CPU是按高位在前(书写或打印时显示在左),低位在后存储的(在右).因此位往左边移的时候(因为左边是高位,位到了左边就占了一个高分位,整个二进制会按基数越来越大),就是乘以2的幂,体现在它的十位制表示会越来越大,C语言规定,一个类型的值向左移位的时候(右边会溢出不用),在它的右边低位加0,一直补满这个类型应有的位数..而这个值向右移位的时候,位到了低分位,整个二进制按基数2越来越小,,移了几次位就相当于除以2的几次幂..移位的时候,左边补0,如果原数左边是0,是个正数,那么还是补0,如果原数左边本来是1,是个负数,那么根据不同的编译器会采取不同的动作,有的编译器把它看成“简单算术右移”,最左边那个位还是补1,有的编译器会把它看成“逻辑右移”,,会把最左边空出来的位加0..
有人会问了,移位会不会把周围内存的位给挤了,不会的,因为所有的移位操作,只局限于这个类型的这个值,跟内存中其它值(只要它们都不参与此次位移运算)都没有关系..如果二个不同类型的值用一个二目移位符连接时,编译器会进行对齐操作以使它们有相同的位数..
位定义了几种运算符,有与(实际上不是逻辑乘,但我们按乘的原理可以得出它的计算方式),或(逻辑加),异或,取反,各种运算用在不同的目的下,与可以用一个屏蔽字屏蔽给定值特定位,就是把它们置0,,,,或可以用一个屏蔽字屏蔽给定值特定位,,就是用1去保留它们..异或可s以反转特定位..
这样所有的工作就成了找一个需要的屏蔽字(根据原值,,面向要作什么样的屏蔽要求,这二个因素)..

###### 如何学习指针

学C,,要学透就学指针,,,
学习函数指针完全是一种挑战,你能分别出以下的吗?
int *(*(*foo)(int))[5];
这个就他妈的表示:foo是一个函数指针(这就是括号带星号的结果-即把*foo括起来的那个括号),它指向一个函数(以指向它的指针foo命名的函数),它带一个int参数(即函数指针foo紧靠右的那个括号和括号内的int),,并返回一个指向数组的指针
所以,这样的语言留之何用??只能做做系统！！

> 类型和屏看原理,以及近看原理
要深克地理解C语言中的“屏看”原理,比如下面二个例子

void (int *p1,int *p2)

define mysub(x) x^3/x

在第一句中,参数是p1,而不是int,即不是*p1,我们优先看到p1,p2这样的变量,即参数是变量
在第二句中,define的是mysub(x)这个整体,而不是x,我们优先看到mysub(x),即define语句的整个前半部分
近看就是当有多个const在后面的时候,此时容易混淆const与它修饰的对象,而可以作如下判断:修饰词const往往与它修饰的变量最向内靠近,就像code block的花括号一样.
int *(*(*foo)(int))[5];
1.*foo
2.(*foo)
3.(*foo)(int)从这里开始,开始具有了意义
4.(*(*foo)(int))
5.int *(4)[5]
对于这样的模式与组合,要在大脑中形成触目即能理解的熟悉程度.
如果实在不能理解typedef，可以把一个typedef分解为多个子typedef过程来理解
	

###### 指针与数组

include <iostream>

define nums 10

/*
假设要讨论的是int *(*(*foo)(int))[5];
foo是指针？？？还是数组，要从这个大方向点去做决定
//背景知识：相关操作符优先级1,(){}自左向右结合2,*&自右向左结合
//我们一步一步写出结合步骤
1.*foo //这一步几乎不能说明什么，因为没有出现第二个操作符
2.(*foo) //(出现括号)foo强行跟指针结合,（到现在为止）这说明，它是一个指针变量了(但我们只知道它是一个指针变量)，
//因为我们是分步来讨论的，所以只能得到针对目前为止最近一步的foo的意义
3.(*foo)(int) //从这里起开始具有意义，foo是一个指向函数的指针，指向一个命为foo(这句有问题？),用int作参的函数
//即，foo是一个除了返回值暂时未定以后，其它的都定了的函数指针指向的函数(有问题？)
4.*(*foo)(int)  //对这个函数指针，进行*。要分清*用于定义和求值时的差别，此时，foo成了一个二层指针。即句柄。
5.int *(4)[5] //foo句柄的数组。每一个元素，都是一个句柄，句柄的第二层指向的函数，形成一个函数指针，这样的函数，返回的值是int*;

*/

using namespace std;

int *(*(*foo)(int a))[13];

int main()
{
	cout<<sizeof(foo)<<endl;

	return 0;
}


###### 字符数组与字符指针

include <stdio.h>
include <iostream>

using namespace std;

char mychar[90] = "dsfasdfdsafsdf"; //数组的char

char *herchar = "dsfsadfsdafsdf"; //指针的char


int main()
{
	cout<<mychar <<herchar <<endl; //所有的东西，都取决于名字的静态类型和特性
	cout <<&mychar[0] <<&herchar[1] <<endl;
	cout<<*mychar<<endl; //mychar表数组名，因此名字是一个指针，是一个指向数组（开头）（第一元素）的字符指针，如例，用*mychar可以展现出来。
	cout << *herchar <<endl; //herchar表指针，因此自然地，*herchar得出d
	cout<<*(&mychar[0])<<endl; //由于mychar[0]是元素，因此&到地址，但输出的语义却是“从这个地址开始输出整个字符串从这里开始的部分“
	cout<<&mychar<<endl; //对“元素取地址”，和对数组名（它是一个变量），取地址。如例，这样才能取到地址
	cout<<*(&mychar)<<endl; // 这句相当于cout<<mychar<<endl;因为中间等价于mychar
}


###### 指针的意义

C是系统编程语言,,一般谈到对系统编程,,,就是数据结构加算法(数据结构加算法是系统的观点,,所以容易跟C语言结合,,,C语言也因此被用来系统编程,当然,系统编程的真正概念是指:socket,graphics,IO,Gui这些平台支持逻辑相关的层面),,,编译器前端的构造就是一个大算法,,,运行时就是一个大数据结构,,,操作系统作为语言运行的环境,,考察它的实现过程,也是数据结构加算法的集中体现,而这些东西,基本不可能不涉及到指针.
如果你真要学透C语言,,,,第一要学习C语言是如何来的,,这就是编译后端了(动态运行期的类型信息),,,第二要学习语言本身的机制,,当然重点是指针..因为指针不单是内存地址,,,而且是一种语言的抽象机制,,,C语言只有指针这种抽象机制,,就像C++的OO,范型一样
**指针是一种抽象概念和语言机制**(比如引用也是这样),它可以用地址的方法实现,所以一种是实现,一种是方法,绝不可混淆
就跟web和http一样,一个是平台,一个是协议,web并不等于www,当web上主要的内容不是用http传送的文档时,那么实际上web可以更多地是非文字信息的html.
根本上引用只是一个指针的别名,因此你可以由一个指针得到一个或多个引用(即关于该指针指向的对象的引用)
一般来说,引用常常跟const在一起(加上const只是为了强制跟保险),那是因为定义出来的引用常常不会改变
其实C也可以表达OO(不过它并不承诺一定要实现运行期多态,继承等OO语言的标准技术,,有一本《C支持面向对象技术》的书讲解到了相关的技术,但是,OO,并不应是C的任务[用C实现的OO,实际上是并不鼓励的,因为那是C++应该做的事,因为C级的OO是不应该成为标准的.C和C++应该只管好自己的职责.这也是Python提倡用一种方法解决一种问题的初衷.])
网上有用指针实现C++的OO的文章,,读完它,你就发现C通过指针机制还可成为设计语言,,,什么是设计语言呢,,C++,ＶＢ,ＲＵＤＹ,ＬＵＡ,ＤＥＬＰＨＩ都是设计语言,而C就是底层语言．

> Todo:这段移走
当然,如果OS不需要开发,那么它不需要一个编译器的前端,语言只是为了开发应用而出现的,OS可以不要它(语言编译器也属于系统软件),更确切来说并不需要一个编译器,,它只需要一个编译器的后端,比如运行时,或者仅仅一个解释器.有了这二个就可以执行源程序了,这二者之间的接口要明白,因为解释器可以直接执行编译器前端生成的中间代码



*/