第一种编程-硬件控制及硬件系统编程,OS内核的原型
=============

在导读中我们讲到编程并非天然一开始就集成在PC内部的,会编语言和裸机会编是历史上集成了编程在PC内部的组合的第一种形式,而且会编编程是有它的局限的.

而且编程有二种,一种是实现，一种是抽象和封装






实模式编程实例举例
-------------

OS的原型实际上就是我们在前面讲过的，完成自动化任务的会编程序的高级语言化。

这就是OS内核的原型
-------------

Xxx

###### 小结
从以上对裸机的介绍和对汇编语言的介绍中,我们可以得出最初的编程到底指的是什么.学习这个有助于我们弄明白编程的概念并将其介定下来,所谓编程,其实总有一种编程就是用机器语言[1. 当然,用高级语言的封装形式也可以驱动机器]去驱动机器本身,这也就是说,最初级的编程,是一种用低层的指令直接描述硬件如何运行的“编程”. (而此时你的眼睛扫过书本,发现本书接下来的部分还有几百页,你于是想到:在本书的接下来可能会谈到某种与机器编程有别的其它高级抽象编程[2. 这就是我们会在本书后来讲到的,脱离了系统编程的应用编程]). 首先,计算机各个部件都是有功能的(BIOS),计算机在硬件级和机器编程层面能做的全部事情就集中体现在BIOS 可以这样说,裸机的功能就是BIOS里定义的那些功能,此时并不出现OS. 比如浮点器可以表达浮点数并处理,计算机籍此可以直接表达硬件级的浮点抽象以及用浮点表达更大的编码了的抽象(实际上也存在软件的浮点处理器),这就为编程引入了浮点逻辑.另外一个道理,你不能编程指使PC为你做“给我泡一杯牛奶”之类的事情,因为它不是硬件上能提供的功能和逻辑所在(即使是抽象也得不到),只有当PC真正接入了一台牛奶机之后,你才能编程实现诸如泡牛奶的硬件功能. 计算机的功能不但在于表达硬件逻辑,而且更大的地方在于表达广泛意义上的应用逻辑.[3. 如果说最初的计算机就是科学用的数值计算机,那么当计算机发展到接入了图形设备的时代之后,它的职责本身就随着功能发生了质的变化,此时,它成了一台“PC”.而且,随着高级语言的出现,以前使用汇编调用指令进行计数和控制机器本身重启,初始化的低级方式.变成了由程序员来书写一句一句的“语句”,使用这些语句可以在高级层面描述逻辑(当然,其本质上也要转化为汇编的机器逻辑).而且减少了程序员需要对于控制机器本身的动作(因为这种编程可以实现一个软件上的OS,解决机器控制的问题,和给计算机导入一个软件层面使计算机接上各种人群),或仅仅进行机器编程时代的事情.]我们可以对PC编程创造一个游戏,虽然图形功能是来源于显卡的,但是游戏世界的逻辑明显不是硬件的.Web应用就是这个道理. 但是无论如何,学习到了这里,我们该学习的都学习完了,感谢上帝. 让我们总结一下,BIOS是计算机功能发源.这样才能懂得编程的出发点和目的.这些硬件功能固然是计算机功能的重要组成部分并影响对其的编程工作,然而并非全部. 缺点:

可见,对机器编程的发展十分有限,一方面汇编语言用机器的语言描述机器,另一方面,纯裸机的功能也十分初级和有限.因为它仅仅提供了初级的程序执行所需要的时空资源(实模式),这种工作方式的程序只是指令集而不是程序.由指令集组成的机器程序直接对所有的硬件进行操作[4. 会编的机器仅能很好直接做计算器这样的东东(那些现有指令能做到的).指令能描述的“软件”的抽象手段,是极不显式的,和极端低下的.这样的软件,我们还是称为指令文本比较好.或者,机器命令序.],编写的工作量十分巨大,在机器级别编程,我们无法表达高级的应用逻辑,因为0,1能直接编码的逻辑是非常有限的,而且这样的直接访问机器的程序容易发生越界行为,真正的程序需要一个受保护的执行环境,不对硬件造成异常,也不会对自己产生崩溃,只有当PC发展到提供了操作系统,进程(操作系统对于程序的意义就是操作系统能执行程序,给程序CPU和IO时空资源)等高级逻辑之后,我们才能在一个新的工作起点上构造更强大的系统逻辑,或应用逻辑.

当然解决程序执行的问题只是一方面,对于寻求更强大的系统功能,其它机制,比如网卡代表的网络,显卡代表的显示,也要从软件上去拓展.甚至具体到用户的认证,磁盘的配额问题等高级硬件逻辑. 这也就是说,不光是解决语言问题,平台问题本身也是一个问题.

这种机器和这种编程是注定要被抽象的.

所幸的是,当裸机发展到OS,编程发展到高级语言阶段之后,这些机器的细节都被完全抽象成更强大的功能了.而系统编程,也不再是用机器语言跟机器直面交谈了 那么为什么要出现这种历史现象呢?为什么这二件事是一起发展着的呢?这就是平台模型与语言模型. 会编与裸机 系统编程高级语言与OS 脚本语言与虚拟机


