原生os与组合OS
=============





架构与组件
-------------

一个os 的架构应是这样的：vm level ,task level ,sub system （win 32,64,etc）level ,service level （内置进程）,那内核分发level .然后是具体分发版的app compent （the app foundation level ,the domain logic level .and thats all）

一个os的开发无非这几个大件，kernel（io,task）,driver,langsys（native.scripting）,sdksys（ddk,pdk）,appcompent（gui,db,fs,etc...）domainframewks（web,game）

其他boot,hal,sys call sys ,deskenvirment sys,等都是小件


桌面编程(net,io,gui)，然后借用一个GLIBC，一套linux core就可以了，其它desktop level级的东西自己发展，或领域专门的东西自己发展，你看andriod这样的平台这不就是这样出来的吗


andriod是一种组合平台，如果PC上的LINUX是标准平台的话，那么anriod这样的mobile os,web os，就是专用OS了


桌面开发的那些轮子已定型，再发明一个更好的也没意义，不是比较起来好用不好用的问题，而是没有必要没有时间去考虑这里面的问题了， 
还有更多的问题去考虑，所以先这么着吧 

业界早已不屑于去发明轮子了，连操作系统都直接用名声好的组件，如移动平台架构中，安桌用SQLITE，OPENSSL，SYBIAM中用QT。。。
mobile平台是linux战胜windows的阵营，是开源化战胜商业化的前线。 但是，它也同时扼杀了windows阵营的创造力

开源杀死了windows的创造力，linux提倡库即应用(如桌面环境等必须有一个库在背后撑着它)，所以往往造成分发配置对一般人而言显得困难，windows提倡开发与应用分离(window不假设你是一个程序员来使用它的产品)，实际上前者是一种后进

WEB开发太少实现ABSTRACTS了，其实，这反而是未来web开发，mobile开发的潮流（JAVA成功从WEB转型到mobile）,这也是“编程工业应是接口组合，积木搭建”的现行形式,所谓积木就是jfc类库。

框架使os成为专用os,如webos,gameos.


windows就是小而精,linux大而用仲，连手机平台的比较也是如此，epage依赖的库都是小而精的，不是大而杂的 
如果让微软掌控了WEB，那么XML这样的东西可能压根不会存在(那是开发者用的东西)，还有tcpip这样的东西 
linux没有在桌面占据多少市场，却在桌面服务端和WEB领域，甚至mobile领域都大有建业

语言系统与SDK库
-------------


就像直接用OO作为标准一样，有些库也成了标准。


为什么一套os的src中总是看到libc这样的东西，这是因为：os必须要提供一个nativelang system

在提供lang sys面向开发者方面，一个os在语言设施方面应当提供平台实现语言，平台开发语言（这两者往往可以采取同一或同系语言，比如c++）领域应用高层语言（一般是脚本语言如py或更强大的vm类语言如.net,java）这两套语言最好不用进行语言间的binding,如objectivec,cppscript，详见我以后会谈到的NO OO CPP方案。

一个OS为LANGSYS提供的标准库应用：语言级的DS，DP，平台级的PDK，DDK，APP框架级的FC，DOMAIN框架级的DFK。

一个os apisys往往有devicedk（使用虚拟硬件也最好提供）,platformdk.这两者内部也包含各种sdks.如设备类按设备class，平台按平台组件（guisdk.dxsdk――使用软件类组件也最好提供，etc…）

会用distuils这样的东西，就不用py2exe这样的东西了

比如py库中有专门的disutil模块，wtc也有这样的模块 
语言体系中，形成库即应用的根本技术是源码包的发放技术 

还是linux用开发眼光来看应用好啊， 从distuilds与py2exe之间的关系就可以看出来了,可以做到一了百了。windows与linux的差别就在这，比如linux分发程序都用pkg mgr。。。

为什么在选用windows的情况下却不选择mfc,必须承认，我们程序员必须跟着时势走，由于开源界的强大和微软在新时期的妥协，在桌面领域（多媒体开发领域除外），微软集成在系统内的桌面组件不敌大量声誉良好的开源品和第三方产品

如db领域不及mysql和甲骨文，即使mfc做得很好（况且它做的不好），它内部的桌面组件不好，基于它们的afc也不会大卖，在当代，鲍维尔时代的微软在服务器市场不及linux,在web,mobile不及linux系，比尔时代将一切桌面开发做的充分远离程序员的作风被提倡编程化的linux,被提倡编程和面向程序员化的风格重新赶超和打压，这是每一个程序员，特别是桌面程序员必须要明白的“历史遗留或超前现象”

mfc并没有集成对声誉良好的桌面组件的封装，它仅是对win32sdk的，单平台桌面领域逻辑的封装，所以，qt这样的封装了gui,sqlite.mysql.opengl这样的声誉好的桌面领域逻辑，提供桌面开发接口的库理应优先被使用。（当然，例外情况永远是opengl不如dx运用广）

组件与应用
---------------

>Linux还是Windows? Windows和类Unix比较的问题一部分是CUI和GUI比较的问题.就专业编程来说,一般提倡在CUI下而不是GUI下,编程为什么要在命令行下而不提倡在界面下呢,,这是因为命令行下有界面,而界面下人们都往往不觉察到有命令行,而其实命令行才是本质逻辑,界面只是一种GUI,是一种建立在本质逻辑上的用户接口和配置文件(只是一种不必要的表现抽象).真正的逻辑可以不需要一个图形界面接口来展现它,但强加了界面接口的逻辑就限制了逻辑本身的表达..因为命令行是观念里自由的世界,是C这样语言开发时所面向的直接世界,是计算机逻辑发源的真实世界,所有计算机逻辑的起点是命令行的(仅需要文字界面这样的用户接口就行了),图形用户界面逻辑只是后来的后来需要考虑的东西..所以开发时不免将界面逻辑滞后,而实际上,无论先后顺序还是本质特征,我们始终都要把握一个观念,即其实命令行比(图形)界面丰富有趣得多,我们始终要相信,虽然我们在Windows下长大,但其实命令行才是主流,才是我们的思想和开发根据地. 可执行文件在Linux下是预编译包,比如DEB下是DEB包,Linux有二种生成可执行逻辑的方式,一种是DEB包分发,一种是从源程序构建(这得益于Linux shell下强大的COMMAND TOOLS,比如MAKE,这说明OS跟开发之间的密切关系,WINDOWS似乎并不是一个为开发而结合的系统,这就是人们常说LINUX是怪人开发的给怪人用的OS的道理developer oriental os,比如它的shell,实际上是一种编程而不是应用的最直接形式,因为它是对功能的调用,不是应用本身.), xml与html,oo与函数式编程，就像windows与linux的对比一样，前者太专业了(虽然它很科学)，但反而成不了市场主流。 UNIX下的那种Shell操作(shell是语言,用语言表达的应用自然比直接的GUI部件表达应用更强大),命令行工具和管道理念,从用语法操作的角度看，远远比Windows菜单有效率(当然,命令行最普遍它的门槛却很高),因为本质上,命令行逻辑的一条语句"ProduceMenu(10000)",屏幕再大,也不可能生成10000个菜单供你使用..而在命令行下,一条命令可搞定这样的逻辑,因为命令行是没有界面限制的观念世界(图形没有文字表意丰富),形成计算机逻辑的一层一层是是命令行的,,C开发时也是命令行的因为C的库全是命令行的,Windows API接口是C后来的产生GUI的一种方式,C是面向命令行的,它面面系统底层,并不一开始就将界面逻辑纳入所有的逻辑开发中.. 可是在另一方面,WINDOWS GUI后面的那些东西给我们学习最简单的计算机原理带来了障碍(甚至是偏离计算机本来面目的惯性思维,相比之下,对LINUX的学习就比较接近计算机本身),当要对计算机进行再高阶的开发时,又不可避免地要涉及到计算机底层(你看,再高级的RUBY都要学习数据结构这些底层思想),,这造成的结果是罪恶的,,这就相当于穿上一双做得不彻底的鞋,跳出去,,却最终没能跳得彻底,只能跌倒,照样使得脚受伤．．WINDOWS在封装复杂性上做得不够彻底,,导致了二面性．．所以,评论LINUX和WINDOWS谁好谁坏,只能是一种在各自的领域里为自己说话的动作,,,实在不值得为这个花时间 由于ＬＩＮＵＸ跟开发直接相关,,可见这种机制不但用于分发,而且还用于执行,,为什么Linux下提供这种机制呢,要知道,我们这是个软工时代,库之间的引用逻辑错综复杂,任何一个单位或个人都不可能不用别人的逻辑来进行开发,LINUX是跟开源紧密相关的,而非WINDOWS大商业大教堂式的开发,这是开不开源导致的最根本的区别所在,,linux的deb预编译说明什么问题呢,,,所有的移殖问题都是逻辑兼容问题,,有的移殖直接跟CＰＵ＋OS有关,有的移殖跟库逻辑有关,,移殖时,不光要考虑CPU+OS的这个大的平台逻辑,而是要考虑它间接或直接涉及到的库的逻辑的移殖问题,比如WINDOWS上VC的编译器还带了一个msvcr80.dll的特定编译器相关的逻辑,需要被动态链接在用VC8产生的EXE逻辑的体中,,,,是完全按它的全部逻辑来的,问个问题,是不是ubnutu上的一切软件,只要unbuntu本身被移殖了,那么它上面的一切APP都可移殖,不是这样的,这需要要讨论一下UBNUTU本身由什么逻辑组成,比如UBNUT的桌面用GTK+/GNOME实现,那么KDE程序就不能运行在这个桌面上,除非你的UBUNTU上有了QT库逻辑,才能拥有二个桌面,GNOME逻辑不包括应用程序,,而KDE包括QT库,包括KDE桌面不说,还有KOFFICE,KDEVELOPER这样的应用逻辑,所以KDE不单是一个桌面环境逻辑,还实现了这个桌面环境上的很多应用.