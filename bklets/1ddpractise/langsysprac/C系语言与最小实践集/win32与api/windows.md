
多用OS的总架构
------------
os 应首先设计为vm ,其次才是windows 或linux 这样的具体操作系统

就像操作系统不满足它们只提供一个OS一样，编译器，如GCC，也不满足于只提供对一套语言的支持，，所以，理所当然地，OS也有它的架构（产品和程序实现方面的）

OS内核应有框架吗？什么是OS实现中最重要的那些算法（CPU，内存负责的，外部设备参与的，，任务过程和IO过程），

不妨把内核实现编程想象为普通的用会编来控制机器，产生例程，它并没有一个框架的东西

os应有多复杂，，它封装了机器，提供了应用RUNTIME也就够了，再就一个IO层面的东西

宏内核一块在内存，并不作对进程的影响，它只提供逻辑上的机制，而微内核，强调用进程加内内核完成内核本身，直接与内核交互

OS上的算法问题是一致的，，策略问题却各有千秋，linux主要依赖C抽象，WINDOWS依赖OO C

linux下任务即进程,,实际上，在类unix OS的实现抽象中，总把进程当成了虚拟CPU代表的虚拟机，而文件是后来接入的PC子系统，，在内核中的实现抽象代表，，进程还是第一位的

WINDOWS将任务空间仅看作PURE内存，因此有可停靠，可替换

WINDOWS的进程只是页面容器

unix在内核，特别是在进程级，没有像WINDOWS一样立即设置安全机制，所以，它并没有IRQL，角色管理进程等机制

理解方法
--------------

就像我们在软件系统的出现那一节讲的一样，对具体OS的研究，也可以遵守透过OS和不透过OS来研究的特点

理解操作系统抽象和体系，至关重要的是一切从硬件逻辑（堆栈机）和系统调用（软件堆栈）出发，这是一条便于理解的，无路不通的线索 
越过OS的硬件调用和通过OS的硬件通用区别在哪,其实都是CPU加内存的堆栈逻辑，不过后者是软件托管的，它基于前者但模糊了前者的抽象，将它们提到一个新的抽象高层（其中有进程等） 

理解系统实现，就是精确理解常见操作系统抽象的作用地位，角色，它们如何组成一个操作系统并发挥作用，相似的抽象到底有什么本质上的区别，做到不人云亦云 


原来的实模式下，主体有三个：cpu,memery,io device----->程序有一个，即指令系统

越来越面向软件抽象（OS实现）的硬件连线实现，比如ACPI PC专用指令
1，CPU的中断，寄存器，微代码,,内存（无）：虚拟PC CORE
2，驱动器的中断，，寄存器，，微代码：文件
3，进程中的文件与进程中的文件IO，进程中的调度与进程间调度的同步
以上三者，进程与虚拟PC ALL,,以进程为单位调度，进行IO

>>CPU无调度执行绪的硬件基础,,新CPU实际上某种面向OS的硬件，，据说还有直接支持软中断的ACPI

现在的软件抽象模式下，任务是软件上的抽象执行机制，主体有三个，内核VS进程VS进程体-------->有3种抽象任务：硬件规程，内核例程，用户进程,,内核态与进程态应该是对各自开放的，进程间隔离，那么进程/内核是不是隔离的（内存不隔离但代权隔离是平坦的，，对他们的访问隔离）在CPU眼中，内核代码与用户代码是一样的地位，这就是说，没有C/S关系，就像线程与进程是一样的，都是去掉任务空间的执行绪

几种程序，如何切换，交互执行。
1，硬件例程,,bios中有中断处理请求，和处理例程
2，内核规程
3，用户进程

>>虚拟内存有从硬件开始到内核MM模块的支持，而进程调度，在硬件级没有直接支持，一切尽在内核中软件实现
>>线程好像只是纯软件逻辑（它代表执行绪），进程才有硬件基础的支持，线程好像只是如何使用进程的一种策略，进程是线程的机制
>>原来，执行绪，调度也是有硬件基础的，那就是各种门,,对应硬件平台没有实现中断优先级怎么办？
>>软中断，，就是软件上的事件机制，，硬件机制是硬件上的事件机制,,系统调用，就是进程级，即VM级的中断，所以是作为OS的软件中断的一个体系，，常用某种特定中断权级的例程，，来实现

外设的IO stack通过驱动接口，与内核交互，手段是利用中断请求和实现在驱动中（属于内核模块的那一部分）的中断处理例程。并受内核的调度。


要分清，1，在内核空间的代码。2，由CPU在特权状态下执行的代码，这二者的区别

真实CPU只有一个（不讨论多核情况下），虚拟多个CPU，为进程提供执行表示和调度机制，虚拟内存为进程提供内存体表示和页面调度机制
文件为进程提供外设（IO体----在C语言实现的内核中常用handle，struct,等数据结构表示）表示和请求例程调度

内存地址空间只有一份，CPU态（用户态--不能称为进程态，特权态--不能称为内核态）却有二种（用户空间，进程空间，这里的空间不但是内存空间还是指令特权状态），中断态（内核规程-它们主要是函数例程，，实现优先级）却有很多种，它们进一步在OS实现中，形成了抽象任务系统与抽象中断系统。


抽象任务与交互：多任务的并发，协调

抽象IO与并发：欠套的中断,,可接入更多的智慧单元

CPU管理内存，MMU只发挥一个存页表功能，产生缺页中断时需要CPU介入（在硬件级并不能完成，需要在内核实现中实现这方面的动作逻辑）产生缺页中断和中断调度，脱离任务概念的页面调度（仅是内核的机制，独立于进程，与策略使用无关）


内核往往由CPU在特权级执行，，它是是一系列最重要的C函数例程和结构，不可中断和换出（不受调度），还存在很多例程，需要很多其它级别的中断级。因此提出了抽象中断系统

CPU负责IO过程，参与任务过程，调度是指CPU的调度还是内核的调度，CPU提供机制，内核提供策略，内核的策略又是进程的机制。

用户空间是一个进程最显著的特征，线程好像代表并发(thread好像是并发的代名词)。

中断是通用意义上的异步事件功能，它：1，实现在内核中，2集成在BIOS中，，3，实现在驱动程序中

<b>调度不是任务级的概念，而是软件PC级的概念，它只是进程为单位调度(以进程为单位执行代码（CPU），处理资源（外设逻辑），完成虚拟计算机的任务。)，进程再代理这些调度给进程内部的元素</b>，调度代码本身也被调度，进程间通讯，是内核对进程的调度，内核从不服务这个过程（比如以任务C/S关系），它只提供逻辑上的机制，内核与外核程序是独立的。



语言级的东西
-----------------

由于本书focus on desktop，所以对OS实现的讨论，只讨论它们形成的一切机制关乎它们引伸到桌面级的那些部分，如qt如何封装windows的线程，异步IO，提供相应的QT封装对应物，以及为什么要这样做linux的做法会不会有所不同（基于windows,task,io的特殊性----such as asynchronous IO API (a typeof overlapped IO on Windows） 

windows的对象系统本质是什么,,（高级语言完成的可执体，执行中总会形成函数级的例程和调用---以会编语言的眼光来看）

内核是C callbacks(C语言完成的内核实现，内核执行体当然只有函数和数据结构之类的东西，而且大量用链表之类的ADT及算法来组织逻辑),引导后常驻内存某个位置作为服务性执行体（作为软件的平台），进程是内核的一种机制，具体进程体则是策略品。

它不是OS实现的东西，即不是算法上的东西，而且跟现今所说的OO也有很大的区别，它着重于语言技法的应用和设计，和对资源（语法元素）的统一管理。以在API的提供与kernel实现之间求得一个平衡。

消息，实际上是winapi的一种api,,就像qtc++的那个signalslot一样

windows的对象系统也是语言技法与应用方案的结合，，跟消息/信号一样，，，它完成的是细粒度的资源统一管理，，，，，真正的面向对象也是的资源管理系统和语言手法
Layeredmodular versus monolithic services
内核的架构主要是考虑哪个模块架构于哪个模块上，这实际上并不是统一的，比如，有的OS，将虚拟管理架构于任务机制上，有的OS则反之
微内核就是用操作系统技术实现操作系统(就地取材，比如，用进程实现内核的东西)



windows
================





架构
--------------

Vm level

然后，一般都是内核中的任务层

task level

然后是子系统层

subsystem level，如win32,win64

最后是分发层

distributor dll level

wine ,其实是某种windows 分发版的“接口层”

分发
-------------

the win32 as pcclient

vs linux
--------------

Linux core
文件系统或任务系统，微内核只实现这二个,甚至只实现这二者中的其中一者. 其它诸如任务间的通讯,网络,等,如果一个内核还写入了这些逻辑,那么它就是一个宏内核. 其实,windows的内核是不是一个微内核(win32是kernel的子系统,所以,windows内核是操作系统的操作系统,在这个意义上,有点微内核的意义),这取决于我们于历史上对微内核的定义,具体一点说,最终取决于我们对内核的定义,因此讨论操作系统我们只需讨论操作系统内核便可一窥其端倪,我们在下一章将讨论巨内核的Linux Core[21. 相比之下有的系统内核是微内核,这种内核基本上只提供对进程,内存管理,图形,用户界面,这样抽象层次的封装和架构逻辑而不实际实现它们].

Linux内核是一个工具实现库,而并非一个逻辑上的架构抽象库,它是一种巨内核,即直接在里面实现了它作为OS内核而言的那些基本逻辑(进程,内存管理啊,网络啊,文件系统啊),而不是微内核,即那种虽名为OS内核,但在内核这一级并不迫切于实现如上这些实际的OS功能,而是把它们放到内核之外的下一层抽象层次上(把它们作为系统的非内核部分)再实现的内核.这样整个所谓的内核部分可以预先考虑一些其它更重要的事情,比如提出一些架构上和扩展上的考虑,籍此就可以为后来的基于这个内核的系统扩展预留很多的扩展空间.这其实也是抽象的作用之一(提出一个中间层来解决问题的抽象手段).其实,Linux Kernel也并不就是没有任何架构,它的架构在于它在内核级只实现对于一个操作系统的设计来说最为至关重要的那些抽象,那些硬件访问功能,CPU资源转化成进程,永远是最底层,最应该被首先解决的逻辑,,至于其它的东西,比如界面通常被放到这个过程的后面(作为用户级的App存在),,而不放在内核级.这其实也是微内核思想的另一种变相.LINUX先是硬件逻辑,再是语言作为中间层,用户程序SHELL等,作为用户空间,这种架构很模块很科学

具体到小的方面,比如所谓的内核中,也其实存在不同的抽象层次.比如linux就是一体的内核,它把进程,进程间通讯,(很明显,这二者存在抽象层次上的不同)诸如此类的东西.整合到了内核中.把这个整体称为内核.而windows可能不同,它把这个所谓的内核,再细分,把进程,进程间通讯,隔开成为内核中的二个层次,因此,如果linux中的内核是“内核的标记参考意义(即,历史上的内核都提供进程化了的任务这样的东西,而且统一把进程相关的逻辑,不管它是进程本身,还是利用进程并服务于进程的“进程间通讯”逻辑,都放进这个所谓的内核中)”,那么windows关于进程的那部分,就是“内内核”了. 作为一个OS内核,我们猜想:Linux Kernel中必定首先有一个是沟通硬件和硬件驱动,使硬件可以运作起来,为软件逻辑开始服务的工作的层面.即硬件抽象层,它解决的是驱动硬件为软件服务的功能.

内核,其实只要实现文件系统或任务系统,当中的任何一者,就可以称得上是一个os kernel了,dos没有进程管理,只有文件管理. 所以,内核还包括网络逻辑,文件系统逻辑,等,而不光是任务逻辑 C 注意,这个网络逻辑,文件系统逻辑是OS层的概念,不是硬件依赖的那些概念,即驱动程序,只是硬件抽象层要解决的问题,一个os core可以不将硬件抽象层和驱动程序作为其部分.这些只是可选部分,支撑部分,os core只是要完成属于OS自己的任务逻辑,网络逻辑,文件系统逻辑部分,就够了 OS CORE如果还包含驱动,那就是巨无霸了,所以OS CORE,是可大可小的概念,一般的OS CORE,指那种维持在OS CORE级的东西,比如任务,文件系统,网络系统,等等

分段机制

分段机制中有二个重要的数据结构:段选择符和段描述符,一般是从段选择符中的某些字段,,组合出这个段的描述符,....有gdt,,ldt这样的东西.,采取了表的模型,有描述符高速缓冲,段的大小可大可小(&lt;4G),一个进程的各种段可以在一个4G的线性地址[22. 当谈到线性空间时,它指“任务的线性空间”,,,,,,,,注意跟“进程地址空间”分开.]内重叠存在.in
分页机制中有页表,这样的数据结构,采取了文件夹的模型.有TLB,片内页描述符高速缓冲.页的大小固定全局选择和和段描述符存在于内核或用户进程的高端地址部分.一般来说,段选择符中放置对内存中存放着它所指的段描述符的指针,而内存中实际放着描述符这样的数据.

Linux为了兼容大部分CPU,设置了一个page middle directory
注意:操作系统内核[23. 操作系统代码段]本身没有分页机制的支持(?操作系统代码段,存在于任务的第3G开始处,是一些页),它只是实现. 操作系统段是全局段.gdt

应用和开发上的不同性

要知道windows也存在客户端与服务端的区分，如sqlsever这样的系统组件，就不集成在客户端，windowspc客户端几乎不要求什么伸缩性和压力，虽然在客户端它的界面比linux顺畅，可是在服务端，它的伸缩性是不及linux的，这个决定权在内核实现中。

而且,linux是developer oriented os,它提倡，应用即库，程序的发行跟源码包的发行紧密相联，发展出包管理器之类的东西

windows io
-------------

windows扩展了硬件中断，在硬件中断和一般进程间设置了DPC这样的东西，多级“为中断”决定了它在软件上也设置了多级中断权限，比如只有硬件中断可以中断 DPC


demo与全功能的产品线区别体现在任何级别的开发中，在抽象体系大小，提供产品多少上都迥异，比如在os开发中，demo os往往提供一个核心加个shell就很不错了，可是reactos是作为一个全功能产品线而存在的，它的源码复杂到提供内核，驱动，语言，aui，还有docgeneto 
它的源码复杂到提供内核，驱动，语言，aui，还有docgenetor,compile mk login,dll genetor,c level OO language technology等等 
windows在内核级整合了oo.用对像的方法看待对一个称为操作系统的领域（它的内部逻辑和外部应用方式），这种抽象粒度（为对像很好地分层）完全迥异于linux就事论事直接表达进程等概念的做法（整块性方案），windows于是就可以形成操作系统架构的东西。而linux完全不这样做。 
这种区别还体现在：windows可以借语言的支持（假设有那么一种oo C formed cpp）实现对操作系统对象的统一管理，比如为它们分层级，为它们命名，销毁它们。所有oo语言提供的好处它都可以有。因为它将操作系统领域看成了对象系统。 
一个os的kernel应首先是处理它关于硬件逻辑的东西，如mmu,timer,trap，然后才是常见的内核逻辑如mm,iom（dm）,sched,所以一个os的架构往往是：硬件抽象层加msg 机制，初步调度逻辑，然后上面是进线程，mm,等 
任务机制分为两层，一层是内内核层的时钟逻辑，内存，io同步逻辑，在外内核层才是常见的进线程，lpc，进线程级的同步 
cpu:sequences thorough instructions while referening memeroy 
线程出入于内核模式和用户模式，导致态的切换 
hal只是一个抽象上的backend？ 
操作系统没有架构就谈不上像windows一样支持多种子系统（在抽象上为每一个子系统提供backend）,语言系统也是如此，g++支持那么多的编译器，同样是一个核心多个后端。适配作用的后端。 
in windows,the iomgr is the heartof io system 
同步是一个动态随机的过程，不可能在最初作一个一次性的规划的过程。 动态随机抢占就是这个意思

debug programming严格来说是系统编程的一部分，windows在它系统实现的哪里提供了debuging接口 
作为driver实现？在kernel中？为ddk所用？那么用户级的调试呢
在windows架构中，内核线程是“内核app”，用户空间（全称，软件托管机的用户模式空间，即os的执行框架中的用户程序空间）才运用“系统进程，系统服务进程，用户程序进程”，从内核的眼光来看，都是c call stack 
内核为啥快，gdi放进内核为什么就快了，因为1直接硬件访问（当然得透过驱动），2不受进程级的调度，不需lpc通讯，那些都是大粒度的，3仅受内核调度，优先级高于普通进程，4粒度小，以pure c call stack 运行。 
os就是软件托管任务运行机，带这个眼光去看它（主要借助内部的MM，IO和调度）如何与编译器合作，加载可执行体映射到托管机，以运行程序，那么一切都会明显 
底层的packet based IO，像极了network过程 
活动的东西才有上下文(当时的上下文)，如进线程 
